/* The MIT License (MIT)

Copyright (c) 2013-2016 Chananya Freiman

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */
"use strict";
// Normalize file paths to lowercase, and all slashes being forward.
function normalizePath(path) {
    return path.toLocaleLowerCase().replace(/\\/g, "/");
}

// Given an array of Image objects, constructs a texture atlas.
// The dimensions of each tile are the dimensions of the first Image object (that is, all images are assumed to have the same size!).
// The resulting texture atlas is always square, and power of two.
var createTextureAtlas = (function () {
    let canvas = document.createElement("canvas"),
        ctx = canvas.getContext("2d");

    return function (src) {
        let width = src[0].width,
            height = src[0].height,
            texturesPerRow = Math.powerOfTwo(Math.sqrt(src.length)),
            pixelsPerRow = texturesPerRow * width;

        canvas.width = canvas.height = width;

        for (let i = 0, l = src.length; i < l; i++) {
            ctx.putImageData(src[i], (i % texturesPerRow) * height, Math.floor(i / texturesPerRow) * height);
        }

        return { texture: ctx.getImageData(0, 0, canvas.width, canvas.height), columns: texturesPerRow, rows: texturesPerRow };
    }
}());

// Compute the spherical coordinates of a vector (end - start).
// The returned values are [radius, azimuthal angle, polar angle].
// See mathworld.wolfram.com/SphericalCoordinates.html
function computeSphericalCoordinates(start, end) {
    var v = vec3.sub([], start, end),
        r = vec3.len(v),
        theta = Math.atan2(v[1], v[0]),
        phi = Math.acos(v[2] / r);
    
    return [r, theta, phi];
}

// A simple incrementing ID generator
var generateID = (function () {
    var i = -1;

    return function () {
        i += 1;

        return i;
    };
}());

function TagToUint(tag) {
    return (tag.charCodeAt(0) << 24) + (tag.charCodeAt(1) << 16) + (tag.charCodeAt(2) << 8) + tag.charCodeAt(3);
}

function UintToTag(uint) {
    return String.fromCharCode((uint >> 24) & 0xff, (uint >> 16) & 0xff, (uint >> 8) & 0xff, uint & 0xff);
}

function mix(dst, ...args) {
    for (let arg of args) {
        // Reflect not supported on Babel for now
        //const keys = Reflect.ownKeys(arg);
        const keys = Object.getOwnPropertyNames(arg).concat(Object.getOwnPropertySymbols(arg))

        for (let i = 0, l = keys.length; i < l; i++) {
            const key = keys[i];
            
            //if (!Reflect.has(dst, key)) {
            if (!(key in dst)) {
                //Reflect.defineProperty(dst, key, Reflect.getOwnPropertyDescriptor(arg, key))
                Object.defineProperty(dst, key, Object.getOwnPropertyDescriptor(arg, key))
            }
        }
}

    return dst;
}

/**
 * Encodes two 0-255 numbers into one.
 *
 * @param {number} x The first number.
 * @param {number} y The second number.
 * @returns {number} The encoded number.
 */
function encodeFloat2(x, y) {
    return x + y * 256;
}

/**
 * Decodes a previously encoded number into the two original numbers.
 *
 * @param {number} f The input.
 * @returns {array} The two decoded numbers.
 */
function decodeFloat2(f) {
    var v = new Float32Array(2);

    v[1] = Math.floor(f / 256);
    v[0] = Math.floor(f - v[1] * 256);

    return v;
}

/**
 * Encodes three 0-255 numbers into one.
 *
 * @param {number} x The first number.
 * @param {number} y The second number.
 * @param {number} z The third number.
 * @returns {number} The encoded number.
 */
function encodeFloat3(x, y, z) {
    return x + y * 256 + z * 65536;
}

/**
 * Decodes a previously encoded number into the three original numbers.
 *
 * @param {number} f The input.
 * @returns {array} The three decoded numbers.
 */
function decodeFloat3(f) {
    var v = new Float32Array(3);

    v[2] = Math.floor(f / 65536);
    v[1] = Math.floor((f - v[2] * 65536) / 256);
    v[0] = Math.floor(f - v[2] * 65536 - v[1] * 256);

    return v;
}

if (!window.requestAnimationFrame ) {
    window.requestAnimationFrame = (function() {
        return window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) { window.setTimeout(callback, 1000 / 60); };
    }());
}

function get(path, binary, onprogress) {
    let xhr = new XMLHttpRequest();

    return new Promise(function (resolve, reject) {
        xhr.addEventListener("load", function () {
            if (xhr.status >= 200 && xhr.status < 300) {
                resolve(xhr);
            } else {
                reject(xhr);
            }
        });

        xhr.addEventListener("error", function () {
            reject(xhr);
        });

        if (onprogress) {
            xhr.addEventListener("progress", onprogress);
        }

        xhr.open("GET", path, true);

        if (binary) {
            xhr.responseType = "arraybuffer";
        }

        xhr.send();
    });;
}

/**
 * A very simple string hashing algorithm.
 *
 * @param {string} s A string to hash.
 * @returns {number} The hash.
 */
function hashFromString(s) {
    var hash = 0;

    for (var i = 0, l = s.length; i < l; i++) {
        hash = hash * 31 + s.charCodeAt(i);
        hash = hash & hash;
    }

    return hash;
}

/**
 * A very simple array-of-numbers hashing algorithm.
 *
 * @param {number[]} a An array fo numbers to hash.
 * @returns {number} The hash.
 */
function hashFromArray(a) {
    var hash = 0;

    for (var i = 0, l = a.length; i < l; i++) {
        var n = a[i];

        if (n === 0) {
            n = 1;
        }

        hash = hash * 31 + n;
        hash = hash & hash;
    }

    return hash;
}

/**
 * A deep Object copy.
 *
 * @param {object} object The object to copy.
 * @returns {object} The copied object.
 */
Object.copy = function (object) {
    var keys = Object.keys(object),
        newObj = (object instanceof Array) ? [] : {};

    for (var i = 0, l = keys.length; i < l; i++) {
        var key = keys[i];

        if (typeof key === "object") {
            newObj[key] = Object.copy(object[key]);
        } else {
            newObj[key] = object[key];
        }
    }

    return newObj;
};

/**
 * A shallow Array copy.
 *
 * @param {array} a The array to copy.
 * @returns {array} The copied array.
 */
Array.copy = function (array) {
    var newArray = [];

    for (var i = 0, l = array.length; i < l; i++) {
        newArray[i] = array[i];
    }

    return newArray;
};

/**
 * Clear an array.
 *
 * @param {array} a The array to clear.
 * @returns {array}.
 */
Array.clear = function (a) {
    while (a.length) {
        a.pop();
    }
    
    return a;
};

/**
 * Shallow array equality test.
 *
 * @param {array} a The first array.
 * @param {array} b The second array.
 * @returns {boolean}.
 */
Array.areEqual = function (a, b) {
    if (a === b) {
        return true;
    }

    if (a.length !== b.length) {
        return false;
    }

    for (var i = 0, l = a.length; i < l; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }

    return true;
};

/**
 * Returns an array that only contains unique values found in the source array.
 * In other words, all duplicated values are deleted.
 *
 * @returns {array}.
 */
Array.prototype.unique = function () {
    return this.reverse().filter(function (e, i, arr) {
        return arr.indexOf(e, i + 1) === -1;
    }).reverse();
};

/**
 * Returns a reversed copy of the source array.
 *
 * @returns {array}.
 */
String.prototype.reverse = function () {
    return [...this].reverse().join("");
};

Map.prototype.findKey = function (value) {
    for (let entry of this.entries()) {
        if (value === entry[1]) {
            return entry[0];
        }
    }
};
function BinaryReader(buffer, byteOffset, byteLength) {
    if (!(buffer instanceof ArrayBuffer)) {
        throw new TypeError("BinaryReader: expected ArrayBuffer, got " + buffer);
    }

    // Note: These four lines exist just for Firefox, since, at the time of writing, its implementation fails ECMAScript 2015 section 22.2.1.5 step 13.
    //       In other words, if you create a typed array with byteLength of undefined, the typed array will have zero length, instead of buffer.byteLength - byteOffset.
    //       See bug report at https://bugzilla.mozilla.org/show_bug.cgi?id=1040402
    byteOffset = byteOffset || 0;
    if (byteLength === undefined) {
        byteLength = buffer.byteLength - byteOffset;
    }

    this.buffer = buffer;
    this.dataview = new DataView(buffer, byteOffset, byteLength);
    this.uint8array = new Uint8Array(buffer, byteOffset, byteLength);
    this.index = 0;
    this.byteLength = buffer.byteLength;
}

function subreader(reader, byteLength) {
    return new BinaryReader(reader.buffer, reader.index, byteLength);
}

function remaining(reader) {
    return reader.byteLength - reader.index;
}

function skip(reader, bytes) {
    reader.index += bytes;
}

function seek(reader, index) {
    reader.index = index;
}

function tell(reader) {
    return reader.index;
}

function peek(reader, size) {
    let uint8array = reader.uint8array,
        index = reader.index,
        data = "";

    for (let i = 0; i < size; i++) {
        const b = uint8array[index + i];

        // Avoid \0
        if (b > 0) {
            data += String.fromCharCode(b);
        }
    }

    return data;
}

function read(reader, size) {
    // If the size isn't specified, default to everything
    size = size || remaining(reader);

    const data = peek(reader, size);

    reader.index += size;

    return data;
}

function peekUntilNull(reader) {
    let uint8array = reader.uint8array,
        index = reader.index,
        data = "",
        b = uint8array[index],
        i = 0;

    while (b !== 0) {
        data += String.fromCharCode(b);

        b = uint8array[index + i]
        i += 1;
    }

    return data;
}

function readUntilNull(reader) {
    const data = peekUntilNull(reader);

    reader.index += data.length + 1; // +1 for the \0 itself

    return data;
}

function peekCharArray(reader, size) {
    let uint8array = reader.uint8array,
        index = reader.index,
        data = [];

    for (let i = 0; i < size; i++) {
        data[i] = String.fromCharCode(uint8array[index + i]);
    }

    return data;
}

function readCharArray(reader, size) {
    // If the size isn't specified, default to everything
    size = size || (reader.byteLength - reader.index);

    const data = peekCharArray(reader, size);

    reader.index += size;

    return data;
}

function readInt8(reader) {
    const data = reader.dataview.getInt8(reader.index, true);

    reader.index += 1;

    return data;
}

function readInt16(reader) {
    const data = reader.dataview.getInt16(reader.index, true);

    reader.index += 2;

    return data;
}

function readInt32(reader) {
    const data = reader.dataview.getInt32(reader.index, true);

    reader.index += 4;

    return data;
}

function readUint8(reader) {
    const data = reader.dataview.getUint8(reader.index, true);

    reader.index += 1;

    return data;
}

function readUint16(reader) {
    const data = reader.dataview.getUint16(reader.index, true);

    reader.index += 2;

    return data;
}

function readUint32(reader) {
    const data = reader.dataview.getUint32(reader.index, true);

    reader.index += 4;

    return data;
}

function readFloat32(reader) {
    const data = reader.dataview.getFloat32(reader.index, true);

    reader.index += 4;

    return data;
}

function readFloat64(reader) {
    const data = reader.dataview.getFloat64(reader.index, true);

    reader.index += 8;

    return data;
}

function readInt8Array(reader, count) {
    const data = new Int8Array(count);

    for (let i = 0; i < count; i++) {
        data[i] = reader.dataview.getInt8(reader.index + i, true);
    }

    reader.index += data.byteLength;

    return data;
}

function readInt16Array(reader, count) {
    const data = new Int16Array(count);

    for (let i = 0; i < count; i++) {
        data[i] = reader.dataview.getInt16(reader.index + 2 * i, true);
    }

    reader.index += data.byteLength;

    return data;
}

function readInt32Array(reader, count) {
    const data = new Int32Array(count);

    for (let i = 0; i < count; i++) {
        data[i] = reader.dataview.getInt32(reader.index + 4 * i, true);
    }

    reader.index += data.byteLength;

    return data;
}

function readUint8Array(reader, count) {
    const data = new Uint8Array(count);

    for (let i = 0; i < count; i++) {
        data[i] = reader.dataview.getUint8(reader.index + i, true);
    }

    reader.index += data.byteLength;

    return data;
}

function readUint16Array(reader, count) {
    const data = new Uint16Array(count);

    for (let i = 0; i < count; i++) {
        data[i] = reader.dataview.getUint16(reader.index + 2 * i, true);
    }

    reader.index += data.byteLength;

    return data;
}

function readUint32Array(reader, count) {
    const data = new Uint32Array(count);

    for (let i = 0; i < count; i++) {
        data[i] = reader.dataview.getUint32(reader.index + 4 * i, true);
    }

    reader.index += data.byteLength;

    return data;
}

function readFloat32Array(reader, count) {
    const data = new Float32Array(count);

    for (let i = 0; i < count; i++) {
        data[i] = reader.dataview.getFloat32(reader.index + 4 * i, true);
    }

    reader.index += data.byteLength;

    return data;
}

function readFloat64Array(reader, count) {
    const data = new Float64Array(count);

    for (let i = 0; i < count; i++) {
        data[i] = reader.dataview.getFloat64(reader.index + 8 * i, true);
    }

    reader.index += data.byteLength;

    return data;
}

function readInt8Matrix(reader, rows, columns) {
    const data = [];

    for (let i = 0; i < rows; i++) {
        data[i] = readInt8Array(reader, columns);
    }

    return data;
}

function readInt16Matrix(reader, rows, columns) {
    const data = [];

    for (let i = 0; i < rows; i++) {
        data[i] = readInt16Array(reader, columns);
    }

    return data;
}

function readInt32Matrix(reader, rows, columns) {
    const data = [];

    for (let i = 0; i < rows; i++) {
        data[i] = readInt32Array(reader, columns);
    }

    return data;
}

function readUint8Matrix(reader, rows, columns) {
    const data = [];

    for (let i = 0; i < rows; i++) {
        data[i] = readUint8Array(reader, columns);
    }

    return data;
}

function readUint16Matrix(reader, rows, columns) {
    const data = [];

    for (let i = 0; i < rows; i++) {
        data[i] = readUint16Array(reader, columns);
    }

    return data;
}

function readUint32Matrix(reader, rows, columns) {
    const data = [];

    for (let i = 0; i < rows; i++) {
        data[i] = readUint32Array(reader, columns);
    }

    return data;
}

function readFloat32Matrix(reader, rows, columns) {
    const data = [];

    for (let i = 0; i < rows; i++) {
        data[i] = readFloat32Array(reader, columns);
    }

    return data;
}

function readFloat64Matrix(reader, rows, columns) {
    const data = [];

    for (let i = 0; i < rows; i++) {
        data[i] = readFloat64Array(reader, columns);
    }

    return data;
}

// Useful shortcuts?

function readVector2(reader) {
    return readFloat32Array(reader, 2);
}

function readVector3(reader) {
    return readFloat32Array(reader, 3);
}

function readVector4(reader) {
    return readFloat32Array(reader, 4);
}

function readMatrix(reader) {
    return readFloat32Array(reader, 16);
}

function readVector2Array(reader, size) {
    return readFloat32Matrix(reader, size, 2);
}

function readVector3Array(reader, size) {
    return readFloat32Matrix(reader, size, 3);
}

function readVector4Array(reader, size) {
    return readFloat32Matrix(reader, size, 4);
}

function readMatrixArray(reader, size) {
    return readFloat32Matrix(reader, size, 16);
}

function readPixel(reader) {
    return readUint8Array(reader, 4);
}

function readPixelArray(reader, size) {
    return readUint8Matrix(reader, size, 4);
}
function BitBuffer(buffer, byteOffset, byteLength) {
    if (!(buffer instanceof ArrayBuffer)) {
        throw new TypeError("BitBuffer: expected ArrayBuffer, got " + buffer);
    }

    // Note: These four lines exist just for Firefox, since, at the time of writing, its implementation fails ECMAScript 2015 section 22.2.1.5 step 13.
    //       In other words, if you create a typed array with byteLength of undefined, the typed array will have zero length, instead of buffer.byteLength - byteOffset.
    //       See bug report at https://bugzilla.mozilla.org/show_bug.cgi?id=1040402
    byteOffset = byteOffset || 0;
    if (byteLength === undefined) {
        byteLength = buffer.byteLength - byteOffset;
    }

    this.buffer = buffer;
    this.uint8array = new Uint8Array(buffer, byteOffset, byteLength);
    this.index = 0;
    this.byteLength = buffer.byteLength;
    this.bitBuffer = 0;
    this.bits = 0;
}

function loadBits(buffer, bits) {
    while (buffer.bits < bits) {
        buffer.bitBuffer += buffer.uint8array[buffer.index] << buffer.bits;
        buffer.bits += 8;
        buffer.index += 1;
    }
}

function peekBits(buffer, bits) {
    loadBits(buffer, bits);

    return (buffer.bitBuffer & (1 << bits));
}

function readBits(buffer, bits) {
    const data = peekBits(buffer, bits);

    buffer.bitBuffer >>>= bits;
    buffer.bits -= bits;

    return data;
}

function skipBits(buffer, bits) {
    loadBits(buffer, bits);

    buffer.bitBuffer >>>= bits;
    buffer.bits -= bits;
}
vec2.heap = vec2.create();

vec3.UNIT_X = vec3.fromValues(1, 0, 0);
vec3.UNIT_Y = vec3.fromValues(0, 1, 0);
vec3.UNIT_Z = vec3.fromValues(0, 0, 1);

vec3.heap = vec3.create();
vec3.heap2 = vec3.create();
vec3.heap3 = vec3.create();

vec3.ZERO = vec3.create();
vec3.ONE = vec3.fromValues(1, 1, 1);

quat.ZERO = quat.fromValues(0, 0, 0, 0);
quat.DEFAULT = quat.create();

mat4.heap = mat4.create();

mat4.toRotationMat4 = (function () {
    const quadrent = mat3.create();
    
    return function (out, m) {
        mat3.fromMat4(quadrent, m);
        mat3.invert(quadrent, quadrent);
        
        out[0] = quadrent[0];
        out[1] = quadrent[1];
        out[2] = quadrent[2];
        out[3] = 0;
        out[4] = quadrent[3];
        out[5] = quadrent[4];
        out[6] = quadrent[5];
        out[7] = 0;
        out[8] = quadrent[6];
        out[9] = quadrent[7];
        out[10] = quadrent[8];
        out[11] = 0;
        out[12] = 0;
        out[13] = 0;
        out[14] = 0;
        out[15] = 1;
        
        return out;
    };
}());

vec3.unproject = (function () {
    const heap = vec4.create();
    
    return function (out, v, inverseMatrix, viewport) {
        const x = 2 * (v[0] - viewport[0]) / viewport[2] - 1,
            y = 1 - 2 * (v[1] - viewport[1]) / viewport[3],
            z = 2 * v[2] - 1;
        
        vec4.set(heap, x, y, z, 1);
        vec4.transformMat4(heap, heap, inverseMatrix);
        vec3.set(out, heap[0] / heap[3], heap[1] / heap[3], heap[2] / heap[3]);
        
        return out;
    };
}());

quat.nlerp = function (out, a, b, t) {
    const dot = quat.dot(a, b),
        inverseFactor = 1 - t;

    if (dot < 0) {
        out[0] = inverseFactor * a[0] - t * b[0];
        out[1] = inverseFactor * a[1] - t * b[1];
        out[2] = inverseFactor * a[2] - t * b[2];
        out[3] = inverseFactor * a[3] - t * b[3];
    } else {
        out[0] = inverseFactor * a[0] + t * b[0];
        out[1] = inverseFactor * a[1] + t * b[1];
        out[2] = inverseFactor * a[2] + t * b[2];
        out[3] = inverseFactor * a[3] + t * b[3];
    }

    quat.normalize(out, out);

    return out;
};

quat.nquad = (function () {
    const temp1 = quat.create(),
        temp2 = quat.create();
  
    return function (out, a, b, c, d, t) {
        quat.nlerp(temp1, a, d, t);
        quat.nlerp(temp2, b, c, t);
        quat.nlerp(out, temp1, temp2, 2 * t * (1 - t));

        return out;
    };
}());

vec3.mulAndAdd = function (out, v, scale, add) {
    out[0] = v[0] * scale[0] + add[0];
    out[1] = v[1] * scale[1] + add[1];
    out[2] = v[2] * scale[2] + add[2];

    return out;
};const Interpolator = {
    heap3: vec3.create(),
    heap4: quat.create(),

    scalar(a, b, c, d, t, type) {
        if (type === 0) {
            return a;
        } else if (type === 1) {
            return Math.lerp(a, d, t);
        } else if (type === 2) {
            return Math.hermite(a, b, c, d, t);
        } else if (type === 3) {
            return Math.bezier(a, b, c, d, t);
        }

        return 0;
    },

    vector(out, a, b, c, d, t, type) {
        if (type === 0) {
            return a;
        } else if (type === 1) {
            return vec3.lerp(out, a, d, t);
        } else if (type === 2) {
            return vec3.hermite(out, a, b, c, d, t);
        } else if (type === 3) {
            return vec3.bezier(out, a, b, c, d, t);
        }

        return vec3.copy(out, vec3.ZERO);
    },

    quaternion(out, a, b, c, d, t, type) {
        if (type === 0) {
            return a;
        } else if (type === 1) {
            return quat.nlerp(out, a, d, t);
        } else if (type === 2 || type === 3) {
            return quat.nquad(out, a, b, c, d, t);
        }

        return quat.copy(out, quat.ZERO);
    },

    interpolate(a, b, c, d, t, type) {
        const length = a.length;

        if (length === 3) {
            return this.vector(this.heap3, a, b, c, d, t, type);
        } else if (length === 4) {
            return this.quaternion(this.heap4, a, b, c, d, t, type);
        } else {
            return this.scalar(a, b, c, d, t, type);
        }
    }
};
Math.TO_RAD = Math.PI / 180;
Math.TO_DEG = 180 / Math.PI;

/**
 * Convert from degrees to radians.
 *
 * @param {number} degrees
 * @returns {number} Radians.
 */
Math.toRad = function (degrees) {
    return degrees * Math.TO_RAD;
};

/**
 * Convert from radians to degrees.
 *
 * @param {number} radians
 * @returns {number} Degrees.
 */
Math.toDeg = function (radians) {
    return radians * Math.TO_DEG;
};

/**
 * Gets a random number in the given range.
 *
 * @param {number} a
 * @param {number} b
 * @returns {number} A random number in [a, b].
 */
Math.randomRange = function (a, b) {
    return a + Math.random() * (b - a);
};

/**
 * Clamp a number in a range.
 *
 * @param {number} x
 * @param {number} minVal
 * @param {number} maxVal
 * @returns {number} Clamped number.
 */
Math.clamp = function (x, minVal, maxVal) {
    return Math.min(Math.max(x, minVal), maxVal);
};

/**
 * Linear interpolation between to numbers.
 *
 * @param {number} a First number.
 * @param {number} b Second number.
 * @param {number} t Factor.
 * @returns {number} Interpolated value.
 */
Math.lerp = function (a, b, t) {
    return a + t * (b - a);
};

/**
 * Hermite interpolation between to numbers.
 *
 * @param {number} a First number.
 * @param {number} b First control point.
 * @param {number} c Second control point.
 * @param {number} d Second number.
 * @param {number} t Factor.
 * @returns {number} Interpolated value.
 */
Math.hermite = function (a, b, c, d, t) {
    var factorTimes2 = t * t,
        factor1 = factorTimes2 * (2 * t - 3) + 1,
        factor2 = factorTimes2 * (t - 2) + t,
        factor3 = factorTimes2 * (t - 1),
        factor4 = factorTimes2 * (3 - 2 * t);

    return (a * factor1) + (b * factor2) + (c * factor3) + (d * factor4);
};

/**
 * Bezier interpolation between to numbers.
 *
 * @param {number} a First number.
 * @param {number} b First control point.
 * @param {number} c Second control point.
 * @param {number} d Second number.
 * @param {number} t Factor.
 * @returns {number} Interpolated value.
 */
Math.bezier = function (a, b, c, d, t) {
    var invt = 1 - t,
        factorTimes2 = t * t,
        inverseFactorTimesTwo = invt * invt,
        factor1 = inverseFactorTimesTwo * invt,
        factor2 = 3 * t * inverseFactorTimesTwo,
        factor3 = 3 * factorTimes2 * invt,
        factor4 = factorTimes2 * t;

    return (a * factor1) + (b * factor2) + (c * factor3) + (d * factor4);
};

/**
 * Gets the sign of a number.
 *
 * @param {number} x
 * @returns {number} The sign.
 */
Math.sign = function (x) {
    return x === 0 ? 0 : (x < 0 ? -1 : 1);
};

/**
 * Copies the sign of one number onto another.
 *
 * @param {number} x Destination.
 * @param {number} y Source.
 * @returns {number} Returns the destination with the source's sign.
 */
Math.copysign = function (x, y) {
    var signy = Math.sign(y),
        signx;

    if (signy === 0) {
        return 0;
    }

    signx = Math.sign(x);

    if (signx !== signy) {
        return -x;
    }

    return x;
};

/**
 * Gets the closest power of two bigger than the given number.
 *
 * @param {number} x
 * @returns {number} A power of two number.
 */
Math.powerOfTwo = function (x) {
    x--;
    x |= x >> 1; 
    x |= x >> 2; 
    x |= x >> 4; 
    x |= x >> 8; 
    x |= x >> 16; 
    x++;

    return x;
};

// Given a list of items and a list of weights per item, get a random item
function getRandomItem(list, weight) {
    const totalWeight = weight.reduce(function (prev, cur, i, arr) { return prev + cur; }),
        n = Math.random() * totalWeight;

    let weightSum = 0;

    for (let i = 0; i < list.length; i++) {
        weightSum += weight[i];

        if (n <= weightSum) {
            return list[i];
        }
    }
}
/**
 * @class
 * @classdesc A simple queue of actions. An action is composed of a function, and the arguments to be used.
 *            This class is used wherever asyncronyous code needs to happen.
 */
function ActionQueue() {
    /** @member {array} */
    this.actions = [];
}
 
ActionQueue.prototype = {
    /**
     * @method
     * @desc Add an action to the queue.
     * @param {function} action The action.
     * @param {array} args The action arguments.
     */
    addAction(action, args) {
        this.actions.push([action, args]);
    },

    /**
     * @method
     * @desc Runs all of the actions in the queue, emptying it.
     */
    applyActions() {
        for (let action of this.actions) {
            action[0].apply(this, action[1]);
        }

        this.actions = [];
    }
};
/**
 * @class
 * @classdesc An event dispatcher. Not much else to say.
 */
function EventDispatcher() {
    /** @member {Map.<string, function>} */
    this.listeners = new Map();
}
 
EventDispatcher.prototype = {
    /**
     * @method
     * @desc Add a new event listener.
     * @param {string} type The event type.
     * @param {function} listener The event listener.
     * @returns this
     */
    addEventListener(type, listener) {
        let listeners = this.listeners;

        if (!listeners.has(type)) {
            listeners.set(type, []);
        }

        listeners.get(type).push(listener);

        return this;
    },
    
    /**
     * @method
     * @desc Remove an existing event listener.
     * @param {string} type The event type.
     * @param {function} listener The event listener.
     * @returns this
     */
    removeEventListener(type, listener) {
        let listeners = this.listeners.get(type);

        if (listeners) {
            let index = listeners.indexOf(listener);

            if (index !== -1) {
                listeners.splice(index, 1);
            }
        }

        return this;
    },
    
    /**
     * @method
     * @desc Dispatch an event.
     * @param {object} event The event object.
     */
    dispatchEvent(event) {
        if (!event.target) {
            event.target = this;
        }

        let listeners = this.listeners.get(event.type);

        if (listeners) {
            for (let i = 0, l = listeners.length; i < l; i++) {
                listeners[i].call(this, event);
            }
        }

        return this;
    }
};
/**
 * @class
 * @classdesc A scene node, that can be moved around and parented to other nodes.
 * @param {boolean} dontInheritScale True if this node should not inherit the parent's scale if this node is parented.
 * @param {?ArrayBuffer} buffer An ArrayBuffer object to add this node to. A new buffer will be created if one isn't given.
 * @param {?number} offset An offset into the buffer, if one was given.
 */
function Node(dontInheritScale, buffer, offset) {
    if (!buffer) {
        buffer = new ArrayBuffer(58 * 4);
        offset = 0;
    }

    if (!(buffer instanceof ArrayBuffer)) {
        throw new TypeError("Node: expected ArrayBuffer, got " + buffer);
    }

    /** @member {vec3} */
    this.pivot = new Float32Array(buffer, offset + 0, 3);
    /** @member {vec3} */
    this.localLocation = new Float32Array(buffer, offset + 12, 3);
    /** @member {quat} */
    this.localRotation = new Float32Array(buffer, offset + 24, 4);
    /** @member {vec3} */
    this.localScale = new Float32Array(buffer, offset + 40, 3);
    /** @member {vec3} */
    this.worldLocation = new Float32Array(buffer, offset + 52, 3);
    /** @member {quat} */
    this.worldRotation = new Float32Array(buffer, offset + 64, 4);
    /** @member {vec3} */
    this.worldScale = new Float32Array(buffer, offset + 80, 3);
    /** @member {vec3} */
    this.inverseWorldScale = new Float32Array(buffer, offset + 92, 3);
    /** @member {mat4} */
    this.localMatrix = new Float32Array(buffer, offset + 104, 16);
    /** @member {mat4} */
    this.worldMatrix = new Float32Array(buffer, offset + 168, 16);
    /** @member {?Node} */
    this.parent = null;
    /** @member {Node[]} */
    this.children = [];
    /** @member {boolean} */
    this.dontInheritScale = dontInheritScale || false;

    this.localRotation[3] = 1;
    this.localScale.fill(1);
    mat4.identity(this.worldMatrix);
}

Node.prototype = {
    /**
     * @method
     * @desc Sets the node's pivot.
     * @param {vec3} pivot The new pivot.
     * @returns this
     */
    setPivot(pivot) {
        vec3.copy(this.pivot, pivot);

        this.recalculateTransformation();

        return this;
    },

    /**
     * @method
     * @desc Sets the node's local location.
     * @param {vec3} location The new location.
     * @returns this
     */
    setLocation(location) {
        vec3.copy(this.localLocation, location);

        this.recalculateTransformation();

        return this;
    },

    /**
     * @method
     * @desc Sets the node's local rotation.
     * @param {quat} rotation The new rotation.
     * @returns this
     */
    setRotation(rotation) {
        quat.copy(this.localRotation, rotation);

        this.recalculateTransformation();

        return this;
    },

    /**
     * @method
     * @desc Sets the node's local scale.
     * @param {vec3} varying The new scale.
     * @returns this
     */
    setScale(varying) {
        vec3.copy(this.localScale, varying);

        this.recalculateTransformation();

        return this;
    },

    /**
     * @method
     * @desc Sets the node's local scale uniformly.
     * @param {number} uniform The new scale.
     * @returns this
     */
    setUniformScale(uniform) {
        vec3.set(this.localScale, uniform, uniform, uniform);

        this.recalculateTransformation();

        return this;
    },

    /**
     * @method
     * @desc Sets the node's local location, rotation, and scale.
     * @param {vec3} location The new location.
     * @param {quat} rotation The new rotation.
     * @param {vec3} scale The new scale.
     * @returns this
     */
    setTransformation(location, rotation, scale) {
        vec3.copy(this.localLocation, location);
        quat.copy(this.localRotation, rotation);
        vec3.copy(this.localScale, scale);

        this.recalculateTransformation();

        return this;
    },

    /**
     * @method
     * @desc Resets the node's local location, pivot, rotation, and scale, to the default values.
     * @returns this
     */
    resetTransformation() {
        vec3.copy(this.localLocation, vec3.ZERO);
        vec3.copy(this.pivot, vec3.ZERO);
        quat.copy(this.localRotation, quat.DEFAULT);
        vec3.copy(this.localScale, vec3.ONE);

        this.recalculateTransformation();

        return this;
    },

    /**
     * @method
     * @desc Moves the node's pivot.
     * @param {vec3} offset The offset.
     * @returns this
     */
    movePivot(offset) {
        vec3.add(this.pivot, this.pivot, offset);

        this.recalculateTransformation();

        return this;
    },

    /**
     * @method
     * @desc Moves the node's local location.
     * @param {vec3} offset The offset.
     * @returns this
     */
    move(offset) {
        vec3.add(this.localLocation, this.localLocation, offset);

        this.recalculateTransformation();

        return this;
    },

    /**
     * @method
     * @desc Rotates the node's local rotation in world space.
     * @param {vec3} rotation The rotation.
     * @returns this
     */
    rotate(rotation) {
        quat.mul(this.localRotation, this.localRotation, rotation);

        this.recalculateTransformation();

        return this;
    },

    /**
     * @method
     * @desc Rotates the node's local rotation in local space.
     * @param {vec3} rotation The rotation.
     * @returns this
     */
    rotateLocal(rotation) {
        quat.mul(this.localRotation, rotation, this.localRotation);

        this.recalculateTransformation();

        return this;
    },

    /**
     * @method
     * @desc Scales the node.
     * @param {vec3} scale The scale.
     * @returns this
     */
    scale(scale) {
        vec3.mul(this.localScale, this.localScale, scale);

        this.recalculateTransformation();

        return this;
    },

    /**
     * @method
     * @desc Scales the node uniformly.
     * @param {number} scale The scale.
     * @returns this
     */
    uniformScale(scale) {
        vec3.scale(this.localScale, this.localScale, scale);

        this.recalculateTransformation();

        return this;
    },

    /**
     * @method
     * @desc Sets the node's parent.
     * @param {?Node} parent The parent. NOTE: don't set parent to null manually, instead use setParent(null).
     * @returns this
     */
    setParent(parent) {
        if (this.parent) {
            this.parent.removeChild(this);
        }

        this.parent = parent;

        parent.addChild(this);

        this.recalculateTransformation();

        return this;
    },

    addChild(child) {
        this.children.push(child);
    },

    removeChild(child) {
        let children = this.children;

        children.splice(children.indexOf(child), 1);
    },

    // This will be called by a parent when it is recalculated.
    // Override at will if you want special functionality.
    // Note that ModelInstance overrides this.
    notify() {

    },

    /**
     * @method
     * @desc Get the node's world location.
     * @returns {vec3}
     */
    getLocation() {
        return this.worldLocation;
    },

    /**
     * @method
     * @desc Get the node's world rotation.
     * @returns {quat}
     */
    getRotation() {
        return this.worldRotation;
    },

    /**
     * @method
     * @desc Get the node's world scale.
     * @returns {vec3}
     */
    getScaling() {
        return this.worldScale;
    },

    recalculateTransformation() {
        let localMatrix = this.localMatrix,
            localRotation = this.localRotation,
            worldMatrix = this.worldMatrix,
            worldLocation = this.worldLocation,
            worldRotation = this.worldRotation,
            worldScale = this.worldScale,
            pivot = this.pivot,
            parent = this.parent,
            children = this.children;

        // Local matrix
        // Model space
        mat4.fromRotationTranslationScaleOrigin(localMatrix, localRotation, this.localLocation, this.localScale, pivot);

        // World matrix
        // Model space -> World space
        if (parent) {
            mat4.mul(worldMatrix, parent.worldMatrix, localMatrix);

            // If this node shouldn't inherit the parent's scale, scale it by the inverse
            if (this.dontInheritScale) {
                mat4.scale(worldMatrix, worldMatrix, parent.inverseWorldScale);
            }

            // World rotation
            quat.mul(worldRotation, parent.worldRotation, localRotation);
        } else {
            mat4.copy(worldMatrix, localMatrix);
            quat.copy(worldRotation, localRotation);
        }

        // Scale and inverse scale
        mat4.getScaling(worldScale, worldMatrix);
        vec3.inverse(this.inverseWorldScale, worldScale);

        // World location
        vec3.copy(worldLocation, pivot);
        vec3.transformMat4(worldLocation, worldLocation, worldMatrix);

        // Notify the children
        for (let i = 0, l = children.length; i < l; i++) {
            children[i].notify();
        }
    }
};
function BoundingShape() {
    Node.call(this, false);

    this.min = new Float32Array([-1, -1, -1]);
    this.max = new Float32Array([1, 1, 1]);
    this.radius = Math.sqrt(2);
}

BoundingShape.prototype = {
    /// TODO: duplicated with Mdx.ModelInstance and M3.ModelInstance, can I do something nice about this? (e.g. parent class)
    // This will be called if this instance is parented to some node, and the node changed
    notify() {
        this.recalculateTransformation();
    },

    fromBounds(min, max) {
        this.min.set(min);
        this.max.set(max);

        let dX = max[0] - min[0],
            dY = max[1] - min[1],
            dZ = max[2] - min[2];

        this.radius = Math.sqrt(dX * dX + dY * dY + dZ * dZ) / 2
    },

    fromRadius(r) {
        let s = r * Math.cos(r),
            min = this.min,
            max = this.max;

        min[0] = min[1] = min[2] = s;
        max[0] = max[1] = max[2] = -s;

        this.radius = r;
    },

    fromVertices(vertices) {
        let min = [1E9, 1E9, 1E9],
            max = [-1E9, -1E9, -1E9];

        for (let i = 0, l = vertices.length; i < l; i += 3) {
            let x = vertices[i],
                y = vertices[i + 1],
                z = vertices[i + 2];

            if (x > max[0]) {
                max[0] = x;
            }

            if (x < min[0]) {
                min[0] = x;
            }

            if (y > max[1]) {
                max[1] = y;
            }

            if (y < min[1]) {
                min[1] = y;
            }

            if (z > max[2]) {
                max[2] = z;
            }

            if (z < min[2]) {
                min[2] = z;
            }
        }

        //this.fromRadius();

        this.fromBounds(min, max);
    },

    getPositiveVertex(out, normal) {
        let min = this.min,
            max = this.max;

        if (normal[0] >= 0) {
            out[0] = max[0];
        } else {
            out[0] = min[0];
        }

        if (normal[1] >= 0) {
            out[1] = max[1];
        } else {
            out[1] = min[1];
        }

        if (normal[2] >= 0) {
            out[2] = max[2];
        } else {
            out[2] = min[2];
        }

        return out;
        //return vec3.mulAndAdd(out, out, this.worldScale, this.worldLocation);
    },

    getNegativeVertex(out, normal) {
        let min = this.min,
            max = this.max;

        if (normal[0] >= 0) {
            out[0] = min[0];
        } else {
            out[0] = max[0];
        }

        if (normal[1] >= 0) {
            out[1] = min[1];
        } else {
            out[1] = max[1];
        }

        if (normal[2] >= 0) {
            out[2] = min[2];
        } else {
            out[2] = max[2];
        }

        return out;
        //return vec3.mulAndAdd(out, out, this.worldScale, this.worldLocation);
    }
};

mix(BoundingShape.prototype, Node.prototype);
/**
 * @class
 * @classdesc A common base class for almost all of the objects used by the viewer.
 *            This class handles the different states of loading, and the events sent as a result.
 *            It also extends action queue, which is the class that gives every object the ability to support asyncronous actions.
 * @extends EventDispatcher
 * @extends ActionQueue
 * @param {ModelViewer} env The model viewer object this resource belongs to.
 */
function AsyncResource(env) {
    /** @member {ModelViewer} */
    this.env = env;
    /** @member {WebGLRenderingContext} */
    this.gl = env.gl;
    /** @member {boolean} */
    this.loaded = false;
    /** @member {boolean} */
    this.error = false;

    EventDispatcher.call(this);
    ActionQueue.call(this);
}

AsyncResource.prototype = {
    update() {

    },

    load() {
        throw new Error("AsyncResource.load must be overriden!");
    },

    onprogress(e) {
        if (e.target.status === 200) {
            this.dispatchEvent({ type: "progress", loaded: e.loaded, total: e.total, lengthComputable: e.lengthComputable });
        }
    },

    onload(src) {
        // This check allows an handler to postpone load finalization, either for asynchronious reasons (e.g. PngTexture), or because an internal error occured
        if (this.initialize(src)) {
            this.finalizeLoad();
        }
    },

    finalizeLoad() {
        this.loaded = true;

        this.dispatchEvent({ type: "load" });
        this.onloadend();
    },

    onerror(error, extra) {
        this.error = true;

        let e = { type: "error", error: error };

        if (extra) {
            e.extra = extra;
        }

        this.dispatchEvent(e);
        this.onloadend();
    },

    onloadend() {
        this.applyActions();
        this.dispatchEvent({ type: "loadend" });
    },

    /**
     * @method
     * @desc Similar to attaching an event listener to the "loadend" event, but handles the case where the resource already loaded, and the callback should still be called.
     * @param {function} callback The function to call.
     * @returns this
     */
    whenLoaded(callback) {
        if (this.loaded || this.error) {
            callback(this);
        } else {
            // Self removing listener
            let listener = () => { this.removeEventListener(listener); callback(this); };

            this.addEventListener("loadend", listener);
        }

        return this;
    }
};

mix(AsyncResource.prototype, EventDispatcher.prototype, ActionQueue.prototype);
/**
 * @class
 * @classdesc A base class for resources that are meant to be downloaded (models, textures, and generic files).
 * @extends AsyncResource
 * @param {ModelViewer} env The model viewer object that this model belongs to.
 * @param {function} pathSolver A function that solves paths. See more {@link PathSolver here}.
 */
function DownloadableResource(env, pathSolver) {
    /** @member {function} */
    this.pathSolver = pathSolver;

    AsyncResource.call(this, env);
}

DownloadableResource.prototype = {
    onerrorXHR(xhr) {
        this.onerror("HttpError", xhr);
    },

    load(src, isBinary, serverFetch) {
        this.originalSrc = src;

        if (serverFetch) {
            get(src, isBinary, xhr => this.onprogress(xhr)).then(xhr => this.onload(xhr.response), xhr => this.onerrorXHR(xhr));
        } else {
            this.onload(src);
        }
    }
};

mix(DownloadableResource.prototype, AsyncResource.prototype);
/**
 * @class
 * @classdesc A base class for skeletons.
 * @param {?Node} parentNode The parent of this skeleton.
 * @param {number} nodeCount The number of nodes in this skeleton.
 */
function Skeleton(parentNode, nodeCount) {
    const buffer = new ArrayBuffer(58 * 4 * nodeCount),
        nodes = [];

    for (let i = 0; i < nodeCount; i++) {
        nodes[i] = new Node(false, buffer, i * 58 * 4);
    }

    /** @member {Node} */
    this.parentNode = parentNode;
    /** @member {ArrayBuffer} */
    this.buffer = buffer;
    /** @member {Node[]} */
    this.nodes = nodes;

    //for (let i = 0; i < nodeCount; i++) {
    //    nodes[i].setParent(skeleton.getNode(hierarchy[i]));
    //}
}

Skeleton.prototype = {
    /**
     * @method
     * @desc Get the i'th node. If the given id is -1, return the parent instead.
     * @param {number} id The index of the node.
     * @returns {Node}
     */
    getNode(id) {
        if (id === -1) {
            return this.parentNode;
        }

        return this.nodes[id];
    }
};
/**
 * @class
 * @classdesc A class that emulates a resizeable WebGL buffer.
 * @param {WebGLRenderingContext} gl The WebGL context.
 * @param {?number} size The initial buffer size. Defaults to 32.
 */
function ResizeableBuffer(gl, size) {
    let buffer = new ArrayBuffer(size || 32); // Arbitrary default size

    /** @member {WebGLRenderingContext} */
    this.gl = gl;
    /** @member {Uint8Array} */
    this.uint8array = new Uint8Array(buffer);
    /** @member {Float32Array} */
    this.float32array = new Float32Array(buffer);
    /** @member {WebGLBuffer} */
    this.buffer = gl.createBuffer();
    
    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.uint8array, gl.DYNAMIC_DRAW);
}

ResizeableBuffer.prototype = {
    get byteLength() {
        return this.uint8array.length;
    },

    /**
     * @method
     * @desc Binds this buffer to the array buffer target.
     * @param {?number} target The WebGL buffer target enum. Defaults to GL_ARRAY_BUFFER.
     */
    bind(target) {
        let gl = this.gl;

        gl.bindBuffer(target || gl.ARRAY_BUFFER, this.buffer);
    },

    /**
     * @method
     * @desc Resizes the internal buffer.
     * @param {number} size The requested size. Actual size is the closest power of two number, that is equal or bigger than size.
     */
    resize(size) {
        size = Math.powerOfTwo(size);

        // Only bother resizing if the size isn't the same.
        if (size !== this.byteLength) {
            let gl = this.gl,
                array = new Uint8Array(size),
                oldArray = this.uint8array;

            if (oldArray.byteLength <= size) {
                array.set(oldArray);
            } else {
                array.set(oldArray.subarray(0, size - 1));
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
            gl.bufferData(gl.ARRAY_BUFFER, array, gl.DYNAMIC_DRAW);

            this.uint8array = array;
            this.float32array = new Float32Array(array.buffer);
        }
    },

    /**
     * @method
     * @desc Double the buffer size.
     */
    extend() {
        this.resize(this.uint8array.length << 1);
    },

    /**
     * @method
     * @desc Halve the buffer size.
     */
    reduce() {
        this.resize(this.uint8array.length >> 1);
    }
};
/**
 * @class
 * @classdesc A wrapper around WebGL shader units.
 * @param {WebGLRenderingContext} gl The WebGL context.
 * @param {string} src The shader source.
 * @param {number} type The shader type.
 */
function ShaderUnit(gl, src, type) {
    let id = gl.createShader(type);

    /** @member {boolean} */
    this.loaded = false;
    /** @member {WebGLShader} */
    this.webglResource = id;
    /** @member {string} */
    this.src = src;
    /** @member {number} */
    this.shaderType = type;

    gl.shaderSource(id, src);
    gl.compileShader(id);

    if (gl.getShaderParameter(id, gl.COMPILE_STATUS)) {
        this.loaded = true;
    } else {
        let error = gl.getShaderInfoLog(id),
            lines = src.split("\n");

        console.error("Shader unit failed to compile!");
        console.error(error);

        let regex = /:(\d+):/g,
            lineNumber = regex.exec(error);

        while (lineNumber) {
            let integer = parseInt(lineNumber[1]);

            console.error(integer + ": " + lines[integer - 1]);

            lineNumber = regex.exec(error);
        }
    }
}

/**
 * @class
 * @classdesc A wrapper around WebGL shader programs.
 * @param {WebGLRenderingContext} gl The WebGL context.
 * @param {ShaderUnit} vertexShader The vertex shader unit.
 * @param {ShaderUnit} fragmentShader The fragment shader unit.
 */
function ShaderProgram(gl, vertexShader, fragmentShader) {
    let id = gl.createProgram(),
        uniforms = new Map(),
        attribs = new Map();

    /** @member {boolean} */
    this.loaded = false;
    /** @member {WebGLProgram} */
    this.webglResource = id;
    /** @member {array} */
    this.shaders = [vertexShader, fragmentShader];
    /** @member {map.<string, WebGLUniformLocation>} */
    this.uniforms = uniforms;
    /** @member {map.<string, number>} */
    this.attribs = attribs;

    gl.attachShader(id, vertexShader.webglResource);
    gl.attachShader(id, fragmentShader.webglResource);
    gl.linkProgram(id);

    if (gl.getProgramParameter(id, gl.LINK_STATUS)) {
        for (let i = 0, l = gl.getProgramParameter(id, gl.ACTIVE_UNIFORMS) ; i < l; i++) {
            let object = gl.getActiveUniform(id, i),
                location = gl.getUniformLocation(id, object.name);

            uniforms.set(object.name, location);

            // Basic support for arrays
            if (object.name.endsWith("[0]")) {
                let base = object.name.substr(0, object.name.length - 3),
                    index = 1,
                    name = base + "[" + index + "]",
                    location = gl.getUniformLocation(id, name);

                while (location) {
                    uniforms.set(name, location);

                    index += 1;
                    name = base + "[" + index + "]",
                    location = gl.getUniformLocation(id, name);
                }
            }
        }

        for (let i = 0, l = gl.getProgramParameter(id, gl.ACTIVE_ATTRIBUTES) ; i < l; i++) {
            let object = gl.getActiveAttrib(id, i),
                location = gl.getAttribLocation(id, object.name);

            attribs.set(object.name, location);

            // Basic support for arrays
            if (object.name.endsWith("[0]")) {
                let base = object.name.substr(0, object.name.length - 3),
                    index = 1,
                    name = base + "[" + index + "]",
                    location = gl.getAttribLocation(id, name);

                while (location) {
                    attribs.set(name, location);

                    index += 1;
                    name = base + "[" + index + "]",
                    location = gl.getAttribLocation(id, name);
                }
            }
        }
           
        this.loaded = true;
    } else {
        console.error("Shader program failed to link!");
        console.error(gl.getProgramInfoLog(id));
    }
}
/**
 * @class
 * @classdesc A simple wrapper around WebGL.
 * @param {HTMLCanvasElement} canvas The canvas to create a WebGL context for.
 */
function WebGL(canvas) {
    let gl;

    for (let identifier of["webgl", "experimental-webgl"]) {
        try {
            // preserveDrawingBuffer is needed normally to be able to use the WebGL canvas as an image source (e.g. RTT).
            // It however makes rendering slower, since it doesn't let browsers implement optimizations.
            // For proper support, use the viewer's render event - the internal WebGL buffer is still valid there.
            gl = canvas.getContext(identifier, { antialias: true, alpha: false/*, preserveDrawingBuffer: true*/ });
        } catch (e) {

        }

        if (gl) {
            break;
        }
    }

    if (!gl) {
        throw new Error("WebGL: Failed to create a WebGL context!");
    }

    function extensionToCamelCase(ext) {
        let tokens = ext.split("_"),
            result = tokens[1];

        for (let i = 2, l = tokens.length; i < l; i++) {
            result += tokens[i][0].toUpperCase() + tokens[i].substr(1);
        }

        return result;
    }

    let extensions = {};
    for (let extension of gl.getSupportedExtensions()) {
        extensions[extensionToCamelCase(extension)] = gl.getExtension(extension);
    }

    if (!gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)) {
        throw new Error("WebGL: No vertex shader texture support!");
    }

    if (!extensions.textureFloat) {
        throw new Error("WebGL: No floating point texture support!");
    }

    if (!extensions.instancedArrays) {
        throw new Error("WebGL: No instanced rendering support!");
    }

    if (!extensions.compressedTextureS3tc) {
        console.warn("WebGL: No compressed textures support! This might reduce performance.");
    }

    gl.extensions = extensions;

    // The only initial setup required, the rest should be handled by the handelrs
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.DEPTH_TEST);

    /** @member {WebGLRenderingContext} */
    this.gl = gl;
    /** @member {array} */
    this.extensions = extensions;
    /** @member {map.<number, ShaderUnit>} */
    this.shaderUnits = new Map();
    /** @member {map.<number, ShaderProgram>} */
    this.shaderPrograms = new Map();
    /** @member {?ShaderProgram} */
    this.currentShaderProgram = null;
    /** @member {string} */
    this.floatPrecision = "precision mediump float;\n";

    // An empty 2x2 texture that is used automatically when binding an invalid texture
    const emptyTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, emptyTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, new ImageData(2, 2));
    /** @member {WebGLTexture} */
    this.emptyTexture = emptyTexture;
}

WebGL.prototype = {
    /**
     * @method
     * @desc Create a new shader unit. Uses caching.
     * @param {string} src The shader source.
     * @param {number} type The shader type.
     * @returns {ShaderUnit}
     */
    createShaderUnit(src, type) {
        let hash = hashFromString(src),
            shaderUnits = this.shaderUnits;

        if (!shaderUnits.has(hash)) {
            shaderUnits.set(hash, new ShaderUnit(this.gl, src, type));
        }

        return shaderUnits.get(hash);
    },

    /**
     * @method
     * @desc Create a new shader program. Uses caching.
     * @param {ShaderUnit} vertexShader The vertex shader unit.
     * @param {ShaderUnit} fragmentShader The fragment shader unit.
     * @returns {ShaderProgram}
     */
    createShaderProgram(vertexSource, fragmentSource) {
        let gl = this.gl,
            vertexShader = this.createShaderUnit(vertexSource, gl.VERTEX_SHADER),
            fragmentShader = this.createShaderUnit(this.floatPrecision + fragmentSource, gl.FRAGMENT_SHADER),
            shaderPrograms = this.shaderPrograms;

        if (vertexShader.loaded && fragmentShader.loaded) {
            let hash = hashFromString(vertexSource + fragmentSource);

            if (!shaderPrograms.has(hash)) {
                shaderPrograms.set(hash, new ShaderProgram(gl, vertexShader, fragmentShader));
            }

            let shaderProgram = shaderPrograms.get(hash);

            if (shaderProgram.loaded) {
                return shaderProgram;
            }
        }
    },

    createResizeableBuffer() {
        return new ResizeableBuffer(this.gl);
    },

    enableVertexAttribs(start, end) {
        const gl = this.gl;

        for (let i = start; i < end; i++) {
            gl.enableVertexAttribArray(i);
        }
    },

    disableVertexAttribs(start, end) {
        const gl = this.gl;

        for (let i = start; i < end; i++) {
            gl.disableVertexAttribArray(i);
        }
    },

    /**
     * @method
     * @desc Use a shader program.
     * @param {ShaderProgram} shaderProgram The program.
     */
    useShaderProgram(shaderProgram) {
        if (shaderProgram && shaderProgram.loaded && shaderProgram !== this.currentShaderProgram) {
            let oldAttribs = 0,
                newAttribs = shaderProgram.attribs.size;

            if (this.currentShaderProgram) {
                oldAttribs = this.currentShaderProgram.attribs.size;
            }

            this.gl.useProgram(shaderProgram.webglResource);

            if (newAttribs > oldAttribs) {
                this.enableVertexAttribs(oldAttribs, newAttribs);
            } else if (newAttribs < oldAttribs) {
                this.disableVertexAttribs(newAttribs, oldAttribs);
            }

            this.currentShaderProgram = shaderProgram;
        }
    },

    /**
     * @method
     * @desc Bind a texture. Note: if the given texture is invalid (null or not loaded) then a 2x2 black texture will be bound instead to avoid WebGL errors.
     * @param {Texture} texture The texture to bind.
     * @param {number} unit The texture unit to bind to.
     */
    bindTexture(texture, unit) {
        const gl = this.gl;

        gl.activeTexture(gl.TEXTURE0 + unit);

        if (texture && texture.loaded) {
            gl.bindTexture(gl.TEXTURE_2D, texture.webglResource);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this.emptyTexture); // To avoid WebGL errors, bind an empty texture, in case an invalid one was given
        }
    }
};
function Frustum() {
    // Left, right, top, bottom, near, far
    this.planes = [quat.create(), quat.create(), quat.create(), quat.create(), quat.create(), quat.create()];
}

Frustum.prototype = {
    /*
plane.distanceToPoint = function (p, v) {
    return p[0] * v[0] + p[1] * v[1] + p[2] * v[2] + p[3];
};

plane.classifyPoint = function (plane, point) {
    let d = plane[0] * point[0] + plane[1] * point[1] + plane[2] * point[2] + plane[3];

    if (d < 0) {
        return -1;
    } else if (d > 0) {
        return 1;
    }

    return 0;
};
     */

    /// NOTE: NOT SCALING RADIUS
    testIntersectionSphere(boundingShape) {
        const TEST_INSIDE = 2,
            TEST_INTERSECT = 1,
            TEST_OUTSIDE = 0;

        let worldLocation = boundingShape.worldLocation,
            worldScale = boundingShape.worldScale,
            planes = this.planes,
            radius = boundingShape.radius;

        for (let i = 0; i < 6; i++) {
            let plane = planes[i],
                d = plane[0] * worldLocation[0] + plane[1] * worldLocation[1] + plane[2] * worldLocation[2] + plane[3];

            if (d < -radius) {
                return TEST_OUTSIDE;
            }

            if (Math.abs(d) < radius) {
                return TEST_INTERSECT;
            }
        }

        return TEST_INSIDE;
    },

    testIntersectionAABB(boundingShape) {
        const TEST_INSIDE = 2,
            TEST_INTERSECT = 1,
            TEST_OUTSIDE = 0;

        let worldLocation = boundingShape.worldLocation,
            worldScale = boundingShape.worldScale,
            planes = this.planes,
            result = TEST_INSIDE,
            v = vec3.heap;

        for (let i = 0; i < 6; i++) {
            let plane = planes[i],
                a = plane[0],
                b = plane[1],
                c = plane[2],
                d = plane[3],
                v2 = [];
               
            // Positive vertex
            boundingShape.getPositiveVertex(v, plane);
            vec3.mulAndAdd(v2, v, worldScale, worldLocation);
            if ((a * v2[0] + b * v2[1] + c * v2[2] + d) < 0) {
                return TEST_OUTSIDE;
            }

            // Negative vertex
            boundingShape.getNegativeVertex(v, plane);
            vec3.mulAndAdd(v2, v, worldScale, worldLocation);
            if ((a * v2[0] + b * v2[1] + c * v2[2] + d) < 0) {
                result = TEST_INTERSECT;
            }

        }

        return result;
    },

    recalculateFrustum(m) {
        let a00 = m[0], a01 = m[4], a02 = m[8], a03 = m[12],
            a10 = m[1], a11 = m[5], a12 = m[9], a13 = m[13],
            a20 = m[2], a21 = m[6], a22 = m[10], a23 = m[14],
            a30 = m[3], a31 = m[7], a32 = m[11], a33 = m[15],
            planes = this.planes,
            plane;

        // Left clipping plane
        plane = planes[0];
        plane[0] = a30 + a00;
        plane[1] = a31 + a01;
        plane[2] = a32 + a02;
        plane[3] = a33 + a03;

        // Right clipping plane
        plane = planes[1];
        plane[0] = a30 - a00;
        plane[1] = a31 - a01;
        plane[2] = a32 - a02;
        plane[3] = a33 - a03;

        // Top clipping plane
        plane = planes[2];
        plane[0] = a30 - a10;
        plane[1] = a31 - a11;
        plane[2] = a32 - a12;
        plane[3] = a33 - a13;

        // Bottom clipping plane
        plane = planes[3];
        plane[0] = a30 + a10;
        plane[1] = a31 + a11;
        plane[2] = a32 + a12;
        plane[3] = a33 + a13;

        // Near clipping plane
        plane = planes[4];
        plane[0] = a30 + a20;
        plane[1] = a31 + a21;
        plane[2] = a32 + a22;
        plane[3] = a33 + a23;

        // Far clipping plane
        plane = planes[5];
        plane[0] = a30 - a20;
        plane[1] = a31 - a21;
        plane[2] = a32 - a22;
        plane[3] = a33 - a23;

        /*
        quat.normalize(planes[0], planes[0]);
        quat.normalize(planes[1], planes[1]);
        quat.normalize(planes[2], planes[2]);
        quat.normalize(planes[3], planes[3]);
        quat.normalize(planes[4], planes[4]);
        quat.normalize(planes[5], planes[5]);
        */
    }
};
function Camera(fieldOfView, aspectRatio, nearClipPlane, farClipPlane) {
    Node.call(this, true);
    Frustum.call(this);

    this.fieldOfView = fieldOfView;
    this.aspectRatio = aspectRatio;
    this.nearClipPlane = nearClipPlane;
    this.farClipPlane = farClipPlane;
    this.viewport = vec4.create();
    this.projectionMatrix = mat4.create();
    this.worldProjectionMatrix = mat4.create();
    this.inverseWorldMatrix = mat4.create();
    this.inverseRotation = quat.create();
    this.inverseRotationMatrix = mat4.create();
    this.inverseWorldProjectionMatrix = mat4.create();

    // First four vectors are the corners of a 2x2 rectangle, the last three vectors are the unit axes
    this.vectors = [vec3.fromValues(-1, -1, 0), vec3.fromValues(-1, 1, 0), vec3.fromValues(1, 1, 0), vec3.fromValues(1, -1, 0), vec3.fromValues(1, 0, 0), vec3.fromValues(0, 1, 0), vec3.fromValues(0, 0, 1)];

    // First four vectors are the corners of a 2x2 rectangle billboarded to the camera, the last three vectors are the unit axes billboarded
    this.billboardedVectors = [vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create()];

    // Left, right, top, bottom, near, far
    this.planes = [quat.create(), quat.create(), quat.create(), quat.create(), quat.create(), quat.create()];

    this.recalculateTransformation();
}

Camera.prototype = {
    setViewport(viewport) {
        vec4.copy(this.viewport, viewport);
        
        this.aspectRatio = viewport[2] / viewport[3];
        
        this.recalculateTransformation();
    },

    recalculateTransformation() {
        let worldMatrix = this.worldMatrix,
            projectionMatrix = this.projectionMatrix,
            worldProjectionMatrix = this.worldProjectionMatrix,
            inverseRotation = this.inverseRotation,
            vectors = this.vectors,
            billboardedVectors = this.billboardedVectors;

        // Projection matrix
        // Camera space -> NDC space
        mat4.perspective(projectionMatrix, this.fieldOfView, this.aspectRatio, this.nearClipPlane, this.farClipPlane);

        // Recalculate the node part
        Node.prototype.recalculateTransformation.call(this);

        // World projection matrix
        // World space -> NDC space
        mat4.mul(worldProjectionMatrix, projectionMatrix, worldMatrix);

        // Inverse rotation matrix
        // Used for billboarding etc.
        quat.invert(inverseRotation, this.worldRotation);
        mat4.fromQuat(this.inverseRotationMatrix, inverseRotation);

        // Inverse world matrix
        // Camera space -> World space
        mat4.invert(this.inverseWorldMatrix, worldMatrix);

        // Inverse world projection matrix
        // NDC space -> World space
        mat4.invert(this.inverseWorldProjectionMatrix, worldProjectionMatrix);

        // Cache the billboarded vectors
        for (let i = 0; i < 7; i++) {
            vec3.transformQuat(billboardedVectors[i], vectors[i], inverseRotation);
        }

        // Caculate the camera's frusum planes
        this.recalculateFrustum(worldProjectionMatrix);
    },

    // Given a vector in camera space, return the vector transformed to world space
    cameraToWorld(out, v) {
        vec3.copy(out, v);
        vec3.transformMat4(out, out, this.inverseWorldMatrix);

        return out;
    },

    // Given a vector in world space, return the vector transformed to camera space
    worldToCamera(out, v) {
        vec3.transformQuat(out, v, this.inverseRotation);

        return out;
    },

    // Given a vector in world space, return the vector transformed to screen space
    worldToScreen(out, v) {
        let temp = vec3.heap,
            viewport = this.viewport;

        vec3.transformMat4(temp, v, this.worldProjectionMatrix);

        out[0] = Math.round(((temp[0] + 1) / 2) * viewport[2]);
        out[1] = Math.round(((temp[1] + 1) / 2) * viewport[3]);

        return out;
    },

    // Given a vector in screen space, return the vector transformed to world space, projected on the X-Y plane
    screenToWorld(out, v) {
        let a = vec3.heap,
            b = vec3.heap2,
            c = vec3.heap3,
            x = v[0],
            y = v[1],
            inverseWorldProjectionMatrix = this.inverseWorldProjectionMatrix,
            viewport = this.viewport;

        // Intersection on the near-plane
        vec3.unproject(a, vec3.set(c, x, y, 0), inverseWorldProjectionMatrix, viewport);

        // Intersection on the far-plane
        vec3.unproject(b, vec3.set(c, x, y, 1), inverseWorldProjectionMatrix, viewport);

        // Intersection on the X-Y plane
        let zIntersection = -a[2] / (b[2] - a[2]);

        vec3.set(out, a[0] + (b[0] - a[0]) * zIntersection, a[1] + (b[1] - a[1]) * zIntersection, 0);

        //console.log(out, a, b, zIntersection)
        return out;
    }
};

mix(Camera.prototype, Node.prototype, Frustum.prototype);
const Handler = {
    // Will be called when adding the handler to the viewer, with env being the viewer itself
    initialize(env) {
        return true;
    },

    get objectType() {
        throw new Error("Handler.objectType must be overriden!");
    },

    // The file extension as a string, e.g. ".png", or if it handles multiple extensions - ".png|.jpg"
    get extension() {
        throw new Error("Handler.extension must be overriden!");
    },

    // The main implementation object that this handler handles.
    // E.g. the model constructor for a model handler.
    get Constructor() {
        throw new Error("Handler.Constructor must be overriden!");
    },

    get binaryFormat() {
        return false;
    }
};
const ModelHandler = {
    get objectType() {
        return "modelhandler"
    },

    get ModelView() {
        return ModelView;
    },

    get Instance() {
        return ModelInstance;
    },

    get Bucket() {
        return Bucket;
    }
};

mix(ModelHandler, Handler);
const TextureHandler = {
    get objectType() {
        return "texturehandler"
    }
};

mix(TextureHandler, Handler);
const FileHandler = {
    get objectType() {
        return "filehandler"
    }
};

mix(FileHandler, Handler);
/**
 * @class
 * @classdesc A model. The point of this viewer.
 * @extends DownloadableResource
 * @param {ModelViewer} env The model viewer object that this model belongs to.
 * @param {function} pathSolver A function that solves paths. See more {@link LoadPathSolver here}.
 */
function Model(env, pathSolver) {
    DownloadableResource.call(this, env, pathSolver);

    /** @member {ModelView[]} */
    this.views = [];

    // Create a default view
    this.addView();
}


Model.prototype = {
    get objectType() {
        return "model";
    },

    get Handler() {
        throw new Error("Model.Handler must be overriden!");
    },

    /**
     * @method
     * @desc Adds a new view to this model, and returns the view.
     * @returns {@link ModelView}
     */
    addView(scene) {
        // If no scene is given, use the default scene
        scene = scene || this.env.scenes[0];

        const view = new this.Handler.ModelView(this);

        // Add this view to the model
        this.views.push(view);

        // Add this view to the scene
        scene.addView(view);

        // Call the view's modelReady function when the model is ready
        this.finalizeView(view);

        return view;
    },

    finalizeView(view) {
        if (this.error || this.loaded) {
            view.modelReady();
        } else {
            this.addAction(view => this.finalizeView(view), [view]);
        }
    },

    /**
     * @method
     * @desc Adds a new instance to the first view owned by this model, and returns the instance.
     *       Equivalent to model.views[0].addInstance()
     * @returns {@link ModelInstance}
     */
    addInstance() {
        return this.views[0].addInstance();
    },

    /**
     * @method
     * @desc Deletes an instance from the first view owned by this model, and returns the instance.
     *       Equivalent to model.views[0].deleteInstance(instance)
     * @returns {@link ModelInstance}
     */
    deleteInstance(instance) {
        return this.views[0].deleteInstance(instance);
    },

    update() {
        const views = this.views;

        for (let i = 0, l = views.length; i < l; i++) {
            views[i].update();
        }
    },

    renderOpaque(bucket) {

    },

    renderTranslucent(bucket) {

    },

    renderEmitters(bucket) {

    }
};

mix(Model.prototype, DownloadableResource.prototype);
/**
 * @class
 * @classdesc This class holds all of the model instances.
 *            It is used to possibly give multiple "views" of the same model.
 *            That is, use the same base model, but have some variations on a per-view basis, hence giving multiple versions of the model.
 *            Mostly used for texture overriding, to allow having multiple instances with different textures.
 * @extends ActionQueue
 * @param {Model} model The model that this view belongs to.
 */
function ModelView(model) {
    /** @member {Model} */
    this.model = model;
    /** @member {ModelInstance[]} */
    this.instances = [];
    /** @member {Bucket[]} */
    this.buckets = [];
    /** @member {map.<ModelInstance, Bucket>} */
    this.instanceToBucket = new Map(); // instance->bucket map
    /** @member {boolean} */
    this.rendered = true;
    /** @member {Scene} */
    this.scene = null;

    ActionQueue.call(this);
}

ModelView.prototype = {
    /** @member {string} */
    get objectType() {
        return "modelview";
    },

    setScene(scene) {
        if (scene && scene.objectType === "scene") {
            this.scene = scene;
        }
    },

    /**
     * @method
     * @desc Adds a new instance  to this view, and returns the instance.
     * @returns {@link ModelInstance}
     */
    addInstance() {
        let model = this.model,
            resource = new model.Handler.Instance(model.env);

        model.env.registerEvents(resource);

        resource.load(this);

        return resource;
    },

    /**
     * @method
     * @desc Deletes the given instance from this view, and returns it.
     * @returns {@link ModelInstance}
     */
    deleteInstance(instance) {
        const instances = this.instances;

        this.hideInstance(instance);

        instances.splice(instances.indexOf(instance), 1);

        this.instanceToBucket.delete(instance);

        return instance;
    },

    // Find a bucket that isn't full. If no bucket is found, add a new bucket and return it.
    getAvailableBucket() {
        const model = this.model,
            buckets = this.buckets;

        for (let bucket of buckets) {
            if (!bucket.isFull()) {
                return bucket;
            }
        }

        const bucket = new model.Handler.Bucket(this);

        buckets.push(bucket);

        return bucket;
    },

    // The model is ready, and so the view can update.
    // This doesn't mean the model is actually valid, just that it finished loading (regardless of the reason).
    modelReady() {
        this.applyActions();
    },

    // Add the given instance to this model
    // This is called by the instance itself when it finishes loading (either instantly, or after a while if the model was still loading)
    add(instance) {
        if (this.model.error) {
            instance.modelError();
        } else if (this.model.loaded) {
            this.instances.push(instance);

            instance.modelReady();
        } else {
            this.addAction(instance => this.add(instance), [instance]);
        }
    },

    // Show the given instance
    // This is done by adding it to a bucket, and calling its setSharedData function
    showInstance(instance) {
        const bucket = this.getAvailableBucket();

        this.instanceToBucket.set(instance, bucket);

        instance.setSharedData(bucket.add(instance));
    },

    // Hide the given instance
    // This is done by deleting it from its bucket
    hideInstance(instance) {
        const bucket = this.instanceToBucket.get(instance);

        this.instanceToBucket.delete(instance);

        bucket.delete(instance);
    },

    update() {
        if (this.rendered) {
            const buckets = this.buckets;

            for (let i = 0, l = buckets.length; i < l; i++) {
                buckets[i].update();
            }
        }
    },

    renderOpaque() {
        if (this.rendered) {
            let model = this.model,
                buckets = this.buckets;

            for (let i = 0, l = buckets.length; i < l; i++) {
                model.renderOpaque(buckets[i]);
            }
        }
    },

    renderTranslucent() {
        if (this.rendered) {
            let model = this.model,
                buckets = this.buckets;

            for (let i = 0, l = buckets.length; i < l; i++) {
                model.renderTranslucent(buckets[i]);
            }
        }
    },

    renderEmitters() {
        if (this.rendered) {
            let model = this.model,
                buckets = this.buckets;

            for (let i = 0, l = buckets.length; i < l; i++) {
                model.renderEmitters(buckets[i]);
            }
        }
    }
};

mix(ModelView.prototype, ActionQueue.prototype);
/**
 * @class
 * @classdesc An instance of a model, and an entity in the world that you can see, and move around.
 * @extends AsyncResource
 * @extends Node
 * @param {ModelViewer} env The model viewer object that this instance belongs to.
 */
function ModelInstance(env) {
    AsyncResource.call(this, env);
    Node.call(this, true);
}

ModelInstance.prototype = {
    load(modelView) {
        /** @member {ModelView} */
        this.modelView = modelView;
        /** @member {Model} */
        this.model = modelView.model;
        this.shouldRender = false; // This value should not be used directly, instead use ModelInstance.rendered
        this.noCulling = false; // Set to true if the model should always be rendered

        this.dispatchEvent({ type: "loadstart" });

        modelView.add(this);
    },

    get objectType() {
        return "instance";
    },

    modelReady() {
        this.loaded = true;

        this.initialize();
        this.dispatchEvent({ type: "load" });
        this.rendered = true;
        this.dispatchEvent({ type: "loadend" });
    },

    modelError() {
        this.error = true;

        this.dispatchEvent({ type: "error", error: "InvalidModel" });
        this.dispatchEvent({ type: "loadend" });
    },

    preemptiveUpdate() {

    },

    /**
     * @member {boolean}
     * @desc Sets whether this instance gets rendered or not.
     */
    set rendered(shouldRender) {
        if (this.loaded) {
            // Model.showInstance/hideInstance shouldn't be called multiple times, so check if the mode actually changed
            if (this.shouldRender !== shouldRender) {
                this.shouldRender = shouldRender;

                if (shouldRender) {
                    this.modelView.showInstance(this);
                    this.applyActions(); // This allows to call setters such as setTeamColor also when the instance has no valid arrays, by delaying the actual calls
                    // When the instance is inserted into a bucket again, the calls will be used with the new valid arrays
                } else {
                    this.modelView.hideInstance(this);
                }
            }
        } else if (!this.error) {
            this.addAction((shouldRender) => this.rendered = shouldRender, [shouldRender]);
        }
    },

    get rendered() {
        return this.shouldRender;
    },

    /// TODO: duplicated with BoundingShape, can I do something nice about this? (e.g. parent class)
    // This will be called if this instance is parented to some node, and the node changed
    notify() {
        this.recalculateTransformation();
    },

    setSharedData(sharedData) {

    }
};

mix(ModelInstance.prototype, AsyncResource.prototype, Node.prototype);
/**
 * @class
 * @classdesc A base class for all textures.
 * @extends DownloadableResource
 * @param {ModelViewer} env The model viewer object that this texture belongs to.
 * @param {function} pathSolver A function that solves paths. See more {@link PathSolver here}.
 */
function Texture(env, pathSolver) {
    DownloadableResource.call(this, env, pathSolver);
}

Texture.prototype = {
    get objectType() {
        return "texture";
    },

    setParameters(wrapS, wrapT, magFilter, minFilter) {
        const gl = this.env.gl;

        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
    }
};

mix(Texture.prototype, DownloadableResource.prototype);
/**
 * @class
 * @classdesc A base class for all generic files.
 * @extends DownloadableResource
 * @param {ModelViewer} env The model viewer object that this model belongs to.
 * @param {function} pathSolver A function that solves paths. See more {@link PathSolver here}.
 */
function GenericFile(env, pathSolver) {
    DownloadableResource.call(this, env, pathSolver);
}

GenericFile.prototype = {
    get objectType() {
        return "file";
    }
};

mix(GenericFile.prototype, DownloadableResource.prototype);
/**
 * @class
 * @classdesc A bucket of instances. Used for batch rendering of many instances at the same time, using instanced rendering.
 * @param {ModelView} modelView The view this bucket belongs to.
 */
function Bucket(modelView) {
    let model = modelView.model,
        gl = model.env.gl;

    /** @member {ModelView} */
    this.modelView = modelView;
    /** @member {Model} */
    this.model = model;
    /** @member {ModelInstance[]} */
    this.instances = [];
    /** @member {map.<ModelInstance, number>} */
    this.instanceToIndex = new Map();

    // The index buffer is used instead of gl_InstanceID, which isn't defined in WebGL shaders.
    // It's a simple buffer of indices, [0, 1, ..., this.size - 1].
    // While it can be shared between all buckets in the viewer, this makes the code slightly messy and less dynamic.
    // It's 256 bytes per bucket, no big deal. Right?
    this.instanceIdBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.instanceIdBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Uint16Array(this.size).map((currentValue, index, array) => index), gl.STATIC_DRAW);
}

Bucket.prototype = {
    get objectType() {
        return "bucket";
    },

    // The capacity of this bucket, override at will
    // TODO: This should possibly be dynamic, although tests in the past have shown it to be slower for some unknown reason
    //       For example, the bucket size of a simple model can probably be a lot bigger than that of a complex one
    /** @member {number} */
    get size() {
        return 256;
    },

    update() {
        
    },

    getSharedData(index) {
        
    },

    isFull() {
        return this.instances.length === this.size;
    },

    update() {
        const instances = this.instances;

        for (let i = 0, l = instances.length; i < l; i++) {
            const instance = instances[i];

            instance.preemptiveUpdate();

            if (instance.noCulling || this.isVisible(instance)) {
                instance.update();
            }
        }
    },

    isVisible(instance) {
        //*
        let ndc = vec3.heap,
            worldProjectionMatrix = this.modelView.scene.camera.worldProjectionMatrix;

        // This test checks whether the instance's position is visible in NDC space. In other words, that it lies in [-1, 1] on all axes
        vec3.transformMat4(ndc, instance.worldLocation, worldProjectionMatrix);
        if (ndc[0] >= -1 && ndc[0] <= 1 && ndc[1] >= -1 && ndc[1] <= 1 && ndc[2] >= -1 && ndc[2] <= 1) {
            return true;
        }

        return false;
        //*/

        //return this.model.env.camera.testIntersectionAABB(instance.boundingShape) > 0;
    },

    // Add a new instance to this bucket, and return the shared data object at its index
    add(instance) {
        const index = this.instances.push(instance) - 1;

        this.instanceToIndex.set(instance, index);

        return this.getSharedData(index);
    },

    // This function deletes an instance by moving the last instance into the index of this one
    delete(instance) {
        const index = this.instanceToIndex.get(instance),
              lastIndex = this.instances.length - 1;

        // Remove the reference to this instance from the map
        this.instanceToIndex.delete(instance);

        // If the instance being removed is the last one, there is no need to move anything
        if (index !== lastIndex) {
            // Get the last instance
            const lastInstance = this.instances[lastIndex];

            // Move the last instance to the index of the one being deleted
            this.instances[index] = lastInstance;
            this.instanceToIndex.set(lastInstance, index);

            // Set the shared data of the previously last instance
            lastInstance.setSharedData(this.getSharedData(index));
        }

        // Finally remove the last instance from the last index
        this.instances.pop();
    }
};
/**
 * @class
 * @classdesc A scene.
 *            Scenes allow to render different model views with different cameras.
 */
function Scene(env) {
    let canvas = env.canvas;

    /** @member {ModelViewer} */
    this.env = env;
    /** @member {ModelView[]} */
    this.modelViews = [];
    /** @member {Camera} */
    this.camera = new Camera(Math.PI / 4, 1, 10, 100000);
    /** @member {boolean} */
    this.rendered = true;

    // Default the camera's viewport to the whole canvas used by the viewer
    this.camera.setViewport([0, 0, canvas.width, canvas.height]);
}

Scene.prototype = {
    /** @member {string} */
    get objectType() {
        return "scene";
    },

    /**
     * @method
     * @desc Adds a new view  to this scene, while setting the view's scene to this scene.
     * @param {ModelView} modelView The model view to add.
     */
    addView(modelView) {
        if (modelView && modelView.objectType === "modelview") {
            modelView.setScene(this);

            this.modelViews.push(modelView);
        }
    },

    clear() {
        this.modelViews.length = 0;
    },

    renderViewsOpaque() {
        if (this.rendered) {
            let views = this.modelViews;

            this.setViewport();

            for (let i = 0, l = views.length; i < l; i++) {
                views[i].renderOpaque();
            }
        }
    },

    renderViewsTranslucent() {
        if (this.rendered) {
            let views = this.modelViews;

            this.setViewport();

            for (let i = 0, l = views.length; i < l; i++) {
                views[i].renderTranslucent();
            }
        }
    },

    renderViewsEmitters() {
        if (this.rendered) {
            let views = this.modelViews;
            
            this.setViewport();

            for (let i = 0, l = views.length; i < l; i++) {
                views[i].renderEmitters();
            }
        }
    },

    setViewport() {
        let viewport = this.camera.viewport;

        this.env.gl.viewport(viewport[0], viewport[1], viewport[2], viewport[3]);
    }
};
/**
 * @class
 * @classdesc The main model viewer class. The starting point of your journey.
 * @extends EventDispatcher
 * @param {HTMLCanvasElement} canvas The canvas object that this model viewer should use.
 */
function ModelViewer(canvas) {
    EventDispatcher.call(this);

    /** @member {boolean} */
    this.paused = false;

    /** @member {object} */
    this.resources = {
        models: {
            array: [],
            map: new Map()
        },

        textures: {
            array: [],
            map: new Map()
        },

        files: {
            array: [],
            map: new Map()
        }
    };

    /** 
     * @desc The speed of animation. Note that this is not the time of a frame in milliseconds, but rather the amount of animation frames to advance each update.
     * @member {number} 
     */
    this.frameTime = 1000 / 60;

    /** @member {HTMLCanvasElement} */
    this.canvas = canvas;

    /** @member {WebGL} */
    this.webgl = new WebGL(canvas);

    /** @member {WebGLRenderingContext} */
    this.gl = this.webgl.gl;

    /** @member {object} */
    this.sharedShaders = {
        // Shared shader code to mimic gl_InstanceID
        "instanceId": `
            attribute float a_InstanceID;
        `,
        // Shared shader code to handle bone textures
        "boneTexture": `
            uniform sampler2D u_boneMap;
            uniform float u_vector_size;
            uniform float u_row_size;

            mat4 boneAtIndex(float column, float row) {
                float offset = column * u_vector_size * 4.0,
                rowOffset = row * u_row_size;

                return mat4(texture2D(u_boneMap, vec2(offset, rowOffset)), texture2D(u_boneMap, vec2(offset + u_vector_size, rowOffset)), texture2D(u_boneMap, vec2(offset + u_vector_size * 2.0, rowOffset)), texture2D(u_boneMap, vec2(offset + u_vector_size * 3.0, rowOffset)));
            }

            `,
        // Shared shader code to handle decoding multiple bytes stored in floats
        "decodeFloat": `
            vec2 decodeFloat2(float f) {
                vec2 v;

                v[1] = floor(f / 256.0);
                v[0] = floor(f - v[1] * 256.0);

                return v;
            }

            vec3 decodeFloat3(float f) {
                vec3 v;

                v[2] = floor(f / 65536.0);
                v[1] = floor((f - v[2] * 65536.0) / 256.0);
                v[0] = floor(f - v[2] * 65536.0 - v[1] * 256.0);

                return v;
            }
        `
    };

    /** @member {map.<string, Handler>} */
    this.handlers = new Map(); // Map from a file extension to an handler

    /** @member {scene} */
    this.scenes = [new Scene(this)];

    /** @member {number} */
    this.resourcesLoading = 0;
    this.addEventListener("loadstart", () => this.resourcesLoading += 1);
    this.addEventListener("loadend", () => this.resourcesLoading -= 1);

    // Main loop
    let step = () => { requestAnimationFrame(step); if (!this.paused) { this.updateAndRender(); } };
    step();
}

ModelViewer.prototype = {
    /**
     * @method
     * @desc Registers a new handler.
     * @param {Handler} handler The handler.
     * @returns this
     */
    addHandler(handler) {
        if (handler) {
            let objectType = handler.objectType;

            if (objectType === "modelhandler" || objectType === "texturehandler" || objectType === "filehandler") {
                let handlers = this.handlers,
                    extensions = handler.extension.split("|");

                // Check to see if this handler was added already.
                if (!handlers.has(extensions[0])) {
                    // Run the global initialization function of the handler.
                    // If it returns true, to signifiy everything worked correctly, add the handler to the handlers map.
                    if (handler.initialize(this)) {
                        // Add each of the handler's extensions to the handler map.
                        for (let extension of extensions) {
                            handlers.set(extension, handler);
                        }

                        return true;
                    } else {
                        this.dispatchEvent({ type: "error", error: "InvalidHandler", extra: "FailedToInitalize" });
                    }
                }
            } else {
                this.dispatchEvent({ type: "error", error: "InvalidHandler", extra: "UnknownHandlerType" });
            }
        }

        return false;
    },

    addScene() {
        let scene = new Scene(this);

        this.scenes.push(scene);

        return scene;
    },

    /**
     * @method
     * @desc Load something. The meat of this whole project.
     *       If a single source was given, a single object will be returned. If an array was given, an array will be returned, with the same ordering.
     * @param {any|any[]} src The source used for the load.
     * @param {function} pathSolver The path solver used by this load, and any subsequent loads that are caused by it (for example, a model that loads its textures).
     * @see See more {@link LoadPathSolver here}.
     * @returns {AsyncResource|AsyncResource[]}
     */
    load(src, pathSolver) {
        if (Array.isArray(src)) {
            return src.map((single) => this.loadSingle(single, pathSolver));
        }

        return this.loadSingle(src, pathSolver);
    },

    /**
     * @method
     * @desc Calls the given callback, when all of the given resources finished loading. In the case all of the resources are already loaded, the call happens immediately.
     * @param {AsyncResource[]} resources The resources to wait for.
     * @param {function} callback The callback.
     */
    whenLoaded(resources, callback) {
        let loaded = 0,
            wantLoaded = resources.length;

        function gotLoaded() {
            loaded += 1;

            if (loaded === wantLoaded) {
                callback(resources);
            }
        }

        for (let i = 0; i < wantLoaded; i++) {
            let resource = resources[i];

            if (this.isViewerResource(resource)) {
                resource.whenLoaded(gotLoaded);
            } else {
                wantLoaded -= 1;
            }
            
        }
    },

    /**
     * @method
     * @desc Calls the given callback, when all of the viewer resources finished loading. In the case all of the resources are already loaded, the call happens immediately.
     *       Note that instances are also counted.
     * @param {AsyncResource[]} resources The resources to wait for.
     * @param {function} callback The callback.
     */
    whenAllLoaded(callback) {
        if (this.resourcesLoading === 0) {
            callback(this);
        } else {
            if (typeof callback !== "function") {
                console.log(callback)
                console.trace();
            }
            // Self removing listener
            let listener = () => { if (this.resourcesLoading === 0) { this.removeEventListener("loadend", listener); callback(this); } };

            this.addEventListener("loadend", listener);
        }
    },

    loadSingle(src, pathSolver) {
        if (src) {
            let extension,
                serverFetch;

            // Built-in texture source
            if (src instanceof HTMLImageElement || src instanceof HTMLVideoElement || src instanceof HTMLCanvasElement || src instanceof ImageData) {
                extension = ".png";
                serverFetch = false;
            } else {
                [src, extension, serverFetch] = pathSolver(src);
            }

            let handler = this.handlers.get(extension.toLowerCase());

            // Is there an handler for this file type?
            if (handler) {
                return this.loadResource(src, extension, serverFetch, pathSolver, handler);
            } else {
                this.dispatchEvent({ type: "error", error: "MissingHandler", extra: [src, extension, serverFetch] });
            }
        }
    },

    registerEvents(resource) {
        let listener = (e) => this.dispatchEvent(e);

        ["loadstart", "load", "loadend", "error", "progress", "delete"].map(e => resource.addEventListener(e, listener));
    },

    pairFromType(objectType) {
        let resources = this.resources;

        if (objectType === "model" || objectType === "modelhandler") {
            return resources.models;
        } else if (objectType === "texture" || objectType === "texturehandler") {
            return resources.textures;
        } else if (objectType === "file" || objectType === "filehandler") {
            return resources.files;
        } else {
            throw new Error("NOPE");
        }
    },

    loadResource(src, extension, serverFetch, pathSolver, handler) {
        let pair = this.pairFromType(handler.objectType),
            map = pair.map;

        if (!map.has(src)) {
            let resource = new handler.Constructor(this, pathSolver);

            map.set(src, resource);
            pair.array.push(resource);

            this.registerEvents(resource);

            this.dispatchEvent({ type: "loadstart", target: resource });

            resource.load(src, handler.binaryFormat, serverFetch);
        }

        return map.get(src);
    },

    /**
     * @method
     * @desc Deletes a resource from the viewer.
     *       Note that this only removes references to this resource, so your code should do the same, to allow GC to work.
     *       This also means that if a resource is referenced by another resource, it is not going to be GC'd.
     *       For example, deleting a texture that is being used by a model, will not actually let the GC to collect it, until the model is deleted too and loses all references.
     */
    delete (resource) {
        if (this.isViewerResource(resource)) {
            let pair = this.pairFromType(resource.objectType),
                objects,
                key;

            // Find the resource in the array and splice it.
            objects = pair.array;
            key = objects.indexOf(resource);
            if (key !== -1) {
                objects.splice(key, 1);
            }

            // Find the resource in the map and delete it.
            objects = pair.map;
            key = objects.findKey(resource);
            if (key) {
                objects.delete(key);
            }
        }
    },

    /**
     * @method
     * @desc Checks if a given object is a resource of the viewer.
     *       This is done by checking the object's objectType field.
     * @param {object} object The object to check.
     * @returns {boolean}
     */
    isViewerResource(object) {
        if (object) {
            let objectType = object.objectType;

            return objectType === "model" || objectType === "texture" || objectType === "file";
        }

        return false;
    },

    /**
     * @method
     * @desc Remove all of the resources from this model viewer.
     */
    clear() {
        let resources = this.resources;

        for (let pair of [resources.models, resources.textures, resources.files]) {
            pair.array.length = 0;
            pair.map.clear();
        }

        for (let scene of this.scenes) {
            scene.clear();
        }
    },

    update() {
        let resources = this.resources,
            objects,
            i,
            l;

        objects = resources.models.array;
        for (i = 0, l = objects.length; i < l; i++) {
            objects[i].update();
        }

        objects = resources.textures.array;
        for (i = 0, l = objects.length; i < l; i++) {
            objects[i].update();
        }

        objects = resources.files.array;
        for (i = 0, l = objects.length; i < l; i++) {
            objects[i].update();
        }
    },

    render() {
        let scenes = this.scenes,
            gl = this.gl,
            i,
            l = scenes.length;

        // See https://www.opengl.org/wiki/FAQ#Masking
        gl.depthMask(1);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        for (i = 0; i < l; i++) {
            scenes[i].renderViewsOpaque();
        }

        for (i = 0; i < l; i++) {
            scenes[i].renderViewsTranslucent();
        }

        for (i = 0; i < l; i++) {
            scenes[i].renderViewsEmitters();
        }

        this.dispatchEvent({ type: "render" })
    },

    updateAndRender() {
        this.update();
        this.render();
    }
};

mix(ModelViewer.prototype, EventDispatcher.prototype);
function SlkLine(line) {
    var tokens = line.split(";"),
        token,
        value;

    // The B command is supposed to define the total number of columns and rows, however in UbetSplatData.slk it gives wrong information
    // Therefore, just ignore it, since JavaScript arrays grow as they want either way
    if (line[0] !== "B") {
        for (var i = 1, l = tokens.length; i < l; i++) {
            token = tokens[i];
            value = token.substring(1);

            switch (token[0]) {
                case "X":
                    this.x = parseInt(value, 10);
                    break;

                case "Y":
                    this.y = parseInt(value, 10);
                    break;

                case "K":
                    this.value = this.parseValue(value);
                    break;
            }
        }
    }
}

SlkLine.prototype = {
    parseValue(value) {
        if (value[0] === "\"") {
            return value.trim().substring(1, value.length - 2);
        }

        return parseFloat(value);
    }
}
/**
 * @class
 * @classdesc An SLK file, used for table data by Warcraft 3.
 * @extends GenericFile
 * @memberOf Slk
 * @param {ModelViewer} env The model viewer object that this texture belongs to.
 * @param {function} pathSolver A function that solves paths. See more {@link PathSolver here}.
 */
function SlkFile(env, pathSolver) {
    GenericFile.call(this, env, pathSolver);
}

SlkFile.prototype = {
    get Handler() {
        return Slk;
    },

    initialize(src) {
        if (!src.startsWith("ID")) {
            this.onerror("InvalidSource", "WrongMagicNumber");
            return false;
        }

        this.parseRows(src);
        this.mapRows();
        this.mapByID();

        return true;
    },

    parseRows(src) {
        var rows = [],
            lines = src.split("\n"),
            line,
            x = 0,
            y = 0;

        for (var i = 0, l = lines.length; i < l; i++) {
            line = new SlkLine(lines[i]);

            if (line.y) {
                y = line.y - 1;

                // If this row doesn't exist yet, add it
                if (!rows[y]) {
                    rows[y] = [];
                }
            }

            if (line.x) {
                x = line.x - 1;
            }

            // Must check against undefined for 0 values
            if (line.value !== undefined) {
                // ...
                if (!rows[y]) {
                    rows[y] = [];
                }

                rows[y][x] = line.value;
            }
        }

        this.rows = rows;
    },

    // This assumes the first row is a header that defines the names of the columns, which is how Blizzard SLKs are written
    mapRows() {
        var mappedRows = [],
            rows = this.rows,
            header = rows[0],
            mappedRow;

        // Hack to unify all the different ID strings
        header[0] = "ID";

        for (var i = 1, l = rows.length; i < l; i++) {
            mappedRows[i - 1] = this.mapRow(header, rows[i]);
        }

        this.mappedRows = mappedRows;
    },

    mapRow(header, row) {
        var mapped = {};

        for (var i = 0, l = header.length; i < l; i++) {

            mapped[header[i]] = row[i];
        }

        return mapped;
    },

    // This assumes that there is some ID to map every row against
    // It allows to get a row by its ID without an O(n) search
    mapByID() {
        var map = {},
            mappedRows = this.mappedRows,
            mappedRow;

        for (var i = 0, l = mappedRows.length; i < l; i++) {
            mappedRow = mappedRows[i];

            map[mappedRow.ID] = mappedRow;
        }

        this.map = map;
    },

    getRow(key) {
        return this.map[key];
    }
};

mix(SlkFile.prototype, GenericFile.prototype);
const Slk = {
    get extension() {
        return ".slk";
    },

    get Constructor() {
        return SlkFile;
    }
};

mix(Slk, FileHandler);
function MpqCrypto() {
    this.prepareCryptTable();
}

MpqCrypto.prototype = {
    prepareCryptTable() {
        let cryptTable = new Uint32Array(0x500),
            seed = 0x00100001,
            temp1,
            temp2;

        for (let index1 = 0; index1 < 0x100; index1++) {
            for (let index2 = index1, i = 0; i < 5; i++, index2 += 0x100) {
                seed = (seed * 125 + 3) % 0x2AAAAB;
                temp1 = (seed & 0xFFFF) << 0x10;

                seed = (seed * 125 + 3) % 0x2AAAAB;
                temp2 = (seed & 0xFFFF);

                cryptTable[index2] = temp1 | temp2;
            }
        }

        this.cryptTable = cryptTable;
    },

    hash(name, hashType) {
        let cryptTable = this.cryptTable,
            seed1 = 0x7FED7FED,
            seed2 = 0xEEEEEEEE,
            ch;

        name = name.toUpperCase();

        for (let i = 0; i < name.length ; i++) {
            ch = name.charCodeAt(i);

            seed1 = cryptTable[(hashType << 8) + ch] ^ (seed1 + seed2);
            seed2 = ch + seed1 + seed2 + (seed2 << 5) + 3;
        }

        // Convert the seed to an unsigned integer
        return seed1 >>> 0;
    },

    decryptBlock(buffer, key) {
        let cryptTable = this.cryptTable,
            seed = 0xEEEEEEEE,
            ch,
            view = new Uint32Array(buffer, 0, buffer.byteLength >>> 2);

        for (let i = 0, l = view.length; i < l; i++) {
            seed += cryptTable[0x400 + (key & 0xFF)];
            ch = view[i] ^ (key + seed);

            key = ((~key << 0x15) + 0x11111111) | (key >>> 0x0B);
            seed = ch + seed + (seed << 5) + 3;

            view[i] = ch;
        }

        return buffer;
    },

    encryptBlock(buffer, key) {
        let cryptTable = this.cryptTable,
            seed = 0xEEEEEEEE,
            ch,
            view = new Uint32Array(buffer, 0, buffer.byteLength >>> 2);

        for (let i = 0, l = view.length; i < l; i++) {
            seed += cryptTable[0x400 + (key & 0xFF)];
            ch = view[i] ^ (key + seed);

            key = ((~key << 0x15) + 0x11111111) | (key >>> 0x0B);
            seed = view[i] + seed + (seed << 5) + 3;

            view[i] = ch;
        }

        return buffer;
    }
};
function MpqHashTableEntry(reader) {
    this.name1 = readUint32(reader);
    this.name2 = readUint32(reader);
    this.locale = readUint16(reader);
    this.platform = readUint16(reader);
    this.blockIndex = readUint32(reader);
}

function MpqHashTable(buffer, c) {
    this.hashSize = buffer.byteLength / 16;
    this.c = c;
    this.prepareEntries(c.decryptBlock(buffer, Mpq.HASH_TABLE_KEY));
}

MpqHashTable.prototype = {
    prepareEntries(buffer) {
        let entries = [],
            reader = new BinaryReader(buffer);

        for (let i = 0, l = this.hashSize; i < l; i++) {
            entries.push(new MpqHashTableEntry(reader));
        }

        this.entries = entries;
    },

    getBlockIndexOfFile(name) {
        let c = this.c,
            name1 = c.hash(name, Mpq.HASH_NAME_A),
            name2 = c.hash(name, Mpq.HASH_NAME_B),
            offset = c.hash(name, Mpq.HASH_TABLE_INDEX) & (this.hashSize - 1),
            entries = this.entries,
            entry;

        for (let i = 0, l = entries.length; i < l; i++) {
            entry = entries[(i + offset) % l];

            if (name1 === entry.name1 && name2 === entry.name2) {
                return entry.blockIndex;
            } else if (entry.platform !== 0) {
                return -1;
            }
        }

        return -1;
    }
};
function MpqBlockTableEntry(reader) {
    this.filePos = readUint32(reader);
    this.compressedSize = readUint32(reader);
    this.normalSize = readUint32(reader);
    this.flags = readUint32(reader);
}

function MpqBlockTable(buffer, c) {
    this.hashSize = buffer.byteLength / 16;
    this.c = c;
    this.prepareEntries(c.decryptBlock(buffer, Mpq.BLOCK_TABLE_KEY));
}

MpqBlockTable.prototype = {
    prepareEntries(buffer) {
        let entries = [],
            reader = new BinaryReader(buffer);

        for (let i = 0, l = this.hashSize; i < l; i++) {
            entries.push(new MpqBlockTableEntry(reader));
        }

        this.entries = entries;
    }
};
/**
 * @class
 * @classdesc A MPQ file, used by Warcraft 3.
 * @memberOf Mpq
 * @param {MpqArchive} archive The archive that owns this file.
 * @param {MpqBlockTableEntry} block This file's block.
 * @param {string} name This file's name.
 */
function MpqFile(archive, block, name) {
    this.archive = archive;
    this.block = block;
    this.name = name;
    this.sectorCount = Math.ceil(block.normalSize / archive.sectorSize);
    this.encryptionKey = 0;

    if (block.flags & Mpq.FILE_ENCRYPTED) {
        let sepIndex = name.lastIndexOf("\\"),
            pathlessName = name.substring(sepIndex + 1);

        this.c = archive.c;
        this.encryptionKey = this.c.hash(pathlessName, Mpq.HASH_FILE_KEY);

        if (block.flags & Mpq.FILE_ADJUSTED_ENCRYPTED) {
            this.encryptionKey = (this.encryptionKey + block.filePos) ^ block.normalSize;
        }
    }

    this.decode();
}

MpqFile.prototype = {
    decode() {
        let archive = this.archive,
            block = this.block,
            flags = block.flags,
            sectorCount = this.sectorCount,
            c = this.c,
            encryptionKey = this.encryptionKey,
            reader = new BinaryReader(archive.buffer);

        // Go to the position of this block
        seek(reader, block.filePos);

        if (flags & Mpq.FILE_SINGLEUNIT) {
            console.warn("[MPQFile::parse] Single unit (add support!)")
            console.log(this);

            if (flags & Mpq.FILE_COMPRESSED) {

            } else {

            }
        }

        if (flags & Mpq.FILE_COMPRESSED) {
            // Alocate a buffer for the uncompressed block size
            let buffer = new Uint8Array(block.normalSize)

            // Get the sector offsets
            let sectorOffsets = readUint32Array(reader, sectorCount + 1);

            // If this block is encrypted, decrypt the sector offsets
            if (c) {
                c.decryptBlock(sectorOffsets.buffer, encryptionKey - 1);
            }

            let start = sectorOffsets[0],
                end = sectorOffsets[1],
                finalSize = 0;

            for (let i = 0; i < sectorCount; i++) {
                // Go to the position of this sector
                seek(reader, block.filePos + start);

                // Read the sector
                let sector = readUint8Array(reader, end - start);

                // If this block is encrypted, decrypt the sector
                if (c) {
                    c.decryptBlock(sector.buffer, encryptionKey + i);
                }

                // Decompress the sector
                if (block.normalSize - finalSize <= archive.sectorSize) {
                    sector = this.decompressSector(sector, block.normalSize - finalSize);
                } else {
                    sector = this.decompressSector(sector, archive.sectorSize);
                }

                // If failed to decompress the sector, stop
                if (!sector) {
                    //console.warn("[MPQFile::parseBlock:" + this.name + "]", "Failed to decompress");
                    return;
                }

                // Add the sector bytes to the buffer
                buffer.set(sector, finalSize);
                finalSize += sector.byteLength;

                // Prepare for the next sector
                if (i < sectorCount) {
                    start = end;
                    end = sectorOffsets[i + 2];
                }
            }

            this.buffer = buffer.buffer;
        } else {
            // Read the sector
            let sector = readUint8Array(reader, block.normalSize);

            // If this block is encrypted, decrypt the sector
            if (c) {
                c.decryptBlock(sector.buffer, encryptionKey);
            }

            this.buffer = sector.buffer;
        }
    },

    decompressSector(buffer, uncompressedSize) {
        if (buffer.byteLength === uncompressedSize) {
            return buffer;
        } else {
            // The first byte is the compression type
            switch (buffer[0]) {
                // Huffman
                //case 1:
                //var huffman = new Huffman(new Uint8Array(buffer.buffer, 1));

                //return huffman.decompress();

                // ZLib
                case 2:
                    var inflate = new Zlib.Inflate(new Uint8Array(buffer.buffer, 1));

                    return inflate.decompress();

                    // PKWare DCL Explode
                    //case 8:
                    //    return Explode(new Uint8Array(buffer.buffer, 1));

                    // Unsupported
                    //default:
                    //console.warn("[MPQ.File:" + this.name + "] compression type " + buffer[0] + " not supported");
                    //return;
            }
        }
    }
};
/**
 * @class
 * @classdesc A MPQ archive, used by Warcraft 3.
 * @extends GenericFile
 * @memberOf Mpq
 * @param {ModelViewer} env The model viewer object that this texture belongs to.
 * @param {function} pathSolver A function that solves paths. See more {@link PathSolver here}.
 */
function MpqArchive(env, pathSolver) {
    GenericFile.call(this, env, pathSolver);
}

MpqArchive.prototype = {
    get handler() {
        return Mpq;
    },

    initialize(src) {
        let reader = new BinaryReader(src);

        this.headerOffset = this.searchHeader(reader);

        if (this.headerOffset === -1) {
            this.onerror("InvalidSource", "HeaderNotFound");
            return false;
        }

        this.buffer = src.slice(this.headerOffset);

        if (this.headerOffset > -1) {
            this.readHeader(reader);

            // Only version 0 is supported, but apparently some maps fake their version, since WC3 ignores it, so ignore it too
            //if (this.formatVersion === 0) {
            this.c = new MpqCrypto();

            this.hashTable = new MpqHashTable(this.buffer.slice(this.hashPos, this.hashPos + this.hashSize * 16), this.c);

            this.blockTable = new MpqBlockTable(this.buffer.slice(this.blockPos, this.blockPos + this.blockSize * 16), this.c);

            this.files = {};
            //}
        }

        return true;
    },

    searchHeader(reader) {
        for (let i = 0, l = Math.floor(reader.byteLength / 512) ; i < l; i++) {
            seek(reader, i * 512)

            if (peek(reader, 4) === "MPQ\x1A") {
                return tell(reader);
            }
        }

        return -1;
    },

    readHeader(reader) {
        skip(reader, 4); // MPQ\x1A
        skip(reader, 4); // Header size

        this.archiveSize = readUint32(reader);
        this.formatVersion = readUint16(reader);
        this.sectorSize = 512 * (1 << readUint16(reader));
        this.hashPos = readUint32(reader);
        this.blockPos = readUint32(reader);
        this.hashSize = readUint32(reader);
        this.blockSize = readUint32(reader);
    },

    /**
     * @method
     * @desc Checks if a file exists in this archive.
     * @param {string} name The file name.
     * @returns {boolean}
     */
    hasFile(name) {
        return this.hashTable.getBlockIndexOfFile(name) !== -1;
    },

    /**
     * @method
     * @desc Extract a file from this archive. Note that this is a lazy and cached operation. That is, files are only decoded from the archive on extraction, and the result is then cached. Further requests to get the same file will get the cached result.
     * @param {string} name The file name.
     * @returns {MpqFile}
     */
    getFile(name) {
        let files = this.files;

        name = normalizePath(name);

        if (!files[name]) {
            let blockIndex = this.hashTable.getBlockIndexOfFile(name);

            if (blockIndex !== -1) {
                let blockEntry = this.blockTable.entries[blockIndex],
                    file = new MpqFile(this, blockEntry, name);

                this.files[name] = file;
            }
        }
        
        return files[name];
    },

    /**
     * @method
     * @desc Get an array of strings, populated by all of the file names in this archive.
     *       Note that this assumes this archive has a listfile, which is not always true.
     *       If there is no listfile, an empty array will be returned.
     * @returns {string[]}
     */
    getFileList() {
        if (this.hasFile("(listfile)")) {
            let file = this.getFile("(listfile)");
                reader = new BinaryReader(file.buffer),
                data = read(reader, reader.byteLength);

            return data.trim().split("\r\n");
        }

        return [];
    }
};

mix(MpqArchive.prototype, GenericFile.prototype);
const Mpq = {
    initialize() {
        Mpq.HASH_TABLE_KEY = 0xC3AF3770;
        Mpq.HASH_TABLE_INDEX = 0;
        Mpq.HASH_NAME_A = 1;
        Mpq.HASH_NAME_B = 2;

        Mpq.BLOCK_TABLE_KEY = 0xEC83B3A3;

        Mpq.HASH_FILE_KEY = 3;
        Mpq.FILE_COMPRESSED = 0x00000200;
        Mpq.FILE_ENCRYPTED = 0x00010000;
        Mpq.FILE_SINGLEUNIT = 0x0100000;
        Mpq.FILE_ADJUSTED_ENCRYPTED = 0x00020000;
        Mpq.FILE_EXISTS = 0x80000000;
        Mpq.FILE_DELETED = 0x02000000;

        return true;
    },

    get extension() {
        return ".mpq";
    },

    get Constructor() {
        return MpqArchive;
    },

    get binaryFormat() {
        return true;
    }
};

mix(Mpq, FileHandler);
/**
 * @class
 * @classdesc A texture that wraps Image, thus supporting PNG, JPG, and GIF.
 * @extends Texture
 * @memberOf NativeTexture
 * @param {ModelViewer} env The model viewer object that this texture belongs to.
 * @param {function} pathSolver A function that solves paths. See more {@link PathSolver here}.
 */
function PngTexture(env, pathSolver) {
    Texture.call(this, env, pathSolver);
}

PngTexture.prototype = {
    get Handler() {
        return Png;
    },

    initialize(src) {
        let gl = this.env.gl;

        // src can either be an Image, or an ArrayBuffer, depending on the way it was loaded
        if (src instanceof HTMLImageElement || src instanceof HTMLVideoElement || src instanceof HTMLCanvasElement || src instanceof ImageData) {
            let id = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, id);
            this.setParameters(gl.REPEAT, gl.REPEAT, gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, src);
            gl.generateMipmap(gl.TEXTURE_2D);

            this.width = src.width;
            this.height = src.height;
            this.webglResource = id;

            return true;
        } else {
            var blob = new Blob([src]),
                url = URL.createObjectURL(blob),
                image = new Image();

            image.onload = _ => {
                let id = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, id);
                this.setParameters(gl.REPEAT, gl.REPEAT, gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.generateMipmap(gl.TEXTURE_2D);

                this.width = image.width;
                this.height = image.height;
                this.webglResource = id;

                this.finalizeLoad();
            };

            image.src = url;
        }
    }
};

mix(PngTexture.prototype, Texture.prototype);
const NativeTexture = {
    get extension() {
        return ".png|.jpg|.gif";
    },

    get Constructor() {
        return PngTexture;
    },

    get binaryFormat() {
        return true;
    }
};

mix(NativeTexture, TextureHandler);
/**
 * @class
 * @classdesc A BLP texture, used by Warcraft 3.
 * @extends Texture
 * @memberOf Blp
 * @param {ModelViewer} env The model viewer object that this model belongs to.
 * @param {function} pathSolver A function that solves paths. See more {@link PathSolver here}.
 */
function BlpTexture(env, pathSolver) {
    Texture.call(this, env, pathSolver);
}

BlpTexture.prototype = {
    get Handler() {
        return Blp;
    },

    initialize(src) {
        const gl = this.env.gl,
              BLP1_MAGIC = 0x31504c42,
              BLP_JPG = 0x0,
              BLP_PALLETE = 0x1;

        if (src.byteLength < 40) {
            this.onerror("InvalidSource", "FileTooSmall");
            return false;
        }

        const header = new Int32Array(src, 0, 39);

        if (header[0] !== BLP1_MAGIC) {
            this.onerror("InvalidSource", "WrongMagicNumber");
            return false;
        }

        const arrayData = new Uint8Array(src),
            content = header[1],
            alphaBits = header[2],
            width = header[3],
            height = header[4],
            mipmapOffset = header[7],
            mipmapSize = header[23],
            imageData = new ImageData(width, height);

        if (content === BLP_JPG) {
            let jpegHeaderSize = new Uint32Array(src, 39 * 4, 1)[0],
                jpegHeader = new Uint8Array(src, 160, jpegHeaderSize),
                jpegData = new Uint8Array(jpegHeaderSize + mipmapSize);

            jpegData.set(jpegHeader);
            jpegData.set(arrayData.subarray(mipmapOffset, mipmapOffset + mipmapSize), jpegHeaderSize);

            const jpegImage = new JpegImage();

            jpegImage.loadFromBuffer(jpegData);

            jpegImage.getData(imageData, jpegImage.width, jpegImage.height);
        } else {
            let pallete = new Uint8Array(src, 156, 1024),
                size = width * height,
                mipmapAlphaOffset = mipmapOffset + size,
                bitBuffer,
                bitsToByte = 1 / alphaBits * 255

            if (alphaBits > 0) {
                bitBuffer = new BitBuffer(arrayData.buffer, mipmapAlphaOffset, Math.ceil((size * alphaBits) / 8));
            }

            for (let index = 0; index < size; index++) {
                let i = arrayData[mipmapOffset + index] * 4,
                    dstI = index * 4;

                imageData.data[dstI] = pallete[i];
                imageData.data[dstI + 1] = pallete[i + 1];
                imageData.data[dstI + 2] = pallete[i + 2];

                if (alphaBits > 0) {
                    imageData.data[dstI + 3] = readBits(bitBuffer, alphaBits) * bitsToByte;
                } else {
                    imageData.data[dstI + 3] = 255;
                }
            }
        }

        // NOTE: BGRA data, it gets sizzled in the shader
        const id = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, id);
        this.setParameters(gl.REPEAT, gl.REPEAT, gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
        gl.generateMipmap(gl.TEXTURE_2D);

        this.width = width;
        this.height = height;
        this.imageData = imageData;
        this.webglResource = id;

        return true;
    }
};

mix(BlpTexture.prototype, Texture.prototype);
const Blp = {
    get extension() {
        return ".blp";
    },

    get Constructor() {
        return BlpTexture;
    },

    get binaryFormat() {
        return true;
    }
};

mix(Blp, TextureHandler);
// Note: This file is largely based on https://github.com/toji/webctx-texture-utils/blob/master/texture-util/dds.js
var dxt4to8 = 255 / 15;
var dxt5to8 = 255 / 31;
var dxt6to8 = 255 / 63;

// 4 bit alpha
function setRgba8888Dxt3(dst, i, int565, a) {
    dst[i] = Math.floor(((int565 >> 11) & 31) * dxt5to8);
    dst[i + 1] = Math.floor(((int565 >> 5) & 63) * dxt6to8);
    dst[i + 2] = Math.floor((int565 & 31) * dxt5to8);
    dst[i + 3] = Math.floor(a * dxt4to8);
}

// 8 bit alpha
function setRgba8888Dxt5(dst, i, int565, a) {
    dst[i] = Math.floor(((int565 >> 11) & 31) * dxt5to8);
    dst[i + 1] = Math.floor(((int565 >> 5) & 63) * dxt6to8);
    dst[i + 2] = Math.floor((int565 & 31) * dxt5to8);
    dst[i + 3] = a;
}

/**
 * Trasnforms DXT1 data to a Uint16Array typed array with 5-6-5 RGB bits.
 * 
 * @param {Uint16Array} src The DXT1 data.
 * @param {number} width The width of the data.
 * @param {number} height The height of the data.
 * @returns {Uint16Array}
 */
function dxt1ToRgb565(src, width, height) {
    let c = new Uint16Array(4),
        dst = new Uint16Array(width * height),
        m,
        dstI,
        i,
        r0, g0, b0, r1, g1, b1;

    for (let blockY = 0, blockHeight = height / 4; blockY < blockHeight; blockY++) {
        for (let blockX = 0, blockWidth = width / 4; blockX < blockWidth; blockX++) {
            i = 4 * (blockY * blockWidth + blockX);
            c[0] = src[i];
            c[1] = src[i + 1];
            r0 = c[0] & 0x1f;
            g0 = c[0] & 0x7e0;
            b0 = c[0] & 0xf800;
            r1 = c[1] & 0x1f;
            g1 = c[1] & 0x7e0;
            b1 = c[1] & 0xf800;

            if (c[0] > c[1]) {
                c[2] = ((5 * r0 + 3 * r1) >> 3) | (((5 * g0 + 3 * g1) >> 3) & 0x7e0) | (((5 * b0 + 3 * b1) >> 3) & 0xf800);
                c[3] = ((5 * r1 + 3 * r0) >> 3) | (((5 * g1 + 3 * g0) >> 3) & 0x7e0) | (((5 * b1 + 3 * b0) >> 3) & 0xf800);
            } else {
                c[2] = (c[0] + c[1]) >> 1;
                c[3] = 0;
            }

            m = src[i + 2];
            dstI = (blockY * 4) * width + blockX * 4;
            dst[dstI] = c[m & 0x3];
            dst[dstI + 1] = c[(m >> 2) & 0x3];
            dst[dstI + 2] = c[(m >> 4) & 0x3];
            dst[dstI + 3] = c[(m >> 6) & 0x3];
            dstI += width;
            dst[dstI] = c[(m >> 8) & 0x3];
            dst[dstI + 1] = c[(m >> 10) & 0x3];
            dst[dstI + 2] = c[(m >> 12) & 0x3];
            dst[dstI + 3] = c[(m >> 14)];
            m = src[i + 3];
            dstI += width;
            dst[dstI] = c[m & 0x3];
            dst[dstI + 1] = c[(m >> 2) & 0x3];
            dst[dstI + 2] = c[(m >> 4) & 0x3];
            dst[dstI + 3] = c[(m >> 6) & 0x3];
            dstI += width;
            dst[dstI] = c[(m >> 8) & 0x3];
            dst[dstI + 1] = c[(m >> 10) & 0x3];
            dst[dstI + 2] = c[(m >> 12) & 0x3];
            dst[dstI + 3] = c[(m >> 14)];
        }
    }

    return dst;
}

/**
 * Trasnforms DXT3 data to a Uint8Array typed array with 8-8-8-8 RGBA bits.
 * 
 * @param {Uint16Array} src The DXT3 data.
 * @param {number} width The width of the data.
 * @param {number} height The height of the data.
 * @returns {Uint8Array}
 */
function dxt3ToRgba8888(src, width, height) {
    let c = new Uint16Array(4),
        dst = new Uint8Array(width * height * 4),
        m,
        a,
        dstI,
        i,
        r0, g0, b0, r1, g1, b1,
        widthBytes = width * 4;

    for (let blockY = 0, blockHeight = width / 4; blockY < blockHeight; blockY++) {
        for (let blockX = 0, blockWidth = height / 4; blockX < blockWidth; blockX++) {
            i = 8 * (blockY * blockWidth + blockX);
            c[0] = src[i + 4];
            c[1] = src[i + 5];
            r0 = c[0] & 0x1f;
            g0 = c[0] & 0x7e0;
            b0 = c[0] & 0xf800;
            r1 = c[1] & 0x1f;
            g1 = c[1] & 0x7e0;
            b1 = c[1] & 0xf800;
            c[2] = ((5 * r0 + 3 * r1) >> 3) | (((5 * g0 + 3 * g1) >> 3) & 0x7e0) | (((5 * b0 + 3 * b1) >> 3) & 0xf800);
            c[3] = ((5 * r1 + 3 * r0) >> 3) | (((5 * g1 + 3 * g0) >> 3) & 0x7e0) | (((5 * b1 + 3 * b0) >> 3) & 0xf800);

            m = src[i + 6];
            a = src[i];
            dstI = (blockY * 16) * width + blockX * 16;
            setRgba8888Dxt3(dst, dstI, c[m & 0x3], a & 0xf);
            setRgba8888Dxt3(dst, dstI + 4, c[(m >> 2) & 0x3], (a >> 4) & 0xf);
            setRgba8888Dxt3(dst, dstI + 8, c[(m >> 4) & 0x3], (a >> 8) & 0xf);
            setRgba8888Dxt3(dst, dstI + 12, c[(m >> 6) & 0x3], (a >> 12) & 0xf);
            a = src[i + 1];
            dstI += widthBytes;
            setRgba8888Dxt3(dst, dstI, c[(m >> 8) & 0x3], a & 0xf);
            setRgba8888Dxt3(dst, dstI + 4, c[(m >> 10) & 0x3], (a >> 4) & 0xf);
            setRgba8888Dxt3(dst, dstI + 8, c[(m >> 12) & 0x3], (a >> 8) & 0xf);
            setRgba8888Dxt3(dst, dstI + 12, c[m >> 14], (a >> 12) & 0xf);
            m = src[i + 7];
            a = src[i + 2];
            dstI += widthBytes;
            setRgba8888Dxt3(dst, dstI, c[m & 0x3], a & 0xf);
            setRgba8888Dxt3(dst, dstI + 4, c[(m >> 2) & 0x3], (a >> 4) & 0xf);
            setRgba8888Dxt3(dst, dstI + 8, c[(m >> 4) & 0x3], (a >> 8) & 0xf);
            setRgba8888Dxt3(dst, dstI + 12, c[(m >> 6) & 0x3], (a >> 12) & 0xf);
            a = src[i + 3];
            dstI += widthBytes;
            setRgba8888Dxt3(dst, dstI, c[(m >> 8) & 0x3], a & 0xf);
            setRgba8888Dxt3(dst, dstI + 4, c[(m >> 10) & 0x3], (a >> 4) & 0xf);
            setRgba8888Dxt3(dst, dstI + 8, c[(m >> 12) & 0x3], (a >> 8) & 0xf);
            setRgba8888Dxt3(dst, dstI + 12, c[m >> 14], (a >> 12) & 0xf);
        }
    }

    return dst;
}

/**
 * Trasnforms DXT5 data to a Uint8Array typed array with 8-8-8-8 RGBA bits.
 * 
 * @param {Uint16Array} src The DXT5 data.
 * @param {number} width The width of the data.
 * @param {number} height The height of the data.
 * @returns {Uint8Array}
 */
function dxt5ToRgba8888(src, width, height) {
    let c = new Uint16Array(4),
        a = new Uint8Array(8),
        alphaBits,
        dst = new Uint8Array(width * height * 4),
        m,
        dstI,
        i,
        r0, g0, b0, r1, g1, b1,
        widthBytes = width * 4;

    for (let blockY = 0, blockHeight = height / 4; blockY < blockHeight; blockY++) {
        for (let blockX = 0, blockWidth = width / 4; blockX < blockWidth; blockX++) {
            i = 8 * (blockY * blockWidth + blockX);
            c[0] = src[i + 4];
            c[1] = src[i + 5];
            r0 = c[0] & 0x1f;
            g0 = c[0] & 0x7e0;
            b0 = c[0] & 0xf800;
            r1 = c[1] & 0x1f;
            g1 = c[1] & 0x7e0;
            b1 = c[1] & 0xf800;
            c[2] = ((5 * r0 + 3 * r1) >> 3) | (((5 * g0 + 3 * g1) >> 3) & 0x7e0) | (((5 * b0 + 3 * b1) >> 3) & 0xf800);
            c[3] = ((5 * r1 + 3 * r0) >> 3) | (((5 * g1 + 3 * g0) >> 3) & 0x7e0) | (((5 * b1 + 3 * b0) >> 3) & 0xf800);
            alphaBits = src[i + 1] + 65536 * (src[i + 2] + 65536 * src[i + 3]);
            a[0] = src[i] & 0xff;
            a[1] = src[i] >> 8;

            if (a[0] > a[1]) {
                a[2] = (54 * a[0] + 9 * a[1]) >> 6;
                a[3] = (45 * a[0] + 18 * a[1]) >> 6;
                a[4] = (36 * a[0] + 27 * a[1]) >> 6;
                a[5] = (27 * a[0] + 36 * a[1]) >> 6;
                a[6] = (18 * a[0] + 45 * a[1]) >> 6;
                a[7] = (9 * a[0] + 54 * a[1]) >> 6;

                /*
                a[2] = (6 * a[0] + a[1]) / 7;
                a[3] = (5 * a[0] + 2 * a[1]) / 7;
                a[4] = (4 * a[0] + 3 * a[1]) / 7;
                a[5] = (3 * a[0] + 4 * a[1]) / 7;
                a[6] = (2 * a[0] + 5 * a[1]) / 7;
                a[7] = (a[0] + 6 * a[1]) / 7;
                //*/
            } else {
                a[2] = (12 * a[0] + 3 * a[1]) >> 4;
                a[3] = (9 * a[0] + 6 * a[1]) >> 4;
                a[4] = (6 * a[0] + 9 * a[1]) >> 4;
                a[5] = (3 * a[0] + 12 * a[1]) >> 4;
                a[6] = 0;
                a[7] = 1

                /*
                a[2] = (4 * a[0] + a[1]) / 5;
                a[3] = (3 * a[0] + 2 * a[1]) / 5;
                a[4] = (2 * a[0] + 3 * a[1]) / 5;
                a[5] = (a[0] + 4 * a[1]) / 5;
                a[6] = 0;
                a[7] = 1;
                //*/
            }

            m = src[i + 6];
            dstI = (blockY * 16) * width + blockX * 16;
            setRgba8888Dxt5(dst, dstI, c[m & 0x3], a[alphaBits & 0x7]);
            setRgba8888Dxt5(dst, dstI + 4, c[(m >> 2) & 0x3], a[(alphaBits >> 3) & 0x7]);
            setRgba8888Dxt5(dst, dstI + 8, c[(m >> 4) & 0x3], a[(alphaBits >> 6) & 0x7]);
            setRgba8888Dxt5(dst, dstI + 12, c[(m >> 6) & 0x3], a[(alphaBits >> 9) & 0x7]);
            dstI += widthBytes;
            setRgba8888Dxt5(dst, dstI, c[(m >> 8) & 0x3], a[(alphaBits >> 12) & 0x7]);
            setRgba8888Dxt5(dst, dstI + 4, c[(m >> 10) & 0x3], a[(alphaBits >> 15) & 0x7]);
            setRgba8888Dxt5(dst, dstI + 8, c[(m >> 12) & 0x3], a[(alphaBits >> 18) & 0x7]);
            setRgba8888Dxt5(dst, dstI + 12, c[m >> 14], a[(alphaBits >> 21) & 0x7]);
            m = src[i + 7];
            dstI += widthBytes;
            setRgba8888Dxt5(dst, dstI, c[m & 0x3], a[(alphaBits >> 24) & 0x7]);
            setRgba8888Dxt5(dst, dstI + 4, c[(m >> 2) & 0x3], a[(alphaBits >> 27) & 0x7]);
            setRgba8888Dxt5(dst, dstI + 8, c[(m >> 4) & 0x3], a[(alphaBits >> 30) & 0x7]);
            setRgba8888Dxt5(dst, dstI + 12, c[(m >> 6) & 0x3], a[(alphaBits >> 33) & 0x7]);
            dstI += widthBytes;
            setRgba8888Dxt5(dst, dstI, c[(m >> 8) & 0x3], a[(alphaBits >> 36) & 0x7]);
            setRgba8888Dxt5(dst, dstI + 4, c[(m >> 10) & 0x3], a[(alphaBits >> 39) & 0x7]);
            setRgba8888Dxt5(dst, dstI + 8, c[(m >> 12) & 0x3], a[(alphaBits >> 42) & 0x7]);
            setRgba8888Dxt5(dst, dstI + 12, c[m >> 14], a[(alphaBits >> 45) & 0x7]);
        }
    }

    return dst;
}
// Note: This file is largely based on https://github.com/toji/webctx-texture-utils/blob/master/texture-util/dds.js
/**
 * @class
 * @classdesc A DDS texture, used by Starcraft 2.
 * @extends Texture
 * @memberOf Dds
 * @param {ModelViewer} env The model viewer object that this texture belongs to.
 * @param {function} pathSolver A function that solves paths. See more {@link PathSolver here}.
 */
function DdsTexture(env, pathSolver) {
    Texture.call(this, env, pathSolver);
}

DdsTexture.prototype = {
    get Handler() {
        return Dds;
    },

    initialize(src) {
        const gl = this.env.gl,
            compressedTextures = this.env.webgl.extensions.compressedTextureS3tc,
            DDS_MAGIC = 0x20534444,
            DDSD_MIPMAPCOUNT = 0x20000,
            DDPF_FOURCC = 0x4,
            FOURCC_DXT1 = 0x31545844,
            FOURCC_DXT3 = 0x33545844,
            FOURCC_DXT5 = 0x35545844,
            header = new Int32Array(src, 0, 31);

        if (header[0] !== DDS_MAGIC) {
            this.onerror("InvalidSource", "WrongMagicNumber");
            return false;
        }

        if (!header[20] & DDPF_FOURCC) {
            this.onerror("UnsupportedFeature", "FourCC");
            return false;
        }

        let fourCC = header[21],
            blockBytes,
            internalFormat;

        if (fourCC === FOURCC_DXT1) {
            blockBytes = 8;
            internalFormat = compressedTextures ? compressedTextures.COMPRESSED_RGBA_S3TC_DXT1_EXT : null;
        } else if (fourCC === FOURCC_DXT3) {
            blockBytes = 16;
            internalFormat = compressedTextures ? compressedTextures.COMPRESSED_RGBA_S3TC_DXT3_EXT : null;
        } else if (fourCC === FOURCC_DXT5) {
            blockBytes = 16;
            internalFormat = compressedTextures ? compressedTextures.COMPRESSED_RGBA_S3TC_DXT5_EXT : null;
        } else {
            this.onerror(UintToTag(fourCC))
            return false;
        }

        internalFormat = null;

        let mipmapCount = 1;

        if (header[2] & DDSD_MIPMAPCOUNT) {
            mipmapCount = Math.max(1, header[7]);
        }

        let width = header[4],
            height = header[3],
            dataOffset = header[1] + 4,
            dataLength,
            byteArray;

        const id = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, id);
        this.setParameters(gl.REPEAT, gl.REPEAT, gl.LINEAR, mipmapCount > 1 ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);

        if (internalFormat) {
            for (let i = 0; i < mipmapCount; i++) {
                dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
                byteArray = new Uint8Array(src, dataOffset, dataLength);
                gl.compressedTexImage2D(gl.TEXTURE_2D, i, internalFormat, width, height, 0, byteArray);
                dataOffset += dataLength;
                width *= 0.5;
                height *= 0.5;
            }
        } else {
            dataLength = Math.max(4, width) / 4 * Math.max(4, height) / 4 * blockBytes;
            byteArray = new Uint16Array(src, dataOffset);

            if (fourCC === FOURCC_DXT1) {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_SHORT_5_6_5, dxt1ToRgb565(byteArray, width, height));
            } else if (fourCC === FOURCC_DXT3) {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, dxt3ToRgba8888(byteArray, width, height));
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, dxt5ToRgba8888(byteArray, width, height));
            }

            gl.generateMipmap(gl.TEXTURE_2D);
        }

        this.width = width;
        this.height = height;
        this.webglResource = id;

        return true;
    }
};

mix(DdsTexture.prototype, Texture.prototype);
const Dds = {
    get extension() {
        return ".dds";
    },

    get Constructor() {
        return DdsTexture;
    },

    get binaryFormat() {
        return true;
    }
};

mix(Dds, TextureHandler);
/**
 * @class
 * @classdesc A TGA texture.
 * @extends Texture
 * @memberOf Tga
 * @param {ModelViewer} env The model viewer object that this texture belongs to.
 * @param {function} pathSolver A function that solves paths. See more {@link PathSolver here}.
 */
function TgaTexture(env, pathSolver) {
    Texture.call(this, env, pathSolver);
}

TgaTexture.prototype = {
    get Handler() {
        return Tga;
    },

    initialize(src) {
        let gl = this.env.gl,
            dataView = new DataView(src),
            imageType = dataView.getUint8(2);

        if (imageType !== 2) {
            this.onerror("UnsupportedFeature", "ImageType");
            return false;
        }

        let width = dataView.getUint16(12, true),
            height = dataView.getUint16(14, true),
            pixelDepth = dataView.getUint8(16),
            imageDescriptor = dataView.getUint8(17);

        if (pixelDepth !== 32) {
            this.onerror("UnsupportedFeature", "BPP");
            return false;
        }

        let id = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, id);
        this.setParameters(gl.REPEAT, gl.REPEAT, gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(src, 18, width * height * 4));
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
        gl.generateMipmap(gl.TEXTURE_2D);

        this.width = width;
        this.height = height;
        this.webglResource = id;

        return true;
    }
};

mix(TgaTexture.prototype, Texture.prototype);
const Tga = {
    get extension() {
        return ".tga";
    },

    get Constructor() {
        return TgaTexture;
    },

    get binaryFormat() {
        return true;
    }
};

mix(Tga, TextureHandler);
/**
 * Creates a rectangle geometry object.
 *
 * @param {number} width The width of the rectangle.
 * @param {number} depth The depth of the rectangle.
 * @returns {object} The geometry object.
 */
function createRectangle(width, depth) {
    return {
        vertices: new Float32Array([-width, depth, 0, -width, -depth, 0, width, -depth, 0, width, depth, 0]),
        uvs: new Float32Array([0, 0, 0, 1, 1, 1, 1, 0]),
        faces: new Uint8Array([0, 1, 2, 0, 2, 3]),
        edges: new Uint8Array([0, 1, 1, 2, 2, 3, 3, 0]),
        boundingRadius: Math.max(width, depth)
    };
}

/**
 * Creates a unit rectangle geometry object.
 * 
 * @returns {object} The geometry object.
 */
function createUnitRectangle() {
    return createRectangle(1, 1);
}

/**
 * Creates a cube geometry object.
 *
 * @param {number} width The width of the cube.
 * @param {number} depth The depth of the cube.
 * @param {number} height The height of the cube.
 * @returns {object} The geometry object.
 */
function createCube(width, depth, height) {
    return { 
        vertices: new Float32Array([-width, -depth, -height, -width, -depth, height, -width, depth, -height, -width, depth, height, width, depth, -height, width, depth, height, width, -depth, -height, width, -depth, height]),
        uvs: new Float32Array([0, 0, 0, 1, 0.25, 0, 0.25, 1, 0.5, 0, 0.5, 1, 0.75, 0, 0.75, 1]),
        faces: new Uint8Array([0, 2, 1, 1, 2, 3, 2, 4, 3, 3, 4, 5, 4, 6, 5, 5, 6, 7, 6, 0, 7, 7, 0, 1, 0, 2, 4, 0, 4, 6, 1, 3, 5, 1, 5, 7]),
        edges: new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 0, 2, 2, 4, 4, 6, 6, 0, 1, 3, 3, 5, 5, 7, 7, 1]),
        boundingRadius: Math.max(width, depth, height)
    };
}

/**
 * Creates a unit cube geometry object.
 * 
 * @returns {object} The geometry object.
 */
function createUnitCube() {
    return createCube(1, 1, 1);
}

// Create a typed array for index buffers based on the biggest possible index
function createIndexArray(size, biggestIndex) {
    if (biggestIndex < 0xFF) {
        return new Uint8Array(size);
    } else if (biggestIndex < 0xFFFF) {
        return new Uint16Array(size);
    } else {
        return new Uint32Array(size);
    }
}

/**
 * Creates a sphere geometry object.
 *
 * @param {number} radius The radius of the sphere.
 * @param {number} stacks The amount of layers from bottom to top.
 * @param {number} slices The number of divisions around the Y axis.
 * @returns {object} The geometry object.
 */
function createSphere(radius, stacks, slices) {
    const points = (stacks + 1) * (slices + 1),
        vertices = new Float32Array(points * 3),
        uvs = new Float32Array(points * 2),
        faces = createIndexArray(stacks * slices * 6, points),
        edges = createIndexArray(stacks * slices * 6, points);

    for (let stack = 0, vOffset = 0, uOffset = 0; stack <= stacks; stack++) {
        let theta = stack * Math.PI / stacks,
            sinTheta = Math.sin(theta),
            cosTheta = Math.cos(theta);

        for (let slice = 0; slice <= slices; slice++, vOffset += 3, uOffset += 2) {
            let phi = slice * 2 * Math.PI / slices,
                sinPhi = Math.sin(phi),
                cosPhi = Math.cos(phi);

            vertices[vOffset + 0] = cosPhi * sinTheta * radius;
            vertices[vOffset + 1] = sinPhi * sinTheta * radius;
            vertices[vOffset + 2] = cosTheta * radius;
            
            uvs[uOffset + 0] = slice / slices;
            uvs[uOffset + 1] = 1 - (stack / stacks);
        }
    }

    for (let stack = 0, fOffset = 0; stack < stacks; stack++) {
        for (let slice = 0; slice < slices; slice++, fOffset += 6) {
            let first = (stack * (slices + 1)) + slice,
                second = first + slices + 1;

            // Faces
            faces[fOffset + 0] = first;
            faces[fOffset + 1] = second;
            faces[fOffset + 2] = first + 1;

            faces[fOffset + 3] = second;
            faces[fOffset + 4] = second + 1;
            faces[fOffset + 5] = first + 1;

            // Edges
            edges[fOffset + 0] = first;
            edges[fOffset + 1] = second;

            edges[fOffset + 2] = first;
            edges[fOffset + 3] = first + 1;

            edges[fOffset + 4] = second;
            edges[fOffset + 5] = second + 1;
        }
    }

    return {
        vertices: vertices,
        uvs: uvs,
        faces: faces,
        edges: edges,
        boundingRadius: radius
    };
}

/**
 * Creates a unit sphere geometry object.
 * 
 * @param {number} stacks The amount of layers from bottom to top.
 * @param {number} slices The number of divisions around the Y axis.
 * @returns {object} The geometry object.
 */
function createUnitSphere(stacks, slices) {
    return createSphere(1, stacks, slices);
}

/**
 * Creates a cylinder geometry object.
 *
 * @param {number} radius The radius of the cylinder.
 * @param {number} height The height of the cylinder.
 * @param {number} slices The number of divisions around the Y axis.
 * @returns {object} The geometry object.
 */
function createCylinder(radius, height, slices) {
    slices = Math.max(slices, 3);

    const points = (slices + 1) * 2 + 2,
        vertices = new Float32Array(points * 3),
        uvs = new Float32Array(points * 2),
        faces = createIndexArray(slices * 12, points),
        edges = createIndexArray(slices * 10, points),
        step = (Math.PI * 2) / slices;

    for (let slice = 0, vOffset = 0, uOffset = 0; slice < slices + 1; slice++, vOffset += 6, uOffset += 4) {
        let x = Math.cos(step * slice) * radius,
            y = Math.sin(step * slice) * radius,
            u = slice / slices;

        vertices[vOffset + 0] = x;
        vertices[vOffset + 1] = y;
        vertices[vOffset + 2] = height;
        vertices[vOffset + 3] = x;
        vertices[vOffset + 4] = y;
        vertices[vOffset + 5] = -height;

        uvs[uOffset + 0] = u;
        uvs[uOffset + 1] = 1;
        uvs[uOffset + 2] = u;
        uvs[uOffset + 3] = 0;
    }

    // Poles
    vertices[vOffset + 0] = 0;
    vertices[vOffset + 1] = 0;
    vertices[vOffset + 2] = height;

    vertices[vOffset + 3] = 0;
    vertices[vOffset + 4] = 0;
    vertices[vOffset + 5] = -height;

    uvs[uOffset + 0] = 0;
    uvs[uOffset + 1] = 1;

    uvs[uOffset + 2] = 0;
    uvs[uOffset + 3] = 0;

    for (let slice = 0, fOffset = 0, eOffset = 0; slice < slices; slice++, fOffset += 12, eOffset += 10) {
        let first = slice * 2;

        // Faces
        faces[fOffset + 0] = first + 0
        faces[fOffset + 1] = first + 1;
        faces[fOffset + 2] = (first + 3) % (points - 2);

        faces[fOffset + 3] = first + 0
        faces[fOffset + 4] = (first + 3) % (points - 2);
        faces[fOffset + 5] = (first + 2) % (points - 2);

        faces[fOffset + 6] = first + 0;
        faces[fOffset + 7] = (first + 2) % (points - 2);
        faces[fOffset + 8] = points - 2;

        faces[fOffset + 9] = first + 1;
        faces[fOffset + 10] = (first + 3) % (points - 2);
        faces[fOffset + 11] = points - 1;

        // Edges
        edges[eOffset + 0] = first + 0;
        edges[eOffset + 1] = first + 1;

        edges[eOffset + 2] = first + 0;
        edges[eOffset + 3] = (first + 2) % (points - 2);

        edges[eOffset + 4] = first + 1;
        edges[eOffset + 5] = (first + 3) % (points - 2);

        edges[eOffset + 6] = first + 0;
        edges[eOffset + 7] = points - 2;

        edges[eOffset + 8] = first + 1;
        edges[eOffset + 9] = points - 1;
    }

    return {
        vertices: vertices,
        uvs: uvs,
        faces: faces,
        edges: edges,
        boundingRadius: Math.max(radius, height)
    };
}

/**
 * Creates a unit cylinder geometry object.
 * 
 * @param {number} slices The number of divisions around the Y axis.
 * @returns {object} The geometry object.
 */
function createUnitCylinder(slices) {
    return createCylinder(1, 1, slices);
}

// See http://gamedev.stackexchange.com/questions/24572/how-does-terrain-following-work-on-height-map/24574#24574
/**
 * Creates an height map geometry object.
 *
 * @param {Array.<number[]>} heightmap The height map as an array of arrays of numbers.
 * @returns {object} The geometry object.
 */
function createHeightMap(heightmap) {
    let columns = heightmap[0].length,
        rows = heightmap.length,
        points = columns * rows,
        vertices = new Float32Array(points * 3),
        uvs = new Float32Array(points * 2),
        faces = new Uint32Array(points * 6),
        edges = new Uint32Array((columns - 1) * (rows - 1) * 4 + (columns - 1) * 2 + (rows - 1) * 2),
        vOffset = 0,
        uOffset = 0,
        fOffset = 0,
        eOffset = 0;

    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < columns; x++, vOffset += 3, uOffset += 2) {
            vertices[vOffset + 0] = x;
            vertices[vOffset + 1] = y;
            vertices[vOffset + 2] = heightmap[y][x];

            uvs[uOffset + 0] = x / (columns - 1);
            uvs[uOffset + 1] = y / (rows - 1);
        }
    }

    for (let y = 0; y < rows - 1; y++) {
        let base = y * columns;

        for (let x = 0; x < columns - 1; x++, fOffset += 6, eOffset += 4) {

            faces[fOffset + 0] = base + x;
            faces[fOffset + 1] = base + x + columns;
            faces[fOffset + 2] = base + x + columns + 1;

            faces[fOffset + 3] = base + x;
            faces[fOffset + 4] = base + x + columns + 1;
            faces[fOffset + 5] = base + x + 1;

            edges[eOffset + 0] = base + x;
            edges[eOffset + 1] = base + x + columns;

            edges[eOffset + 2] = base + x;
            edges[eOffset + 3] = base + x + 1;
        }
    }

    // Last row
    for (let x = 0; x < columns - 1; x++, eOffset += 2) {
        edges[eOffset + 0] = columns * (rows - 1) + x;
        edges[eOffset + 1] = columns * (rows - 1) + x + 1
    }

    // Last column
    for (let y = 0; y < rows - 1; y++, eOffset += 2) {
        edges[eOffset + 0] = (columns) * y + columns - 1;
        edges[eOffset + 1] = (columns) * (y + 1) + columns - 1;
    }

    return {
        vertices: vertices,
        uvs: uvs,
        faces: faces,
        edges: edges
    };
}
/**
 * @class
 * @classdesc A geometry model view.
 * @extends ModelView
 * @memberOf Geo
 * @param {GeometryModel} model The model that this view belongs to.
 */
function GeometryModelView(model) {
    ModelView.call(this, model);

    /** @member {?Texture} */
    this.texture = null;
}

mix(GeometryModelView.prototype, ModelView.prototype);
/**
 * @class
 * @classdesc A geometry model.
 * @extends Model
 * @memberOf Geo
 * @param {ModelViewer} env The model viewer object that this texture belongs to.
 * @param {function} pathSolver A function that solves paths. See more {@link PathSolver here}.
 */
function GeometryModel(env, pathSolver) {
    Model.call(this, env, pathSolver);
}

GeometryModel.prototype = {
    get Handler() {
        return Geo;
    },

    initialize(src) {
        const gl = this.env.gl;

        var geometry = src.geometry;
        var material = src.material;

        var vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, geometry.vertices, gl.STATIC_DRAW);

        var uvBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, geometry.uvs, gl.STATIC_DRAW);

        var faceBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geometry.faces, gl.STATIC_DRAW);

        var edgeBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, edgeBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geometry.edges, gl.STATIC_DRAW);

        this.boundingRadius = geometry.boundingRadius;

        this.vertexArray = geometry.vertices;
        this.uvArray = geometry.uvs;
        this.faceArray = geometry.faces;
        this.edgeArray = geometry.edges;
        this.vertexBuffer = vertexBuffer;
        this.uvBuffer = uvBuffer;
        this.faceBuffer = faceBuffer;
        this.edgeBuffer = edgeBuffer;

        var bytesPerElement = geometry.faces.BYTES_PER_ELEMENT;

        if (bytesPerElement === 1) {
            this.faceIndexType = gl.UNSIGNED_BYTE;
        } else if (bytesPerElement === 2) {
            this.faceIndexType = gl.UNSIGNED_SHORT;
        } else {
            this.faceIndexType = gl.UNSIGNED_INT;
        }

        bytesPerElement = geometry.edges.BYTES_PER_ELEMENT;

        if (bytesPerElement === 1) {
            this.edgeIndexType = gl.UNSIGNED_BYTE;
        } else if (bytesPerElement === 2) {
            this.edgeIndexType = gl.UNSIGNED_SHORT;
        } else {
            this.edgeIndexType = gl.UNSIGNED_INT;
        }

        this.texture = material.texture;

        this.twoSided = material.twoSided || false;
        this.noDepthTest = material.noDepthSet || false;
        this.noDepthSet = material.noDepthSet || false;

        this.uvScale = material.uvScale || new Float32Array([1, 1]);
        this.uvOffset = material.uvOffset || new Float32Array(2);

        this.color = material.color || new Float32Array(3);
        this.edgeColor = material.edgeColor || new Float32Array([255, 255, 255]);

        this.renderMode = 0;

        if (material.renderMode > 0) {
            this.renderMode = material.renderMode;
        }

        this.isBGR = material.isBGR || false;
        this.isBlended = material.isBlended || false;

        this.alpha = material.alpha || 1;

        if (this.alpha < 1) {
            this.translucent = true;
        } else {
            this.opaque = true;
        }

        return true;
    },

    render(bucket) {
        let webgl = this.env.webgl,
            gl = this.env.gl,
            instancedArrays = webgl.extensions.instancedArrays,
            shader = Geo.shader,
            uniforms = shader.uniforms,
            attribs = shader.attribs,
            instances = bucket.instances,
            modelView = bucket.modelView;

        webgl.useShaderProgram(shader);

        gl.uniformMatrix4fv(uniforms.get("u_mvp"), false, modelView.scene.camera.worldProjectionMatrix);

        // Bone texture
        gl.activeTexture(gl.TEXTURE15);
        gl.bindTexture(gl.TEXTURE_2D, bucket.boneTexture);
        gl.uniform1i(uniforms.get("u_boneMap"), 15);
        gl.uniform1f(uniforms.get("u_vector_size"), bucket.vectorSize);
        gl.uniform1f(uniforms.get("u_row_size"), bucket.rowSize);

        // Instanced IDs
        let instanceIdAttrib = attribs.get("a_InstanceID");
        gl.bindBuffer(gl.ARRAY_BUFFER, bucket.instanceIdBuffer);
        gl.vertexAttribPointer(instanceIdAttrib, 1, gl.UNSIGNED_SHORT, false, 2, 0);
        instancedArrays.vertexAttribDivisorANGLE(instanceIdAttrib, 1);

        // Vertices
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(attribs.get("a_position"), 3, gl.FLOAT, false, 12, 0);

        // UVs
        gl.bindBuffer(gl.ARRAY_BUFFER, this.uvBuffer);
        gl.vertexAttribPointer(attribs.get("a_uv"), 2, gl.FLOAT, false, 8, 0);

        if (this.twoSided) {
            gl.disable(gl.CULL_FACE);
        } else {
            gl.enable(gl.CULL_FACE);
        }

        if (this.noDepthTest) {
            gl.disable(gl.DEPTH_TEST);
        } else {
            gl.enable(gl.DEPTH_TEST);
        }

        if (this.noDepthSet) {
            gl.depthMask(0);
        } else {
            gl.depthMask(1);
        }

        if (this.isBlended) {
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        } else {
            gl.disable(gl.BLEND);
        }

        gl.uniform1i(uniforms.get("u_texture"), 0);

        let colorAttrib = attribs.get("a_color");
        instancedArrays.vertexAttribDivisorANGLE(colorAttrib, 1);

        if (this.renderMode === 0 || this.renderMode === 2) {
            webgl.bindTexture(modelView.texture || this.texture, 0);

            gl.uniform1f(uniforms.get("u_isEdge"), 0);
            gl.uniform2fv(uniforms.get("u_uvScale"), this.uvScale);
            gl.uniform2fv(uniforms.get("u_uvOffset"), this.uvOffset);
            gl.uniform1f(uniforms.get("u_isBGR"), this.isBGR);
            gl.uniform1f(uniforms.get("u_alphaMod"), this.alpha)

            // Colors
            gl.bindBuffer(gl.ARRAY_BUFFER, bucket.colorBuffer);
            gl.vertexAttribPointer(colorAttrib, 3, gl.UNSIGNED_BYTE, true, 3, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.faceBuffer);
            instancedArrays.drawElementsInstancedANGLE(gl.TRIANGLES, this.faceArray.length, this.faceIndexType, 0, instances.length);
        }

        if (this.renderMode === 1 || this.renderMode === 2) {
            webgl.bindTexture(null, 0);

            gl.uniform1f(uniforms.get("u_isEdge"), 1);

            // Edge colors
            gl.bindBuffer(gl.ARRAY_BUFFER, bucket.edgeColorBuffer);
            gl.vertexAttribPointer(colorAttrib, 3, gl.UNSIGNED_BYTE, true, 3, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.edgeBuffer);
            instancedArrays.drawElementsInstancedANGLE(gl.LINES, this.edgeArray.length, this.edgeIndexType, 0, instances.length);
        }

        /// Reset the attributes to play nice with other handlers
        instancedArrays.vertexAttribDivisorANGLE(instanceIdAttrib, 0);
        instancedArrays.vertexAttribDivisorANGLE(colorAttrib, 0);
    },

    renderOpaque(bucket) {
        if (this.opaque) {
            this.render(bucket);
        }
    },

    renderTranslucent(bucket) {
        if (this.translucent) {
            this.render(bucket);
        }
    },

    renderEmitters(bucket) {

    }
};

mix(GeometryModel.prototype, Model.prototype);
/**
 * @class
 * @classdesc A geometry model instance.
 * @extends ModelInstance
 * @memberOf Geo
 * @param {ModelViewer} env The model viewer object that this texture belongs to.
 */
function GeometryModelInstance(env) {
    ModelInstance.call(this, env);
}

GeometryModelInstance.prototype = {
    initialize() {
        this.boundingShape = new BoundingShape();
        this.boundingShape.fromVertices(this.model.vertexArray);
        this.boundingShape.setParent(this);
    },

    setSharedData(sharedData) {
        this.bucket = sharedData.bucket;
        this.boneArray = sharedData.boneArray;
        this.colorArray = sharedData.colorArray;
        this.edgeColorArray = sharedData.edgeColorArray;

        // Initialize to the model's material color
        this.setColor(this.model.color);
        this.setEdgeColor(this.model.edgeColor);
    },

    update() {
        mat4.copy(this.boneArray, this.worldMatrix);
    },

    setColor(color) {
        if (this.rendered) {
            this.colorArray.set(color);
            this.bucket.updateColors[0] = 1;
        } else {
            this.addAction(id => this.setColor(color), [color]);
        }

        return this;
    },

    setEdgeColor(color) {
        if (this.rendered) {
            this.edgeColorArray.set(color);
            this.bucket.updateEdgeColors[0] = 1;
        } else {
            this.addAction(id => this.setEdgeColor(color), [color]);
        }

        return this;
    }
};

mix(GeometryModelInstance.prototype, ModelInstance.prototype);
/**
 * @class
 * @classdesc A geometry bucket.
 * @extends Bucket
 * @memberOf Geo
 * @param {GeometryModelView} modelView The model view that this bucket belongs to.
 */
function GeometryBucket(modelView) {
    Bucket.call(this, modelView);

    const env = this.model.env;
    const gl = env.gl;
    const numberOfBones = 1;

    this.env = env;

    this.boneArrayInstanceSize = numberOfBones * 16;

    this.boneArray = new Float32Array(this.boneArrayInstanceSize * this.size);

    this.boneTexture = gl.createTexture();
    this.boneTextureWidth = numberOfBones * 4;
    this.boneTextureHeight = this.size;
    this.vectorSize = 1 / this.boneTextureWidth;
    this.rowSize = 1 / this.boneTextureHeight;

    gl.activeTexture(gl.TEXTURE15);
    gl.bindTexture(gl.TEXTURE_2D, this.boneTexture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.boneTextureWidth, this.boneTextureHeight, 0, gl.RGBA, gl.FLOAT, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

    // Color (per instance)
    this.updateColors = new Uint8Array(1);
    this.colorArray = new Uint8Array(3 * this.size);
    this.colorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.colorArray, gl.DYNAMIC_DRAW);

    // Edge color (per instance)
    this.updateEdgeColors = new Uint8Array(1);
    this.edgeColorArray = new Uint8Array(3 * this.size);
    this.edgeColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.edgeColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.edgeColorArray, gl.DYNAMIC_DRAW);
}

GeometryBucket.prototype = {
    update() {
        Bucket.prototype.update.call(this);

        const gl = this.env.gl,
            size = this.instances.length;

        gl.activeTexture(gl.TEXTURE15);
        gl.bindTexture(gl.TEXTURE_2D, this.boneTexture);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.boneTextureWidth, size, gl.RGBA, gl.FLOAT, this.boneArray);

        if (this.updateColors[0]) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.colorArray.subarray(0, size * 3));

            this.updateColors[0] = 0;
        }

        if (this.updateEdgeColors[0]) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.edgeColorBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.edgeColorArray.subarray(0, size * 3));

            this.updateEdgeColors[0] = 0;
        }
    },

    getSharedData(index) {
        return {
            bucket: this,
            boneArray: new Float32Array(this.boneArray.buffer, this.boneArrayInstanceSize * 4 * index, this.boneArrayInstanceSize),
            colorArray: new Uint8Array(this.colorArray.buffer, 3 * index, 3),
            edgeColorArray: new Uint8Array(this.edgeColorArray.buffer, 3 * index, 3)
        };
    }
};

mix(GeometryBucket.prototype, Bucket.prototype);
const Geo = {
    initialize(env) {
        this.shader = env.webgl.createShaderProgram(
            env.sharedShaders.boneTexture + env.sharedShaders.instanceId + `
                uniform mat4 u_mvp;
                uniform vec2 u_uvOffset;
                uniform vec2 u_uvScale;

                attribute vec3 a_position;
                attribute vec2 a_uv;
                attribute vec2 a_uvScale;
                attribute vec3 a_color;

                varying vec2 v_uv;
                varying vec3 v_color;

                void main() {
                    v_uv = a_uv * u_uvScale + u_uvOffset;
                    v_color = a_color;

                    gl_Position = u_mvp * boneAtIndex(0.0, a_InstanceID) * vec4(a_position, 1.0);
                }
            `,
            `
                uniform sampler2D u_diffuseMap;
                uniform bool u_isBGR;
                uniform bool u_isEdge;
                uniform float u_alphaMod;

                varying vec2 v_uv;
                varying vec3 v_color;

                void main() {
                    vec4 color = vec4(v_color, 1.0);

                    if (u_isEdge) {
                        gl_FragColor = color;
                    } else {
                        vec4 texel = texture2D(u_diffuseMap, v_uv);

                        if (u_isBGR) {
                            texel = texel.bgra;
                        }

                        //gl_FragColor = color * texel;

                        //gl_FragColor.a *= u_alphaMod;

                        gl_FragColor = color + texel;
                    }
                }
            `
        );

        // If a shader failed to compile, don't allow the handler to be registered, and send an error instead.
        if (!this.shader.loaded) {
            return false;
        }

        return true;
    },

    get extension() {
        return ".geo";
    },

    get Constructor() {
        return GeometryModel;
    },

    get ModelView() {
        return GeometryModelView;
    },

    get Instance() {
        return GeometryModelInstance;
    },

    get Bucket() {
        return GeometryBucket;
    },

    pathSolver(src) {
        return [src, ".geo", false];
    }
};

mix(Geo, ModelHandler);
function sequenceSorter(a, b) {
    return a.rarity < b.rarity;
}

function filterSequences(type, sequences) {
    var filtered = [];

    for (var i = 0, l = sequences.length; i < l; i++) {
        sequence = sequences[i];
        name = sequence.name.split("-")[0].replace(/\d/g, "").trim().toLowerCase();

        if (name === type) {
            filtered.push(sequence);
        }
    }

    return filtered;
}

function selectSequence(type, sequences) {
    var sequences = filterSequences(type, sequences);

    sequences.sort(sequenceSorter);

    for (var i = 0, l = sequences.length; i < l; i++) {
        var sequence = sequences[i];
        var rarity = sequence.rarity;

        if (rarity === 0) {
            break;
        }

        if (Math.random() * 10 > rarity) {
            return sequence;
        }
    }

    var sequencesLeft = sequences.length - i;
    var random = i + Math.floor(Math.random() * sequencesLeft);
    var sequence = sequences[random]

    return sequence;
}

function standSequence(target) {
    // This function is registered both with whenLoaded, and with addEventListener.
    // The former sends the object directly, while the latter passes an event object, so take care of this difference here.
    if (target.target) {
        target = target.target;
    }

    if (target.model.sequences) {
        var sequences = target.model.sequences;
        var standSequence = selectSequence("stand", sequences);

        if (standSequence) {
            target.setSequence(standSequence.index);
        }
    }
}


function W3xDroppedItem(reader) {
    this.id = read(reader, 4);
    this.chance = readInt32(reader);
}

function W3xDroppedItemSet(reader) {
    this.items = [];

    for (var i = 0, l = readInt32(reader) ; i < l; i++) {
        this.items[i] = new W3xDroppedItem(reader);
    }
}

function W3xModifiedAbility(reader) {
    this.id = read(reader, 4);
    this.activeForAutocast = readInt32(reader);
    this.heroLevel = readInt32(reader);
}

function W3xInventoryItem(reader) {
    this.slot = readInt32(reader);
    this.id = read(reader, 4);
}

function W3xRandomUnit(reader) {
    this.id = read(reader, 4);
    this.chance = readUint32(reader);
}

function W3xUnit(reader, version, map) {
    this.map = map;

    var id = read(reader, 4);
    var variation = readInt32(reader);
    this.location = readVector3(reader);
    this.angle = readFloat32(reader);
    this.scale = readVector3(reader);
    var flags = readUint8(reader);
    this.player = readInt32(reader);
    skip(reader, 2); // ?
    var hitpoints = readInt32(reader);
    var mana = readInt32(reader);

    if (version > 7) {
        var droppedItemTable = readInt32(reader);
    }

    var droppedItemSetsCount = readInt32(reader);
    var droppedItemSets = [];
    for (var i = 0; i < droppedItemSetsCount; i++) {
        droppedItemSets[i] = new W3xDroppedItemSet(reader);
    }

    var goldAmount = readInt32(reader);
    var targetAcquisition = readFloat32(reader);
    var heroLevel = readInt32(reader);

    if (version > 7) {
        var heroStrength = readInt32(reader);
        var heroAgility = readInt32(reader);
        var heroIntelligence = readInt32(reader);
    }

    var itemsInInventoryCount = readInt32(reader);
    var itemsInInventory = [];
    for (var i = 0; i < itemsInInventoryCount; i++) {
        itemsInInventory[i] = new W3xInventoryItem(reader);
    }

    var modifiedAbilitiesCount = readInt32(reader);
    var modifiedAbilities = [];
    for (var i = 0; i < modifiedAbilitiesCount; i++) {
        modifiedAbilities[i] = new W3xModifiedAbility(reader);
    }

    var randomUnitTable = [];
    var randomFlag = readInt32(reader);
    if (randomFlag === 0) {
        var level = read(reader, 3); // 24bit number
        var itemClass = readUint8(reader);
    } else if (randomFlag === 1) {
        var unitGroup = readUint8(reader);
        var positionInGroup = readUint8(reader);
    } else if (randomFlag === 2) {
        var randomUnits = readInt32(reader);
        for (let i = 0; i < randomUnits; i++) {
            randomUnitTable[i] = new W3xRandomUnit(reader);
        }

        console.log(randomUnitTable)
        /// TODO: implement random selection
        id = randomUnitTable[0].id;
    }

    var customTeamColor = readInt32(reader);
    var waygate = readInt32(reader);
    var creationNumber = readInt32(reader);

    var row = map.slkFiles.unitdata.map[id] || map.slkFiles.itemdata.map[id];
    if (row) {
        var path;

        // Items have a file field, units don't...
        if (row.file) {
            path = row.file.replace(".mdl", ".mdx");

            if (!path.endsWith(".mdx")) {
                path += ".mdx";
            }
        } else {
            this.location[2] += row.moveHeight;

            row = map.slkFiles.unitui.map[id];

            if (!row) {
                console.log("Unknown unit ID", id);
                return;
            }

            

            path = row.file + ".mdx";

            vec3.scale(this.scale, this.scale, row.modelScale);
        }

        this.path = path;
    } else {
        if (id === "sloc") {
            this.path = "Objects/StartLocation/StartLocation.mdx";
        } 
    }

    if (this.path) {
        this.addInstance();
    } else {
        console.log("Unknown unit/item ID", id, randomUnitTable)
    }
}

W3xUnit.prototype = {
    addInstance() {
        const model = this.map.loadFiles(this.path),
            instance = model.addInstance();

        instance.setLocation(this.location);
        instance.setRotation(quat.setAxisAngle(quat.create(), vec3.UNIT_Z, this.angle));
        instance.setScale(this.scale);
        instance.setTeamColor(this.player);

        // Select a random stand sequence when the instance is loaded
        instance.whenLoaded(standSequence);

        // And select a random stand sequence every time a sequence ends
        instance.addEventListener("seqend", standSequence);

        this.instance = instance;
    }
};

function W3xDoodad(reader, version, map) {
    this.map = map;

    var id = read(reader, 4);
    var variation = readInt32(reader);
    this.location = readVector3(reader);
    this.angle = readFloat32(reader);
    this.scale = readVector3(reader);
    var flags = readUint8(reader);
    var life = readUint8(reader);
    var editorId = readInt32(reader);

    if (version > 7) {
        read(reader, 8); // ?
    }

    var row = map.slkFiles.doodads.map[id] || map.slkFiles.destructabledata.map[id];
    if (row) {
        if (row.texFile) {
            this.texFile = map.loadFiles(row.texFile + ".blp");
        }

        var path;
        var file = row.file;

        // Imported, keep the path but change the extension back to mdx
        if (file.endsWith(".mdl")) {
            path = file.replace(".mdl", ".mdx");
        // MPQ file, create the full path using the variation
        } else {
            // The SLK has two versions, one with "dir" and "file", the other just "file", both behave differently
            if (row.dir) {
                path = row.dir.replace(/\\/g, "/") + "/" + row.file + "/" + row.file;
            } else {
                path = row.file.replace(/\\/g, "/");
            }

            if (row.numVar > 1) {
                path += variation;
            }

            path += ".mdx";
        }
        
        this.path = path;
    }

    if (this.path) {
        this.loadModel();
        this.addInstance();
    } else {
        console.log("Unknown doodad/destructable ID", id)
    }

}

W3xDoodad.prototype = {
    loadModel() {
        const model = this.map.loadFiles(this.path);

        // This is used by trees and other doodads that share a model, but override the texture
        if (this.texFile) {
            model.addEventListener("load", () => model.views[0].textures[0] = this.texFile);
        }

        this.model = model;
    },

    addInstance() {
        const instance = this.model.addInstance();

        instance.setLocation(this.location);
        instance.setRotation(quat.setAxisAngle(quat.create(), vec3.UNIT_Z, this.angle));
        instance.setScale(this.scale);
        instance.setSequence(0);

        this.instance = instance;
    }
};

function W3xSpecialDoodad(reader, version, map) {
    var id = read(reader, 4);
    var z = readFloat32(reader);
    var x = readFloat32(reader);
    var y = readFloat32(reader);

    var row = map.slkFiles.doodads.map[id] || map.slkFiles.destructabledata.map[id];
    if (row) {
        var path = row.file;

        if (row.numVar > 1) {
            path += variation;
        }

        path += ".mdx";

        console.log("W3xSpecialDoodad", path)
        //var instance = viewer.load(path, mpqPaths);
        //instance.setLocation([x, y, z]);
    }
}

function W3xModification(reader, useOptionalInts) {
    this.id = read(reader, 4);

    var variableType = readInt32(reader);

    if (useOptionalInts) {
        this.levelOrVariation = readInt32(reader);
        this.dataPointer = readInt32(reader);
    }

    if (variableType === 0) {
        this.value = readInt32(reader);
    } else if (variableType === 1 || variableType === 2) {
        this.value = readFloat32(reader);
    } else if (variableType === 3) {
        this.value = readUntilNull(reader);
    }

    var endModification = read(reader, 4);
}

function W3xModifiedObject(reader, useOptionalInts) {
    this.oldID = read(reader, 4);
    this.newID = read(reader, 4);
    this.modifications = [];

    for (var i = 0, l = readInt32(reader) ; i < l; i++) {
        this.modifications[i] = new W3xModification(reader, useOptionalInts);

    }
}

function W3xModificationTable(reader, useOptionalInts) {
    this.objects = [];

    for (var i = 0, l = readInt32(reader) ; i < l; i++) {
        this.objects[i] = new W3xModifiedObject(reader, useOptionalInts);
    }
}

function W3xTilePoint(reader) {
    this.groundHeight = readInt16(reader);

    var short = readInt16(reader);

    this.waterLevel = short & 0x3FFF;
    this.mapEdge = short & 0xC000;

    var byte = readInt8(reader);

    this.groundTextureType = byte & 0x0F;

    var flags = byte & 0xF0;
    this.ramp = flags & 0x0010;
    this.blight = flags & 0x0020;
    this.water = flags & 0x0040;
    this.boundry = flags & 0x4000;
    
    byte = readInt8(reader);

    this.variation = byte & 31;

    // Values seen are 0, 1, and 2. What is this?
    this.whatIsThis = (byte & 224) >> 5;

    byte = readInt8(reader);

    this.cliffTextureType = (byte & 0xF0) >> 4;
    this.layerHeight = byte & 0x0F;
}

W3xTilePoint.prototype = {
    getWaterHeight() {
        return ((this.waterLevel - 0x2000 + (this.layerHeight - 2) * 0x0200) / 4) / 128;

    },

    getHeight() {
        return ((this.groundHeight - 0x2000 + (this.layerHeight - 2) * 0x0200) / 4) / 128;
    },

    getCliffHeight(cliffHeight) {
        return ((this.groundHeight - 0x2000 + (this.layerHeight - 2) * 0x0200) / 4 - cliffHeight * 128) / 128;
    }
};
/**
 * @class
 * @classdesc A Warcraft 3 map.
 * @extends GenericFile
 * @memberOf W3x
 * @param {ModelViewer} env The model viewer object that this texture belongs to.
 * @param {function} pathSolver A function that solves paths. See more {@link PathSolver here}.
 */
function W3xMap(env, pathSolver) {
    GenericFile.call(this, env, pathSolver);
}

W3xMap.prototype = {
    get Handler() {
        return W3x;
    },

    initialize(src) {
        var reader = new BinaryReader(src);

        if (read(reader, 4) !== "HM3W") {
            this.onerror("InvalidSource", "WrongMagicNumber");
            return false;
        }

        skip(reader, 4);

        this.name = readUntilNull(reader);
        this.flags = readInt32(reader);
        this.maxPlayers = readInt32(reader);

        this.mpq = new MpqArchive(this.env);
        this.mpq.initialize(src);

        console.log(this.mpq.getFileList());

        this.pathSolver = (path) => {
            if (this.mpq.hasFile(path)) {
                return [this.mpq.getFile(path).buffer, true];
            }

            path = path.toLowerCase().replace(/\\/g, "/");

            if (window.location.hostname.match("hiveworkshop")) {
                path = "http://www.hiveworkshop.com/mpq-contents/?path=" + path;
            } else {
                path = "resources/warcraft/" + path;
            }

            return [path, path.substr(path.lastIndexOf(".")), true];
        };

        var paths = [
            "Doodads/Doodads.slk",
            "Doodads/DoodadMetaData.slk",
            "Units/DestructableData.slk",
            "Units/DestructableMetaData.slk",
            "Units/UnitData.slk",
            "Units/ItemData.slk",
            "Units/UnitMetaData.slk",
            "Units/unitUI.slk",
            "TerrainArt/Terrain.slk",
            "TerrainArt/CliffTypes.slk"];

        var files = this.loadFiles(paths);

        this.slkFiles = {};

        for (var i = 0, l = files.length; i < l; i++) {
            this.slkFiles[paths[i].substr(paths[i].lastIndexOf("/") + 1).toLowerCase().split(".")[0]] = files[i];
        }

        this.env.whenAllLoaded(files, () => {
            this.loadTerrain();
            this.loadModifications();
            this.loadDoodads();
            this.loadUnits();
        });

        return true;
    },

    loadFiles(src) {
        return this.env.load(src, this.pathSolver);
    },

    // Doodads and destructables
    loadDoodads() {
        var file = this.mpq.getFile("war3map.doo");

        if (file) {
            var reader = new BinaryReader(file.buffer);

            var id = read(reader, 4);
            var version = readInt32(reader);
            var something = readInt32(reader); // sub version?
            var objects = readInt32(reader);

            for (var i = 0; i < objects; i++) {
                new W3xDoodad(reader, version, this)
            }

            //*
            //skip(reader, 4);
    
            //var specialObjects = readInt32(reader);
    
            //for (var i = 0; i < specialObjects; i++) {
            //    new W3xSpecialDoodad(reader, version, this)
            //}
            //*/
        }
    },

    // Units and items
    loadUnits() {
        var file = this.mpq.getFile("war3mapUnits.doo");

        if (file) {
            var reader = new BinaryReader(file.buffer);

            var id = read(reader, 4);
            var version = readInt32(reader);
            var something = readInt32(reader); // sub version?
            var objects = readInt32(reader);

            for (var i = 0; i < objects; i++) {
                new W3xUnit(reader, version, this);
            }
        }
    },

    heightAt(location) {
        var heightMap = this.heightMap,
            offset = this.offset,
            x = (location[0] / 128) + offset[0],
            y = (location[1] / 128) + offset[1];

        var minY = Math.floor(y),
            maxY = Math.ceil(y),
            minX = Math.floor(x),
            maxX = Math.ceil(x);

        // See if this coordinate is in the map
        if (maxY > 0 && minY < heightMap.length - 1 && maxX > 0 && minX < heightMap[0].length - 1) {
            // See http://gamedev.stackexchange.com/a/24574
            var triZ0 = heightMap[minY][minX],
                triZ1 = heightMap[minY][maxX],
                triZ2 = heightMap[maxY][minX],
                triZ3 = heightMap[maxY][maxX],
                sqX = x - minX,
                sqZ = y - minY,
                height;

            if ((sqX + sqZ) < 1) {
                height = triZ0 + (triZ1 - triZ0) * sqX + (triZ2 - triZ0) * sqZ;
            } else {
                height = triZ3 + (triZ1 - triZ3) * (1 - sqZ) + (triZ2 - triZ3) * (1 - sqX);
            }

            return height * 128;
        }

        return 0;
    },

    loadTerrain() {
        var file = this.mpq.getFile("war3map.w3e");

        if (file) {
            var reader = new BinaryReader(file.buffer);

            var id = read(reader, 4);
            var version = readInt32(reader);
            var tileset = read(reader, 1);
            var haveCustomTileset = readInt32(reader);
            var groundTilesetCount = readInt32(reader);
            var groundTilesets = [];

            for (var i = 0; i < groundTilesetCount; i++) {
                groundTilesets[i] = read(reader, 4);
            }

            var cliffTilesetCount = readInt32(reader);
            var cliffTilesets = [];

            for (var i = 0; i < cliffTilesetCount; i++) {
                cliffTilesets[i] = read(reader, 4);
            }

            var mapSize = readInt32Array(reader, 2);
            var centerOffset = readFloat32Array(reader, 2);

            var tilepoints = [];
            var heightMap = [];

            for (var y = 0; y < mapSize[1]; y++) {
                tilepoints[y] = [];
                heightMap[y] = [];

                for (var x = 0; x < mapSize[0]; x++) {
                    tilepoints[y][x] = new W3xTilePoint(reader);
                    heightMap[y][x] = tilepoints[y][x].getHeight();
                }
            }

            this.mapSize = mapSize;
            this.offset = [-centerOffset[0] / 128, -centerOffset[1] / 128];
            this.tilepoints = tilepoints;
            this.heightMap = heightMap;

            var slk = this.slkFiles.terrain;

            this.tilesetTextures = [];

            var gl = this.env.gl;

            for (var i = 0, l = groundTilesets.length; i < l; i++) {
                var row = slk.getRow(groundTilesets[i]) ;

                this.tilesetTextures.push(this.loadFiles(row.dir + "\\" + row.file + ".blp"));
            }

            var tilesetToBlight = {
                A: "Ashen",
                B: "Barrens",
                C: "Felwood",
                D: "Dungeon",
                F: "Lordf",
                G: "Lords", // Underground is what?
                L: "Lords",
                N: "North",
                Q: "VillageFall",
                V: "Village",
                W: "Lordw",
                X: "Lords", // Dalaran is what?
                Y: "Lords", // Cityscape is what?
                Z: "Lords", // Sunken ruins
                I: "Ice",
                J: "DRuins",
                O: "Outland",
                K: "Citadel"
            };

            this.tilesetTextures.push(this.loadFiles("TerrainArt\\Blight\\" + tilesetToBlight[tileset] + "_Blight.blp"));

            this.blightTextureIndex = groundTilesetCount;

            let cliffSlk = this.slkFiles.clifftypes;

            //console.log(cliffTilesets)
            //console.log(slk)

            this.cliffs = [];
            this.cliffTextures = [];

            for (var i = 0, l = cliffTilesets.length; i < l; i++) {
                var row = cliffSlk.getRow(cliffTilesets[i]);
                //if (row) {
                    path = row.dir + "\\" + row.file + ".blp";

                    this.cliffs.push(row);
                    this.cliffTextures.push(this.loadFiles(path));
                //} else {
                //    console.warn("W3x: unknown tileset texture ID " + cliffTilesets[i]);
                //}
            }

            this.cliffTexturesOffset = groundTilesetCount + 1;

            this.env.whenAllLoaded(this.tilesetTextures, _ => {
                // Try to avoid texture atlas bleeding
                for (let texture of this.tilesetTextures) {
                    // To avoid WebGL errors if a texture failed to load
                    if (texture.loaded) {
                        gl.bindTexture(gl.TEXTURE_2D, texture.webglResource);
                        texture.setParameters(gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.LINEAR, gl.LINEAR);
                    }
                }

                this.loadTerrainCliffs();
                this.loadTerrainGeometry();
                this.loadWater();
            });
        }
    },

    heightsToCliffTag(a, b, c, d) {
        const map = {
            0: "A",
            1: "B",
            2: "C"
        };

        return map[a] + map[b] + map[c] + map[d];
    },

    prepareTilePoints() {
        var mapSize = this.mapSize;
        var tilepoints = this.tilepoints;
        var centerOffset = this.offset;

        for (var y = 0; y < mapSize[1]; y++) {
            for (var x = 0; x < mapSize[0]; x++) {
                var tile = tilepoints[y][x];
                var ltMask = 0, rtMask = 0, lbMask = 0, rbMask = 0;

                if (x > 0) {
                    tile.l = tilepoints[y][x - 1];
                    tile.dl = tile.layerHeight - tile.l.layerHeight;

                    if (tile.dl === 1) {
                        ltMask |= 1;
                        lbMask |= 4;
                    } else if (tile.dl === 2) {
                        ltMask |= 8;
                        lbMask |= 32;
                    }
                }

                if (x < mapSize[0] - 1) {
                    tile.r = tilepoints[y][x + 1];
                    tile.dr = tile.layerHeight - tile.r.layerHeight;

                    if (tile.dr === 1) {
                        rtMask |= 4;
                        rbMask |= 1;
                    } else if (tile.dr === 2) {
                        rtMask |= 32;
                        rbMask |= 8;
                    }
                }

                if (y > 0) {
                    tile.b = tilepoints[y - 1][x];
                    tile.db = tile.layerHeight - tile.b.layerHeight;

                    if (tile.db === 1) {
                        lbMask |= 1;
                        rbMask |= 4;
                    } else if (tile.db === 2) {
                        lbMask |= 8;
                        rbMask |= 32;
                    }
                }

                if (y < mapSize[1] - 1) {
                    tile.t = tilepoints[y + 1][x];
                    tile.dt = tile.layerHeight - tile.t.layerHeight;

                    if (tile.dt === 1) {
                        ltMask |= 4;
                        rtMask |= 1;
                    } else if (tile.dt === 2) {
                        ltMask |= 32;
                        rtMask |= 8;
                    }
                }

                if (x > 0 && y > 0) {
                    tile.lb = tilepoints[y - 1][x - 1];
                    tile.dlb = tile.layerHeight - tile.lb.layerHeight;

                    if (tile.dlb === 1) {
                        lbMask |= 2;
                    } else if (tile.dlb === 2) {
                        lbMask |= 16;
                    }
                }

                if (x < mapSize[0] - 1 && y > 0) {
                    tile.rb = tilepoints[y - 1][x + 1];
                    tile.drb = tile.layerHeight - tile.rb.layerHeight;

                    if (tile.drb === 1) {
                        rbMask |= 2;
                    } else if (tile.drb === 2) {
                        rbMask |= 16;
                    }
                }

                if (x> 0 && y < mapSize[1] - 1) {
                    tile.lt = tilepoints[y + 1][x - 1];
                    tile.dlt = tile.layerHeight - tile.lt.layerHeight;

                    if (tile.dlt === 1) {
                        ltMask |= 2;
                    } else if (tile.dlt === 2) {
                        ltMask |= 16;
                    }
                }

                if (x < mapSize[0] - 1 && y < mapSize[1] - 1) {
                    tile.rt = tilepoints[y + 1][x + 1];
                    tile.drt = tile.layerHeight - tile.rt.layerHeight;

                    if (tile.drt === 1) {
                        rtMask |= 2;
                    } else if (tile.drt === 2) {
                        rtMask |= 16;
                    }
                }

                // TODO: Do I need to check all 8 surrounding tiles, or are the straight ones enough?
                let locX = (x - centerOffset[0]) * 128,
                    locY = (y - centerOffset[1]) * 128,
                    locZ = tile.getCliffHeight(Math.max(tile.dl, tile.dr, tile.dt, tile.db)) * 128;

                tile.x = locX;
                tile.y = locY;
                tile.z = locZ;

                if ((lbMask | ltMask | rtMask | rbMask) > 0) {
                    tile.cliff = true;
                    tile.lbMask = lbMask;
                    tile.ltMask = ltMask;
                    tile.rtMask = rtMask;
                    tile.rbMask = rbMask;
                }
            }
        }
    },

    update() {
        if (this.water) {
            this.BLAAA += 1;

            if (this.BLAAA === 4) {
                this.BLAAA = 0;
                this.waterCounter += 1;

            }
            

            if (this.waterCounter === 44) {
                this.waterCounter = 0;
            }

            let x = this.waterCounter % 8,
                y = Math.floor(this.waterCounter / 8),
                uvOffset = this.water.model.uvOffset;

            uvOffset[0] = x / 8;
            uvOffset[1] = y / 8;
        }
    },

    loadWater() {
        var mapSize = this.mapSize;
        var tilepoints = this.tilepoints;
        var centerOffset = this.offset;
        
        let vertices = [],
            uvs = [],
            edges = [],
            faces = [],
            base = 0;

        for (var y = 0; y < mapSize[1] - 1; y++) {
            for (var x = 0; x < mapSize[0] - 1; x++) {
                var tile1 = tilepoints[y][x],
                    tile2 = tilepoints[y + 1][x],
                    tile3 = tilepoints[y + 1][x + 1],
                    tile4 = tilepoints[y][x + 1];


                if ((tile1.water || tile2.water || tile3.water || tile4.water)) {
                    //let z = Math.min(tile1.getWaterHeight(), tile2.getWaterHeight(), tile3.getWaterHeight(), tile4.getWaterHeight()) + 0.25;
                    let z = ((tile1.waterLevel - 0x2000) / 4 - 89.6) / 128;

                    faces.push(base, base + 1, base + 2, base, base + 2, base + 3);
                    edges.push(base, base + 1, base + 1, base + 2, base + 2, base + 3, base + 3, base);
                    vertices.push(x, y, z, x, y + 1, z, x + 1, y + 1, z, x + 1, y, z);
                    uvs.push(0, 0, 0, 1, 1, 1, 1, 0);

                    base += 4;
                }
            }
        }

        let textures = [],
            n;

        for (let i = 0; i < 45; i++) {
            n = (i < 10) ? "0" + i : "" + i;

            textures[i] = this.loadFiles("Textures/Water" + n + "-0.blp");
        }

        this.env.whenAllLoaded(textures, _ => {
            var images = [];

            for (var i = 0, l = textures.length; i < l; i++) {
                images[i] = textures[i].imageData;
            }

            var atlasData = createTextureAtlas(images);

            var texture = this.env.load(atlasData.texture);

            var gl = this.env.gl;
            gl.bindTexture(gl.TEXTURE_2D, texture.webglResource);
            texture.setParameters(gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.LINEAR, gl.LINEAR);

            var model = this.env.load({
                geometry: { vertices: new Float32Array(vertices), uvs: new Float32Array(uvs), faces: new Uint16Array(faces), edges: new Float32Array(edges) },
                material: { renderMode: 0, twoSided: true, alpha: 0.5, texture: texture, isBGR: true, isBlended: true }
            }, src =>[src, ".geo", false]);
            var instance = model.addInstance();
            instance.setUniformScale(128).setLocation([-centerOffset[0] * 128, -centerOffset[1] * 128, 0]);
            instance.noCulling = true;

            this.water = instance;

            model.uvScale[0] = model.uvScale[1] = 1 / 8;

            this.waterCounter = 0;
            this.BLAAA = 0;
        });
    },

    loadTerrainCliffs() {
        this.prepareTilePoints();

        var mapSize = this.mapSize;
        var tilepoints = this.tilepoints;

        var unitCube = this.env.load({
            geometry: createUnitCube(),
            material: { renderMode: 2, color: [1, 1, 1], twoSided: true }
        }, src =>[src, ".geo", false]);

        for (var y = 0; y < mapSize[1]; y++) {
            for (var x = 0; x < mapSize[0]; x++) {
                var tile = tilepoints[y][x];

                if (!tile.cliff) {
                    //unitCube.addInstance().setColor([1, 0, 0]).setLocation([tile.x, tile.y, tile.z + 128]).uniformScale(16);
                } else {
                    //unitCube.addInstance().setColor([0, 1, 0]).setLocation([tile.x, tile.y, tile.z + 128]).uniformScale(16);
                }

                if (x === 13 && y === 12) {
                    //unitCube.addInstance().setColor([0, 0, 1]).setLocation([tile.x, tile.y, tile.z]).uniformScale(32);
                    console.log(tile)
                }

                if (tile.cliff) {
                    let cliffVariation = 0;
                    let variation = tile.variation;
                    let cliffRow = this.cliffs[tile.cliffTextureType];
                    let model, instance;

                    let ltMask = tile.ltMask;
                    let rtMask = tile.rtMask;
                    let rbMask = tile.rbMask;
                    let lbMask = tile.lbMask;
                    let tag, supportedMask;

                    if (ltMask) {
                        supportedMask = true;

                        switch (ltMask) {
                            // Left wall
                            // 0 T
                            // 0 C
                            case 3:
                            case 24:
                                tag = this.heightsToCliffTag(0, 0, tile.dlt, tile.dlt);
                                break;

                                // ???
                                // T 0
                                // T C
                            case 4:
                                tag = this.heightsToCliffTag(1, 1, 0, 1);
                                break;

                                // Diagonal connection
                                // T 0
                                // 0 C
                            case 5:
                                tag = this.heightsToCliffTag(0, 1, 0, 1);
                                break;

                            // T T
                            // 0 C
                            case 8:
                                tag = this.heightsToCliffTag(0, 2, 2, 2);
                                break;

                                // Left-top corner
                                // 0 0
                                // 0 C
                            case 7: // Low
                            case 56: // High
                                tag = this.heightsToCliffTag(0, 0, 0, tile.dlt);
                                break;

                            // 1 0
                            // 1 C
                            case 32:
                                tag = this.heightsToCliffTag(2, 2, 0, 2);
                                break;

                            default:
                                supportedMask = false;
                        }

                        if (supportedMask) {
                            model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + tag + cliffVariation + ".mdx");
                            instance = model.addInstance().setLocation([tile.x, tile.y, tile.z]);
                        }
                    }

                    if (rtMask) {
                        supportedMask = true;

                        switch (rtMask) {
                            // ???
                            // 0 T
                            // C T
                            case 1:
                                tag = this.heightsToCliffTag(1, 0, 1, 1);
                                break;

                                // Top wall
                                // 0 0
                                // C T
                            case 3:
                            case 24:
                                tag = this.heightsToCliffTag(tile.drt, 0, 0, tile.drt);
                                break;

                            // 0 T
                            // C T
                            case 8:
                                tag = this.heightsToCliffTag(2, 0, 2, 2);
                                break;

                                // Diagonal connection
                                // 0 T
                                // C 0
                            case 5:
                                tag = this.heightsToCliffTag(1, 0, 1, 0);
                                break;

                            case 40:
                                tag = this.heightsToCliffTag(2, 0, 2, 0);
                                break;

                                // Diagonal 2 to 1
                            case 42:
                                tag = this.heightsToCliffTag(2, 0, 1, 0);
                                break;

                                // Right-top corner
                                // 0 0
                                // 0 C
                            case 7:
                            case 56:
                                tag = this.heightsToCliffTag(tile.drt, 0, 0, 0);
                                break;

                                // Right wall
                                // T 0
                                // C 0
                            case 6:
                                tag = this.heightsToCliffTag(1, 1, 0, 0);
                                break;

                            // Right wall high
                            // T 0
                            // C 0
                            case 48:
                                tag = this.heightsToCliffTag(2, 2, 0, 0);
                                break;

                            default:
                                supportedMask = false;
                        }

                        if (supportedMask) {
                            model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + tag + cliffVariation + ".mdx");
                            instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);
                        }
                    }

                    if (rbMask) {
                        supportedMask = true;

                        switch (rbMask) {
                            // ???
                            // C T
                            // 0 T
                            case 4:
                                tag = this.heightsToCliffTag(0, 1, 1, 1);
                                break;

                            // Right-bottom corner
                            // C 0
                            // 0 0
                            case 7:
                            case 56:
                                tag = this.heightsToCliffTag(0, tile.drb, 0, 0);
                                break;

                            // High - Low ???
                            case 28:
                                tag = this.heightsToCliffTag(0, 2, 0, 1);
                                break;

                            default:
                                supportedMask = false;
                        }

                        if (supportedMask) {
                            model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + tag + cliffVariation + ".mdx");
                            instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);
                        }
                    }

                    if (lbMask) {
                        supportedMask = true;

                        switch (lbMask) {
                            // ???
                            // T C
                            // T 0
                            case 1:
                                tag = this.heightsToCliffTag(1, 1, 1, 0);
                                break;

                            // ??? high
                            // T C
                            // T 0
                            case 8:
                                tag = this.heightsToCliffTag(2, 2, 2, 0);
                                break;

                                // Bottom-wall
                                // T C
                                // 0 0
                            case 3:
                                tag = this.heightsToCliffTag(0, 1, 1, 0);
                                break;

                                // Bottom-wall high
                            case 24:
                                tag = this.heightsToCliffTag(0, 2, 2, 0);
                                break;


                                // Left-bottom corner
                                // 0 C
                                // 0 0
                            case 7:
                            case 56:
                                tag = this.heightsToCliffTag(0, 0, tile.dlb, 0);
                                break;

                            // Some diagonal...
                            case 40:
                                tag = this.heightsToCliffTag(2, 0, 2, 0);
                                break;

                            // High - Low ???
                            case 49:
                                tag = this.heightsToCliffTag(0, 0, 2, 1);
                                break;

                            default:
                                supportedMask = false;
                        }

                        if (supportedMask) {
                            model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + tag + cliffVariation + ".mdx");
                            instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);
                        }
                    }

                  
                    
                    /*
                    if (tile.mask === CLIFF_TYPE_SINGLE_CLIFF) {
                        // Right top
                        tag = this.heightsToCliffTag(1, 0, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);

                        // Right bottom
                        tag = this.heightsToCliffTag(0, 1, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);

                        // Left bottom
                        tag = this.heightsToCliffTag(0, 0, 1, 0);
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);

                        // Left top
                        tag = this.heightsToCliffTag(0, 0, 0, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y, tile.z])
                    } else if (tile.mask === CLIFF_TYPE_LEFT) {
                        // Right top
                        tag = this.heightsToCliffTag(1, 0, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);

                        // Right bottom
                        tag = this.heightsToCliffTag(0, 1, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);

                        // Left bottom
                        tag = this.heightsToCliffTag(0, 1, 1, 0);
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);

                        // Left top
                        tag = this.heightsToCliffTag(1, 0, 0, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y, tile.z])
                    } else if (tile.mask === CLIFF_TYPE_RIGHT) {
                        // Right top
                        tag = this.heightsToCliffTag(1, 0, 0, 1);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);

                        // Right bottom
                        tag = this.heightsToCliffTag(0, 1, 1, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);

                        // Left bottom
                        tag = this.heightsToCliffTag(0, 0, 1, 0);
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);

                        // Left top
                        tag = this.heightsToCliffTag(0, 0, 0, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y, tile.z])
                    } else if (tile.mask === CLIFF_TYPE_BOTTOM) {
                        // Right top
                        tag = this.heightsToCliffTag(1, 0, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);

                        // Right bottom
                        tag = this.heightsToCliffTag(1, 1, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);

                        // Left bottom
                        tag = this.heightsToCliffTag(0, 0, 1, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);

                        // Left top
                        tag = this.heightsToCliffTag(0, 0, 0, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y, tile.z])
                    } else if (tile.mask === CLIFF_TYPE_TOP) {
                        // Right top
                        tag = this.heightsToCliffTag(1, 1, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);

                        // Right bottom
                        tag = this.heightsToCliffTag(0, 1, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);

                        // Left bottom
                        tag = this.heightsToCliffTag(0, 0, 1, 0);
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);

                        // Left top
                        tag = this.heightsToCliffTag(0, 0, 1, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y, tile.z])
                    } else if (tile.mask === CLIFF_TYPE_LEFT_BOTTOM_CORNER) {
                        // Left top
                        tag = this.heightsToCliffTag(0, 0, 1, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y, tile.z])

                        // Left bottom
                        tag = this.heightsToCliffTag(0, 0, 1, 0);
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);

                        // Right bottom
                        tag = this.heightsToCliffTag(0, 1, 1, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);
                    } else if (tile.mask === CLIFF_TYPE_RIGHT_BOTTOM_CORNER) {
                        // Left bottom
                        tag = this.heightsToCliffTag(0, 0, 1, 0);
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);

                        // Right bottom
                        tag = this.heightsToCliffTag(0, 1, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);

                        // Right top
                        tag = this.heightsToCliffTag(1, 1, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);
                    } else if (tile.mask === CLIFF_TYPE_LEFT_TOP_CORNER) {
                        // Left bottom
                        tag = this.heightsToCliffTag(0, 0, 1, 0);
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);

                        // Left top
                        tag = this.heightsToCliffTag(0, 0, 0, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y, tile.z])

                        // Right top
                        tag = this.heightsToCliffTag(1, 0, 0, 1);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);
                    } else if (tile.mask === CLIFF_TYPE_RIGHT_TOP_CORNER) {
                        // Left top
                        tag = this.heightsToCliffTag(0, 0, 0, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y, tile.z])

                        // Right top
                        tag = this.heightsToCliffTag(1, 0, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);

                        // Right bottom
                        tag = this.heightsToCliffTag(0, 1, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);
                    } else if (tile.mask === CLIFF_TYPE_BOTTOM_WALL) {
                        tag = this.heightsToCliffTag(0, 1, 1, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);

                        tag = this.heightsToCliffTag(0, 1, 1, 0);
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);
                    } else if (tile.mask === CLIFF_TYPE_LEFT_WALL) {
                        tag = this.heightsToCliffTag(0, 0, 1, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);

                        tag = this.heightsToCliffTag(0, 0, 1, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y, tile.z]);
                    } else if (tile.mask === CLIFF_TYPE_RIGHT_WALL) {
                        tag = this.heightsToCliffTag(1, 1, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);

                        tag = this.heightsToCliffTag(1, 1, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);
                    } else if (tile.mask === CLIFF_TYPE_TOP_WALL) {
                        tag = this.heightsToCliffTag(1, 0, 0, 1);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);

                        tag = this.heightsToCliffTag(1, 0, 0, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y, tile.z]);
                    } else {
                        //if (tile.mask === 51) {
                            //unitCube.addInstance().setColor([0, 0, 1]).setLocation([tile.x, tile.y, tile.z]).uniformScale(32);
                            ///zAxisModel.addInstance().setLocation([tile.x, tile.y, tile.z]).uniformScale(40);
                       // }

                        unitCube.addInstance().setColor([0, 1, 0]).setLocation([tile.x, tile.y, tile.z]).uniformScale(32);

                        //console.warn("Unhandled cliff mask", tile.mask)
                    }
                    */







                    // Right top
                    /*
                    if (R > 0 && T > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(cliffHeight, 0, 0, 0) + "0.mdx");
                        instance = model.addInstance().setLocation([locX + 128, locY, locZ]);
                    } else if (T > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(cliffHeight, 0, 0, T) + "0.mdx");
                        instance = model.addInstance().setLocation([locX + 128, locY, locZ]);
                    } else if (R > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(cliffHeight, R, 0, 0) + "0.mdx");
                        instance = model.addInstance().setLocation([locX + 128, locY, locZ]);
                    }
                    */

                    // Right bottom
                    /*
                    if (R > 0 && B > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(0, cliffHeight, 0, 0) + "0.mdx");
                        instance = model.addInstance().setLocation([locX + 128, locY - 128, locZ]);
                    } else if (B > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(0, cliffHeight, B, 0) + "0.mdx");
                        instance = model.addInstance().setLocation([locX + 128, locY - 128, locZ]);
                    } else if (R > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(R, cliffHeight, 0, 0) + "0.mdx");
                        instance = model.addInstance().setLocation([locX + 128, locY - 128, locZ]);
                    }

                    // Left bottom
                    if (L > 0 && B > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(0, 0, cliffHeight, 0) + "0.mdx");
                        instance = model.addInstance().setLocation([locX, locY - 128, locZ]);
                    } else if (B > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(0, B, cliffHeight, 0) + "0.mdx");
                        instance = model.addInstance().setLocation([locX, locY - 128, locZ]);
                    } else if (L > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(0, 0, cliffHeight, L) + "0.mdx");
                        instance = model.addInstance().setLocation([locX, locY - 128, locZ]);
                    }

                    // Left top
                    if (L > 0 && T > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(0, 0, 0, cliffHeight) + "0.mdx");
                        instance = model.addInstance().setLocation([locX, locY, locZ]);
                    } else if (T > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(T, 0, 0, cliffHeight) + "0.mdx");
                        instance = model.addInstance().setLocation([locX, locY, locZ]);
                    } else if (L > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(0, 0, L, cliffHeight) + "0.mdx");
                        instance = model.addInstance().setLocation([locX, locY, locZ]);
                    }
                    */

                    /*
                    // Left wall
                    if (tile.top.cliff && tile.bottom.cliff && tile.left.layerHeight !== tile.layerHeight) {
                        tag = this.heightsToCliffTag(0, 0, 1, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);

                        tag = this.heightsToCliffTag(0, 0, 1, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y, tile.z]);
                    }

                    // Right wall
                    if (tile.top.cliff && tile.bottom.cliff && tile.right.layerHeight !== tile.layerHeight) {
                        tag = this.heightsToCliffTag(1, 1, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);

                        tag = this.heightsToCliffTag(1, 1, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);
                    }

                    // Top wall
                    if (tile.left.cliff && tile.right.cliff && tile.top.layerHeight !== tile.layerHeight) {
                        tag = this.heightsToCliffTag(1, 0, 0, 1);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);

                        tag = this.heightsToCliffTag(1, 0, 0, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y, tile.z]);
                    }

                    // Bottom wall
                    if (tile.left.cliff && tile.right.cliff && tile.bottom.layerHeight !== tile.layerHeight) {
                        tag = this.heightsToCliffTag(0, 1, 1, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);

                        tag = this.heightsToCliffTag(0, 1, 1, 0);
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);
                    }

                    // Left top corner
                    if (!tile.top.cliff && !tile.left.cliff) {
                        tag = this.heightsToCliffTag(0, 0, 0, 1);
                        instance = model.addInstance().setLocation([tile.x, tile.y, tile.z]);
                    }

                    // Right top corner
                    if (!tile.top.cliff && !tile.right.cliff) {
                        tag = this.heightsToCliffTag(1, 0, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);
                    }

                    // Right bottom corner
                    if (!tile.bottom.cliff && !tile.right.cliff) {
                        tag = this.heightsToCliffTag(0, 1, 0, 0);
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);
                    }

                    // Left bottom corner
                    if (!tile.bottom.cliff && !tile.left.cliff) {
                        tag = this.heightsToCliffTag(0, 0, 1, 0);
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);
                    }
                    */
                    /*
                    if (tile.dR > 0 && tile.dT > 0 && tile.right.cliff) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(tile.cliffHeight, 0, 0, 1) + "0.mdx");
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);
                    } else if (tile.dR > 0 && tile.dT > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(tile.cliffHeight, 0, 0, 0) + "0.mdx");
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y, tile.z]);
                    }

                    if (tile.dR > 0 && tile.dB > 0 && tile.right.cliff) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(0, tile.cliffHeight, 1, 0) + "0.mdx");
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);
                    } else if (tile.dR > 0 && tile.dB > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(0, tile.cliffHeight, 0, 0) + "0.mdx");
                        instance = model.addInstance().setLocation([tile.x + 128, tile.y - 128, tile.z]);
                    }

                    if (tile.left.cliff) {
                        console.log("ASD")
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(0, 1, tile.cliffHeight, 0) + "0.mdx");
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);
                    } else if (tile.dL > 0 && tile.dB > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(0, 0, tile.cliffHeight, 0) + "0.mdx");
                        instance = model.addInstance().setLocation([tile.x, tile.y - 128, tile.z]);
                    }

                    if (tile.dL > 0 && tile.dT > 0) {
                        model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(0, 0, 0, tile.cliffHeight) + "0.mdx");
                        instance = model.addInstance().setLocation([tile.x, tile.y, tile.z]);
                    }
                    */

                    //model = this.loadFiles("Doodads/Terrain/Cliffs/Cliffs" + this.heightsToCliffTag(0, 0, R, L) + "0.mdx");
                    //instance = model.addInstance().setLocation([locX, locY, locZ]);
                }
            }
        }
    },

    getTileVariation(variation, isExtended) {
        if (isExtended) {
            switch (variation) {
                case 0: return [4, 0]
                case 1: return [5, 0]
                case 2: return [6, 0]
                case 3: return [7, 0]
                case 4: return [4, 1]
                case 5: return [5, 1]
                case 6: return [6, 1]
                case 7: return [7, 1]
                case 8: return [4, 2]
                case 9: return [5, 2]
                case 10: return [6, 2]
                case 11: return [7, 2]
                case 12: return [4, 3]
                case 13: return [5, 3]
                case 14: return [6, 3]
                case 15: return [7, 3]
                case 16: return [3, 3]
                case 17: return [0, 0]
                default: /*console.log("Unknown tile variation " + variation);*/ return [0, 0]
            }
        } else {
            if (variation === 1) {
                return [3, 3];
            } else {
                return [0, 0];
            }
        }
    },

    loadTerrainGeometry() {
        var tilesetTextures = this.tilesetTextures;
        var mapSize = this.mapSize;
        var tilepoints = this.tilepoints;
        var centerOffset = this.offset;

        var vertices = {};
        var uvs = {};
        var faces = {};
        var edges = {};
        
        var blightTextureIndex = this.blightTextureIndex;

        for (var y = 0; y < mapSize[1] - 1; y++) {
            for (var x = 0; x < mapSize[0] - 1; x++) {
                var tile1 = tilepoints[y][x],
                    tile2 = tilepoints[y + 1][x],
                    tile3 = tilepoints[y + 1][x + 1],
                    tile4 = tilepoints[y][x + 1],
                    texture1 = tile1.blight ? blightTextureIndex : tile1.groundTextureType,
                    texture2 = tile2.blight ? blightTextureIndex : tile2.groundTextureType,
                    texture3 = tile3.blight ? blightTextureIndex : tile3.groundTextureType,
                    texture4 = tile4.blight ? blightTextureIndex : tile4.groundTextureType;

                var textures = [texture1, texture2, texture3, texture4].unique();

                for (var texture = 0; texture < textures.length; texture++) {
                    var t = textures[texture];

                    if (!vertices[t]) {
                        vertices[t] = [];
                        uvs[t] = [];
                        faces[t] = [];
                        edges[t] = [];
                    }

                    var base = vertices[t].length / 3;

                    faces[t].push(base, base + 1, base + 2, base, base + 2, base + 3);
                    edges[t].push(base, base + 1, base + 1, base + 2, base + 2, base + 3, base + 3, base);
                    vertices[t].push(x, y, tile1.getHeight(), x, y + 1, tile2.getHeight(), x + 1, y + 1, tile3.getHeight(), x + 1, y, tile4.getHeight());

                    var extended = (tilesetTextures[t].width === 512);
                    var width = extended ? 1 / 8 : 1 / 4;
                    var height = 1 / 4;
                    var offsetX = 0;
                    var offsetY = 0;

                    // The following set of conditions picks which tile this is, by checking the textures used by the four tilepoints

                    // 1 1
                    // 1 1
                    if (t === texture1 && t === texture2 && t === texture3 && t === texture4) {
                        let variation = this.getTileVariation(tile1.variation, extended)
                        
                        offsetX = variation[0];
                        offsetY = variation[1];
                    // 1 1
                    // 1 0
                    } else if (t === texture1 && t === texture2 && t === texture3) {
                        if (t > texture4) {
                            offsetX = 2;
                            offsetY = 3;
                        }
                    // 1 1
                    // 0 1
                    } else if (t === texture2 && t === texture3 && t === texture4) {
                        if (t > texture1) {
                            offsetX = 1;
                            offsetY = 3;
                        }
                    // 0 1
                    // 1 1
                    } else if (t === texture3 && t === texture4 && t === texture1) {
                        if (t > texture2) {
                            offsetX = 3;
                            offsetY = 1;
                        }
                    // 1 0
                    // 1 1
                    } else if (t === texture4 && t === texture1 && t === texture2) {
                        if (t > texture3) {
                            offsetX = 3;
                            offsetY = 2;
                        }
                    // 1 0
                    // 1 0
                    } else if (t === texture1 && t === texture2) {
                        if (t > texture3 || t > texture4) {
                            offsetX = 2;
                            offsetY = 2;
                        }
                    // 1 1
                    // 0 0
                    } else if (t === texture2 && t === texture3) {
                        if (t > texture1 || t > texture4) {
                            offsetX = 0;
                            offsetY = 3;
                        }
                    // 0 1
                    // 0 1
                    } else if (t === texture3 && t === texture4) {
                        if (t > texture1 || t > texture2) {
                            offsetX = 1;
                            offsetY = 1;
                        }
                    // 0 0
                    // 1 1
                    } else if (t === texture4 && t === texture1) {
                        if (t > texture2 || t > texture3) {
                            offsetX = 3;
                            offsetY = 0;
                        }
                    // 0 1
                    // 1 0
                    } else if (t === texture1 && t === texture3) {
                        if (t > texture2 || t > texture4) {
                            offsetX = 2;
                            offsetY = 1;
                        }
                    // 1 0
                    // 0 1
                    } else if (t === texture2 && t === texture4) {
                        if (t > texture1 || t > texture3) {
                            offsetX = 1;
                            offsetY = 2;
                        }
                    // 0 0
                    // 1 0
                    } else if (t === texture1) {
                        if (t > texture2 || t > texture3 || t > texture4) {
                            offsetX = 2;
                            offsetY = 0;
                        }
                    // 1 0
                    // 0 0
                    } else if (t === texture2) {
                        if (t > texture1 || t > texture3 || t > texture4) {
                            offsetX = 0;
                            offsetY = 2;
                        }
                    // 0 1
                    // 0 0
                    } else if (t === texture3) {
                        if (t > texture1 || t > texture2 || t > texture4) {
                            offsetX = 0;
                            offsetY = 1;
                        }
                    // 0 0
                    // 0 1
                    } else if (t === texture4) {
                        if (t > texture1 || t > texture2 || t > texture3) {
                            offsetX = 1;
                            offsetY = 0;
                        }
                    }

                    offsetX *= width;
                    offsetY *= height;

                    // pixel correction, to avoid bleeding
                    var pixelSizeX = 1 / tilesetTextures[t].width;
                    var pixelSizeY = 1 / tilesetTextures[t].height;
                    offsetX += pixelSizeX;
                    offsetY += pixelSizeY;
                    width -= 2 * pixelSizeX;
                    height -= 2 * pixelSizeY;

                    uvs[t].push(offsetX, offsetY + height, offsetX, offsetY, offsetX + width, offsetY, offsetX + width, offsetY + height);
                }
            }
        }

        for (var i = 0, l = tilesetTextures.length; i < l; i++) {
            if (vertices[i]) {
                var v = new Float32Array(vertices[i]),
                    u = new Float32Array(uvs[i]),
                    f = new Uint32Array(faces[i]),
                    e = new Float32Array(edges[i]),
                    t = tilesetTextures[i];

                var terrainModel = this.env.load({
                    geometry: { vertices: v, uvs: u, faces: f, edges: e },
                    material: { renderMode: 2, twoSided: true, texture: t, isBGR: true, isBlended: true }
                }, src =>[src, ".geo", false]);
                var instance = terrainModel.addInstance();
                instance.setUniformScale(128).setLocation([-centerOffset[0] * 128, -centerOffset[1] * 128, 0]);
                instance.noCulling = true;
            }
        }
    },

    loadModifications() {
        // useOptionalInts:
        //      w3u: no (units)
        //      w3t: no (items)
        //      w3b: no (destructables)
        //      w3d: yes (doodads)
        //      w3a: yes (abilities)
        //      w3h: no (buffs)
        //      w3q: yes (upgrades)

        var slkFiles = this.slkFiles;

        this.loadModificationFile("b", false, slkFiles.destructabledata, slkFiles.destructablemetadata);
        this.loadModificationFile("d", true, slkFiles.doodads, slkFiles.doodadmetadata);
        this.loadModificationFile("u", false, slkFiles.unitdata, slkFiles.unitmetadata);
    },

    loadModificationFile(file, useOptionalInts, dataTable, metadataTable) {
        var file = this.mpq.getFile("war3map.w3" + file);

        if (file) {
            var reader = new BinaryReader(file.buffer);

            var version = readInt32(reader);

            // Modifications to built-in objects
            var originalTable = new W3xModificationTable(reader, useOptionalInts);
            this.applyModificationTable(originalTable, dataTable, metadataTable);

            // Declarations of user-defined objects
            var customTable = new W3xModificationTable(reader, useOptionalInts);
            this.applyModificationTable(customTable, dataTable, metadataTable);
        }
    },

    applyModificationTable(modificationTable, dataTable, metadataTable) {
        var modifications = modificationTable.objects;

        for (var i = 0, l = modifications.length; i < l; i++) {
            this.applyModificationObject(modifications[i], dataTable, metadataTable);
        }
    },

    applyModificationObject(modification, dataTable, metadataTable) {
        var row;

        if (modification.newID !== "") {
            if (dataTable.map[modification.oldID]) {
                row = dataTable.map[modification.newID] = Object.copy(dataTable.map[modification.oldID]);
                row.ID = modification.newID;
            }
        } else {
            row = dataTable.map[modification.oldID];
        }

        var modifications = modification.modifications

        if (row) {
            for (var i = 0, l = modifications.length; i < l; i++) {
                this.applyModification(modifications[i], row, metadataTable);
            }
        } else {
            console.warn("[W3xMap:applyModificationObject] Undefined row for modification", modification);
        }
    },

    applyModification(modification, row, metadataTable) {
        var metadata = metadataTable.map[modification.id];

        if (metadata) {
            row[metadata.field] = modification.value;
        } else {
            console.warn("Unknown modification ID", modification.id);
        }
    }
};

mix(W3xMap.prototype, GenericFile.prototype);
const W3x = {
    initialize(env) {
        env.addHandler(Mpq);
        env.addHandler(Mdx);
        env.addHandler(Geo);

        return true;
    },

    get extension() {
        return ".w3x|.w3m";
    },

    get Constructor() {
        return W3xMap;
    },

    get binaryFormat() {
        return true;
    }
};

mix(W3x, FileHandler);
const MdxShaders = {
    "vs_main": `
        uniform mat4 u_mvp;
        uniform vec2 u_uvScale;
        uniform vec3 u_teamColors[14];
        uniform bool u_isTextureAnim;

        attribute vec3 a_position;
        attribute vec3 a_normal;
        attribute vec2 a_uv;
        attribute vec4 a_bones;
        attribute float a_boneNumber;
        attribute float a_teamColor;
        attribute vec3 a_tintColor;
        attribute float a_InstanceID;
        attribute float a_batchVisible;
        attribute vec4 a_geosetColor;
        attribute vec4 a_uvOffset;

        varying vec3 v_normal;
        varying vec2 v_uv;
        varying vec3 v_teamColor;
        varying vec3 v_tintColor;
        varying vec4 v_geosetColor;

        void transform(inout vec3 position, inout vec3 normal, float boneNumber, vec4 bones) {
            mat4 m;

            m += boneAtIndex(bones[0], a_InstanceID);
            m += boneAtIndex(bones[1], a_InstanceID);
            m += boneAtIndex(bones[2], a_InstanceID);
            m += boneAtIndex(bones[3], a_InstanceID);

            position = vec3(m * vec4(position, 1)) / boneNumber;
            normal = normalize(mat3(m) * normal);
        }

        void main() {
            vec2 uv = a_uv;
            vec3 position = a_position,
                 normal = a_normal;
            
            transform(position, normal, a_boneNumber, a_bones);

            if (u_isTextureAnim) {
                v_uv = (fract(a_uv +a_uvOffset.xy) +a_uvOffset.zw) * u_uvScale;
            } else {
                v_uv = a_uv;
            }

            v_normal = normal;
	        v_teamColor = u_teamColors[int(a_teamColor)];
	        v_tintColor = a_tintColor;
	        v_geosetColor = a_geosetColor;

	        if (a_batchVisible == 0.0) {
		        gl_Position = vec4(0.0);
            } else {
		        gl_Position = u_mvp * vec4(position, 1);
            }
        }
    `,

    "ps_main": `
        uniform sampler2D u_texture;
        uniform bool u_alphaTest;
        uniform vec4 u_modifier;
        uniform float u_colorMode;

        varying vec3 v_normal;
        varying vec2 v_uv;
        varying vec3 v_teamColor;
        varying vec3 v_tintColor;
        varying vec4 v_geosetColor;

        void main() {
            #ifdef STANDARD_PASS
	        vec4 texel;

	        if (u_colorMode == 1.0) {
		        texel = vec4(v_teamColor, 1.0);
            } else if (u_colorMode == 2.0) {
		        // Change the coordinate from [0, 1] to [-1, 1]
		        vec2 coord = (v_uv -0.5) * 2.0;

		        // Distance of the coordinate from the center
		        float dist = sqrt(dot(coord, coord));

		        // An estimation of the equation that created the team glow textures used by Warcraft 3
		        float factor = max(0.55 -dist, 0.0);

		        texel = vec4(factor * v_teamColor, 1.0);
            } else {
		        texel = texture2D(u_texture, v_uv).bgra;
            }

            // 1bit Alpha
            if (u_alphaTest && texel.a < 0.75) {
                discard;
            }

	        gl_FragColor = texel * v_geosetColor.bgra * vec4(v_tintColor, 1.0);
            #endif

            #ifdef UVS_PASS
            gl_FragColor = vec4(v_uv, 0.0, 1.0);
            #endif

            #ifdef NORMALS_PASS
            gl_FragColor = vec4(v_normal, 1.0);
            #endif

            #ifdef WHITE_PASS
            gl_FragColor = vec4(1.0);
            #endif
        }
    `,

    "vs_particles": `
        uniform mat4 u_mvp;
        uniform vec2 u_dimensions;

        attribute vec3 a_position;
        attribute vec2 a_uva_rgb;

        varying vec2 v_uv;
        varying vec4 v_color;

        void main() {
            vec3 uva = decodeFloat3(a_uva_rgb[0]);
            vec3 rgb = decodeFloat3(a_uva_rgb[1]);

            v_uv = uva.xy / u_dimensions;
            v_color = vec4(rgb, uva.z) / 255.0;

            gl_Position = u_mvp * vec4(a_position, 1);
        }
    `,

    "ps_particles": `
        uniform sampler2D u_texture;

        varying vec2 v_uv;
        varying vec4 v_color;

        void main() {
            gl_FragColor = texture2D(u_texture, v_uv).bgra * v_color;
        }
    `,

    "vs_ribbons": `
        uniform mat4 u_mvp;
        uniform vec3 u_uv_offset;

        attribute vec3 a_position;
        attribute vec2 a_uv;

        varying vec2 v_uv;

        void main() {
            v_uv = a_uv + u_uv_offset.xy;

            gl_Position = u_mvp * vec4(a_position, 1.0);
        }
    `
};
let MdxParser = (function () {
    // Mapping from track tags to their type and default value
    var tagToTrack = {
        // LAYS
        KMTF: [readUint32, 0, 0],
        KMTA: [readFloat32, 1, 1],
        // TXAN
        KTAT: [readVector3, new Float32Array([0, 0, 0]), 2],
        KTAR: [readVector4, new Float32Array([0, 0, 0, 1]), 3],
        KTAS: [readVector3, new Float32Array([1, 1, 1]), 4],
        // GEOA
        KGAO: [readFloat32, 1, 5],
        KGAC: [readVector3, new Float32Array([0, 0, 0]), 6],
        // LITE
        KLAS: [readFloat32, 0, 7],
        KLAE: [readFloat32, 0, 8],
        KLAC: [readVector3, new Float32Array([0, 0, 0]), 9],
        KLAI: [readFloat32, 0, 10],
        KLBI: [readFloat32, 0, 11],
        KLBC: [readVector3, new Float32Array([0, 0, 0]), 12],
        KLAV: [readFloat32, 1, 13],
        // ATCH
        KATV: [readFloat32, 1, 14],
        // PREM
        KPEE: [readFloat32, 0, 15],
        KPEG: [readFloat32, 0, 16],
        KPLN: [readFloat32, 0, 17],
        KPLT: [readFloat32, 0, 18],
        KPEL: [readFloat32, 0, 19],
        KPES: [readFloat32, 0, 20],
        KPEV: [readFloat32, 1, 21],
        // PRE2
        KP2S: [readFloat32, 0, 22],
        KP2R: [readFloat32, 0, 23],
        KP2L: [readFloat32, 0, 24],
        KP2G: [readFloat32, 0, 25],
        KP2E: [readFloat32, 0, 26],
        KP2N: [readFloat32, 0, 27],
        KP2W: [readFloat32, 0, 28],
        KP2V: [readFloat32, 1, 29],
        // RIBB
        KRHA: [readFloat32, 0, 30],
        KRHB: [readFloat32, 0, 31],
        KRAL: [readFloat32, 1, 32],
        KRCO: [readVector3, new Float32Array([0, 0, 0]), 33],
        KRTX: [readUint32, 0, 34],
        KRVS: [readFloat32, 1, 35],
        // CAMS
        KCTR: [readVector3, new Float32Array([0, 0, 0]), 36],
        KTTR: [readVector3, new Float32Array([0, 0, 0]), 37],
        KCRL: [readUint32, 0, 38],
        // NODE
        KGTR: [readVector3, new Float32Array([0, 0, 0]), 39],
        KGRT: [readVector4, new Float32Array([0, 0, 0, 1]), 40],
        KGSC: [readVector3, new Float32Array([1, 1, 1]), 41]
    };

    // Read elements with unknown sizes
    function readUnknownElements(reader, size, Func, nodes) {
        var totalSize = 0,
            elements = [],
            element;
        
        while (totalSize !== size) {
            element = new Func(reader, nodes, elements.length);

            totalSize += element.size;

            elements.push(element);
        }

        return elements;
    }

    // Read elements with known sizes
    function readKnownElements(reader, count, Func) {
        var elements = [];

        for (var i = 0; i < count; i++) {
            elements[i] = new Func(reader, i);
        }

        return elements;
    }

    // Read a node, and also push it to the nodes array
    function readNode(reader, nodes, object) {
        var node = new Node(reader, nodes.length, object);

        nodes.push(node);

        return node;
    }

    function Extent(reader) {
        this.radius = readFloat32(reader);
        this.min = readVector3(reader);
        this.max = readVector3(reader);
    }

    function SDTrack(reader, interpolationType, Func) {
        this.frame = readInt32(reader);
        this.value = Func(reader);

        if (interpolationType > 1) {
            this.inTan = Func(reader);
            this.outTan = Func(reader);
        }
    }

    function SD(reader) {
        this.tag = read(reader, 4);

        var tracks = readUint32(reader);

        this.interpolationType = readUint32(reader);
        this.globalSequenceId = readInt32(reader);
        this.tracks = [];

        var sdTrackInfo = tagToTrack[this.tag];

        for (var i = 0; i < tracks; i++) {
            this.tracks[i] = new SDTrack(reader, this.interpolationType, sdTrackInfo[0])
        }

        this.defval = sdTrackInfo[1];
        this.sdIndex = sdTrackInfo[2];

        var elementsPerTrack = 1 + (typeof this.defval === "number" ? 1 : this.defval.length) * (this.interpolationType > 1 ? 3 : 1);

        this.size = 16 + tracks * elementsPerTrack * 4;
    }

    function SDContainer(reader, size) {
        this.sd = {};

        var sd = readUnknownElements(reader, size, SD);

        for (var i = 0, l = sd.length; i < l; i++) {
            this.sd[sd[i].tag] = sd[i];
        }
    }

    function Node(reader, index, object) {
        this.object = object;
        this.index = index;
        this.size = readUint32(reader);
        this.name = read(reader, 80);
        this.objectId = readUint32(reader);
        this.parentId = readInt32(reader);
        this.flags = readUint32(reader);
        this.tracks = new SDContainer(reader, this.size - 96);

        var flags = this.flags;

        this.dontInheritTranslation = flags & 1;
        this.dontInheritRotation = flags & 2;
        this.dontInheritScaling = flags & 4;
        this.billboarded = flags & 8;
        this.billboardedX = flags & 16;
        this.billboardedY = flags & 32;
        this.billboardedZ = flags & 64;
        this.cameraAnchored = flags & 128;
        this.bone = flags & 256;
        this.light = flags & 512;
        this.eventObject = flags & 1024;
        this.attachment = flags & 2048;
        this.particleEmitter = flags & 4096;
        this.collisionShape = flags & 8192;
        this.ribbonEmitter = flags & 16384;
        this.emitterUsesMdlOrUnshaded = flags & 32768;
        this.emitterUsesTgaOrSortPrimitivesFarZ = flags & 65536;
        this.lineEmitter = flags & 131072;
        this.unfogged = flags & 262144;
        this.modelSpace = flags & 524288;
        this.xYQuad = flags & 1048576;
    }

    function VersionChunk(reader, tag, size, nodes) {
        this.version = readUint32(reader);
    }

    function ModelChunk(reader, tag, size, nodes) {
        this.name = read(reader, 80);
        this.animationPath = read(reader, 260);
        this.extent = new Extent(reader);
        this.blendTime = readUint32(reader);
    }

    function Sequence(reader, index) {
        this.index = index;
        this.name = read(reader, 80);
        this.interval = readUint32Array(reader, 2);
        this.moveSpeed = readFloat32(reader);
        this.flags = readUint32(reader);
        this.rarity = readFloat32(reader);
        this.syncPoint = readUint32(reader);
        this.extent = new Extent(reader);
    }

    function GlobalSequence(reader, index) {
        this.index = index;
        this.value = readUint32(reader);
    }

    function Texture(reader, index) {
        this.index = index;
        this.replaceableId = readUint32(reader);
        this.path = read(reader, 260);
        this.flags = readUint32(reader);
    }
    
    function Layer(reader, index) {
        this.index = index;
        this.size = readUint32(reader);
        this.filterMode = readUint32(reader);
        this.flags = readUint32(reader);
        this.textureId = readUint32(reader);
        this.textureAnimationId = readInt32(reader);
        this.coordId = readUint32(reader);
        this.alpha = readFloat32(reader);
        this.tracks = new SDContainer(reader, this.size - 28);

        var flags = this.flags;

        this.unshaded = flags & 1;
        this.sphereEnvironmentMap = flags & 2;
        this.twoSided = flags & 16;
        this.unfogged = flags & 32;
        this.noDepthTest = flags & 64;
        this.noDepthSet = flags & 128;
    }

    function Material(reader, nodes, index) {
        this.index = index;
        this.size = readUint32(reader);
        this.priorityPlane = readInt32(reader);
        this.flags = readUint32(reader);
        skip(reader, 4); // LAYS
        this.layers = readKnownElements(reader, readUint32(reader), Layer);
    }

    function TextureAnimation(reader, nodes, index) {
        this.index = index;
        this.size = readUint32(reader);
        this.tracks = new SDContainer(reader, this.size - 4);
    }

    function Geoset(reader, nodes, index) {
        this.index = index;
        this.size = readUint32(reader);

        skip(reader, 4); // VRTX
        this.vertices = readFloat32Array(reader, readUint32(reader) * 3);

        skip(reader, 4); // NRMS
        this.normals = readFloat32Array(reader, readUint32(reader) * 3);

        skip(reader, 4); // PTYP
        this.faceTypeGroups = readUint32Array(reader, readUint32(reader));

        skip(reader, 4); // PCNT
        this.faceGroups = readUint32Array(reader, readUint32(reader));

        skip(reader, 4); // PVTX
        this.faces = readUint16Array(reader, readUint32(reader));

        skip(reader, 4); // GNDX
        this.vertexGroups = readUint8Array(reader, readUint32(reader));

        skip(reader, 4); // MTGC
        this.matrixGroups = readUint32Array(reader, readUint32(reader));

        skip(reader, 4); // MATS
        this.matrixIndexes = readUint32Array(reader, readUint32(reader));

        this.materialId = readUint32(reader);
        this.selectionGroup = readUint32(reader);
        this.selectionFlags = readUint32(reader);
        this.extent =  new Extent(reader);
        this.extents = readKnownElements(reader, readUint32(reader), Extent);

        skip(reader, 4); // UVAS

        this.textureCoordinateSets = [];

        for (var i = 0, l = readUint32(reader); i < l; i++) {
            skip(reader, 4); // UVBS
            this.textureCoordinateSets[i] = readFloat32Array(reader, readUint32(reader) * 2);
        }
    }

    function GeosetAnimation(reader, nodes, index) {
        this.index = index;
        this.size = readUint32(reader);
        this.alpha = readFloat32(reader);
        this.flags = readUint32(reader);
        this.color = readVector3(reader);
        this.geosetId = readUint32(reader);
        this.tracks = new SDContainer(reader, this.size - 28);
    }

    function Bone(reader, nodes, index) {
        this.node = readNode(reader, nodes, this);
        this.geosetId = readUint32(reader);
        this.geosetAnimationId = readUint32(reader);
        this.size = this.node.size + 8;
    }

    function Light(reader, nodes, index) {
        this.index = index;
        this.size = readUint32(reader);
        this.node = readNode(reader, nodes, this);
        this.type = readUint32(reader);
        this.attenuation = readFloat32Array(reader, 2);
        this.color = readVector3(reader);
        this.intensity = readFloat32(reader);
        this.ambientColor = readVector3(reader);
        this.ambientIntensity = readFloat32(reader);
        this.tracks = new SDContainer(reader, this.size - this.node.size - 48);
    }

    function Helper(reader, nodes, index) {
        this.index = index;
        this.node = readNode(reader, nodes, this);
        this.size = this.node.size;
    }

    function Attachment(reader, nodes, index) {
        this.index = index;
        this.size = readUint32(reader);
        this.node = readNode(reader, nodes, this);
        this.path = read(reader, 260);
        this.attachmentId = readUint32(reader);
        this.tracks = new SDContainer(reader, this.size - this.node.size - 268);
    }

    function PivotPoint(reader, index) {
        this.index = index;
        this.value = readFloat32Array(reader, 3);
    }

    function ParticleEmitter(reader, nodes, index) {
        this.index = index;
        this.size = readUint32(reader);
        this.node = readNode(reader, nodes, this);
        this.emissionRate = readFloat32(reader);
        this.gravity = readFloat32(reader);
        this.longitude = readFloat32(reader);
        this.latitude = readFloat32(reader);
        this.path = read(reader, 260);
        this.lifespan = readFloat32(reader);
        this.speed = readFloat32(reader);
        this.tracks = new SDContainer(reader, this.size - this.node.size - 288);
    }

    function ParticleEmitter2(reader, nodes, index) {
        this.index = index;
        this.size = readUint32(reader);
        this.node = readNode(reader, nodes, this);
        this.speed = readFloat32(reader);
        this.variation = readFloat32(reader);
        this.latitude = readFloat32(reader);
        this.gravity = readFloat32(reader);
        this.lifespan = readFloat32(reader);
        this.emissionRate = readFloat32(reader);
        this.width = readFloat32(reader);
        this.length = readFloat32(reader);
        this.filterMode = readUint32(reader);
        this.rows = readUint32(reader);
        this.columns = readUint32(reader);
        this.headOrTail = readUint32(reader);
        this.tailLength = readFloat32(reader);
        this.timeMiddle = readFloat32(reader);
        this.segmentColor = readFloat32Matrix(reader, 3, 3);
        this.segmentAlpha = readUint8Array(reader, 3);
        this.segmentScaling = readFloat32Array(reader, 3);
        this.headInterval = readUint32Array(reader, 3);
        this.headDecayInterval = readUint32Array(reader, 3);
        this.tailInterval = readUint32Array(reader, 3);
        this.tailDecayInterval = readUint32Array(reader, 3);
        this.textureId = readUint32(reader);
        this.squirt = readUint32(reader);
        this.priorityPlane = readUint32(reader);
        this.replaceableId = readUint32(reader);
        this.tracks = new SDContainer(reader, this.size - this.node.size - 175);
    }

    function RibbonEmitter(reader, nodes, index) {
        this.index = index;
        this.size = readUint32(reader);
        this.node = readNode(reader, nodes, this);
        this.heightAbove = readFloat32(reader);
        this.heightBelow = readFloat32(reader);
        this.alpha = readFloat32(reader);
        this.color = readVector3(reader);
        this.lifespan = readFloat32(reader);
        this.textureSlot = readUint32(reader);
        this.emissionRate = readUint32(reader);
        this.rows = readUint32(reader);
        this.columns = readUint32(reader);
        this.materialId = readUint32(reader);
        this.gravity = readFloat32(reader);
        this.tracks = new SDContainer(reader, this.size - this.node.size - 56);
    }

    function EventObject(reader, nodes, index) {
        this.index = index;
        this.node = readNode(reader, nodes, this);
        
        skip(reader, 4); // KEVT
        
        var count = readUint32(reader);

        this.globalSequenceId = readInt32(reader);
        this.tracks = readUint32Array(reader, count);
        this.size = this.node.size + 12 + count * 4;
    }

    function Camera(reader, nodes, index) {
        this.index = index;
        this.size = readUint32(reader);
        this.name = read(reader, 80);
        this.position = readVector3(reader);
        this.fieldOfView = readFloat32(reader);
        this.farClippingPlane = readFloat32(reader);
        this.nearClippingPlane = readFloat32(reader);
        this.targetPosition = readVector3(reader);
        this.tracks = new SDContainer(reader, this.size - 120);
    }
    
    function CollisionShape(reader, nodes, index) {
        this.index = index;
        this.node = readNode(reader, nodes, this);
        this.type = readUint32(reader);

        var type = this.type,
            size = this.node.size + 4;
        
        if (type === 0 || type === 1 || type === 3) {
            this.vertices = readFloat32Array(reader, 6);
            size += 24;
        } else if (type === 2) {
            this.vertices = readVector3(reader);
            size += 12;
        }

        if (type === 2 || type === 3) {
            this.radius = readFloat32(reader);
            size += 4;
        }

        this.size = size;
    }

    /*
    // Note: this chunk was reverse engineered from the game executable itself, but was never seen in any resource
    function SoundTrack(reader, index) {
        this.index = index;
        this.path = read(reader, 260);
        this.volume = readFloat32(reader);
        this.pitch = readFloat32(reader);
        this.flags = readUint32(reader);
    }
    */

    // Chunks that have elements with known sizes
    var tagToKnownChunk = {
        SEQS: [Sequence, 132],
        GLBS: [GlobalSequence, 4],
        TEXS: [Texture, 268],
        PIVT: [PivotPoint, 12]
    };

    // Chunks that have elements with unknown sizes
    var tagToUnknownChunk = {
        MTLS: Material,
        TXAN: TextureAnimation,
        GEOS: Geoset,
        GEOA: GeosetAnimation,
        BONE: Bone,
        LITE: Light,
        HELP: Helper,
        ATCH: Attachment,
        PREM: ParticleEmitter,
        PRE2: ParticleEmitter2,
        RIBB: RibbonEmitter,
        EVTS: EventObject,
        CAMS: Camera,
        CLID: CollisionShape
    };

    function GenericKnownChunk(reader, tag, size, nodes) {
        var tagInfo = tagToKnownChunk[tag];

        this.elements = readKnownElements(reader, size / tagInfo[1], tagInfo[0]);

    }

    function GenericUnknownChunk(reader, tag, size, nodes) {
        var tagInfo = tagToUnknownChunk[tag];

        this.elements = readUnknownElements(reader, size, tagInfo, nodes);
    }
    
    var tagToFunc = {
        VERS: VersionChunk,
        MODL: ModelChunk,
        SEQS: GenericKnownChunk,
        GLBS: GenericKnownChunk,
        TEXS: GenericKnownChunk,
        //SNDS: GenericKnownChunk,
        MTLS: GenericUnknownChunk,
        TXAN: GenericUnknownChunk,
        GEOS: GenericUnknownChunk,
        GEOA: GenericUnknownChunk,
        BONE: GenericUnknownChunk,
        LITE: GenericUnknownChunk,
        HELP: GenericUnknownChunk,
        ATCH: GenericUnknownChunk,
        PIVT: GenericKnownChunk,
        PREM: GenericUnknownChunk,
        PRE2: GenericUnknownChunk,
        RIBB: GenericUnknownChunk,
        EVTS: GenericUnknownChunk,
        CAMS: GenericUnknownChunk,
        CLID: GenericUnknownChunk
    };

    function Parser(reader) {
        var tag,
            size,
            Func,
            chunks = {},
            nodes = [];

        while (remaining(reader) > 0) {
            tag = read(reader, 4);
            size = readUint32(reader);
            Func = tagToFunc[tag];

            if (Func) {
                chunks[tag] = new Func(reader, tag, size, nodes);
            } else {
                //console.log("Didn't parse chunk " + tag);
                skip(reader, size);
            }
        }

        this.chunks = chunks;
        this.nodes = nodes;
    }

    Parser.prototype = {
        // Checks the parser for any errors that will not affect the viewer, but affect the model when it is used in Warcraft 3.
        // For example, things that make the model completely invalid and unloadable in the game, but work just fine in the viewer.
        sanityCheck() {
            let errors = [],
                warnings = [],
                chunks = this.chunks;

            // Found in game.dll: "File contains no geosets, lights, sound emitters, attachments, cameras, particle emitters, or ribbon emitters."
            if (!chunks.GEOS && !chunks.LITE /* && !chunks.SNDS */ && !chunks.ATCH && !chunks.CAMS && !chunks.PREM && !chunks.PRE2 && !chunks.RIBB) {
                errors.push("The model has no geosets, lights, attachments, cameras, particle emitters, or ribbon emitters");
            }

            // Sequences
            if (chunks.SEQS) {
                let sequences = chunks.SEQS.elements,
                    foundStand = false,
                    foundDeath = false;

                if (sequences.length === 0) {
                    warnings.push("No animations");
                }

                for (let i = 0, l = sequences.length; i < l; i++) {
                    let sequence = sequences[i],
                        interval = sequence.interval,
                        length = interval[1] - interval[0];

                    if (sequence.name.toLowerCase().indexOf("stand") !== -1) {
                        foundStand = true;
                    }

                    if (sequence.name.toLowerCase().indexOf("death") !== -1) {
                        foundDeath = true;
                    }

                    if (length <= 0) {
                        errors.push("Sequence " + sequence.name + ": Invalid length " + length);
                    }
                }

                if (!foundStand) {
                    warnings.push("No stand animation");
                }

                if (!foundDeath) {
                    warnings.push("No death animation");
                }
            }
        
            // Textures
            if (chunks.TEXS) {
                let textures = chunks.TEXS.elements;

                for (let i = 0, l = textures.length; i < l; i++) {
                    let texture = textures[i],
                        replaceableId = texture.replaceableId,
                        path = texture.path;

                    if (path === "" && Mdx.replaceableIdToName[replaceableId] === undefined) {
                        errors.push("Texture " + i + ": Unknown replaceable ID " + replaceableId);
                    }

                    // Is this a warning or an error?
                    if (path !== "" && replaceableId !== 0) {
                        warnings.push("Texture " + i + ": Path " + path + " and replaceable ID " + replaceableId + " used together");
                    }
                }
            }

            // Geosets
            if (chunks.GEOS) {
                let geosets = chunks.GEOS.elements;

                for (let i = 0, l = geosets.length; i < l; i++) {
                    let matrixGroups = geosets[i].matrixGroups;

                    for (let j = 0, k = matrixGroups.length; j < k; j++) {
                        let matrixGroup = matrixGroups[j];

                        // There are built-in models with vertices attached to 8 bones, so I assume the game has no upper limit.
                        if (matrixGroup < 1 /*|| matrixGroup > 4*/) {
                            warnings.push("Geoset " + i + ": Vertex " + j + " is attached to " + matrixGroup + " bones");
                        }
                    }
                }
            }

            // Geoset animations
            if (chunks.GEOA && chunks.GEOS) {
                let biggest = chunks.GEOS.elements.length - 1,
                    usageMap = {},
                    geosetAnimations = chunks.GEOA.elements;

                for (let i = 0, l = geosetAnimations.length; i < l; i++) {
                    let geosetId = geosetAnimations[i].geosetId;

                    if (geosetId < 0 || geosetId > biggest) {
                        errors.push("Geoset animation " + i + ": Invalid geoset ID " + geosetId);
                    }

                    if (!usageMap[geosetId]) {
                        usageMap[geosetId] = [];
                    }

                    usageMap[geosetId].push(i);
                }

                let keys = Object.keys(usageMap);

                for (let i = 0, l = keys.length; i < l; i++) {
                    let geoset = keys[i],
                        users = usageMap[geoset];

                    if (users.length > 1) {
                        errors.push("Geoset " + geoset + " has " + users.length + " geoset animations referencing it (" + users.join(", ") + ")");
                    }
                }
            }

            // Lights
            if (chunks.LITE) {
                let lights = chunks.LITE.elements;

                for (let i = 0, l = lights.length; i < l; i++) {
                    let light = lights[i],
                        attenuation = light.attenuation;

                    if (attenuation[0] < 80 || attenuation[1] > 200) {
                        warnings.push("Light " + light.node.name + ": Attenuation min=" + attenuation[0] + " max=" + attenuation[1]);
                    }
                }
            }

            // Event objects
            if (chunks.EVTS) {
                let eventObjects = chunks.EVTS.elements;

                for (let i = 0, l = eventObjects.length; i < l; i++) {
                    let eventObject = eventObjects[i];

                    if (eventObject.tracks.length === 0) {
                        errors.push("Event object " + eventObject.node.name + ": No keys");
                    }
                }
            }

            return [errors, warnings];
        }
    };

    return (function (reader) {
        if (read(reader, 4) === "MDLX") {
            return new Parser(reader);
        }
    });
}());
function MdxSDSequence(sd, start, end, keyframes) {
    var defval = sd.defval;

    this.sd = sd;
    this.start = start;
    this.end = end;
    this.keyframes = [];

    for (var i = 0, l = keyframes.length; i < l; i++) {
        var keyframe = keyframes[i],
            frame = keyframe.frame,
            value = keyframe.value;

        if (frame >= start && frame <= end) {
            this.keyframes.push(keyframe);
        }
    }

    switch (this.keyframes.length) {
        case 0:
            this.constant = true;
            this.value = defval;
            break;

        case 1:
            this.constant = true;
            this.value = this.keyframes[0].value;
            break;

        default:
            /// Mote: This code handles the case where there are multiple keyframes, but they all share the same value.
            ///       It's not really likely to happen, so I commented it for now.
            //var constant = true;
            //var firstValue = this.keyframes[0].value;

            //for (var i = 1, l = this.keyframes.length; i < l; i++) {
            //    var keyframe = this.keyframes[i],
            //        value = keyframe.value;

            //    if (typeof value === "number") {
            //        if (value !== firstValue) {
            //            constant = false;
            //            break;
            //        }
            //    } else {
            //        if (!Array.areEqual(value, firstValue)) {
            //            constant = false;
            //            break;
            //        }
            //    }
            //}

            //if (constant) {
            //    console.log("MISSED")
            //}

            this.constant = false;

            if (this.keyframes[0].frame !== start) {
                this.keyframes.splice(0, 0, { frame: start, value: defval, inTan: defval, outTan: defval });
            }

            if (this.keyframes[this.keyframes.length - 1].frame !== end) {
                // Swap the in/out tangents
                this.keyframes.splice(this.keyframes.length, 0, { frame: end, value: this.keyframes[0].value, inTan: this.keyframes[0].outTan, outTan: this.keyframes[0].inTan });
            }

            break;
    }

    //console.log(sequence, this.keyframes, defval)
}

MdxSDSequence.prototype = {
    getValue(frame) {
        if (this.constant) {
            return this.value;
        } else {
            var keyframes = this.keyframes,
                l = keyframes.length;

            if (frame <= this.start) {
                return keyframes[0].value;
            } else if (frame >= this.end) {
                return keyframes[l - 1].value;
            } else {
                for (var i = 1; i < l; i++) {
                    var keyframe = keyframes[i];

                    if (keyframe.frame > frame) {
                        var lastKeyframe = keyframes[i - 1];

                        var t = Math.clamp((frame - lastKeyframe.frame) / (keyframe.frame - lastKeyframe.frame), 0, 1);

                        return Interpolator.interpolate(lastKeyframe.value, lastKeyframe.outTan, keyframe.inTan, keyframe.value, t, this.sd.interpolationType);
                    }
                }
            }
        }
    }
};

function MdxSD(sd, model) {
    var i, l, arr, keys;
    
    this.tag = sd.tag;
    this.model = model;
    this.keyframes = sd.tracks;
    this.defval = sd.defval;
    this.interpolationType = sd.interpolationType;
    
    if (sd.globalSequenceId !== -1 && model.globalSequences) {
        this.globalSequence = new MdxSDSequence(this, 0, model.globalSequences[sd.globalSequenceId].value, sd.tracks);
    } else {
        this.sequences = [];

        for (var i = 0, l = model.sequences.length; i < l; i++) {
            var interval = model.sequences[i].interval;

            this.sequences[i] = new MdxSDSequence(this, interval[0], interval[1], sd.tracks);
        }
    }
}

MdxSD.prototype = {
    getValue(instance) {
        if (this.globalSequence) {
            var globalSequence = this.globalSequence;

            return globalSequence.getValue(Date.now() % globalSequence.end);
        } else if (instance.sequence !== -1) {
            return this.sequences[instance.sequence].getValue(instance.frame);
        } else {
            return this.defval;
        }
    },

    isVariant(sequence) {
        if (this.globalSequence) {
            return !this.globalSequence.constant;
        } else {
            return !this.sequences[sequence].constant;
        }
    },

    getValues() {
        if (this.globalSequence) {
            var values = [],
                keyframes = this.globalSequence.keyframes;

            for (var i = 0, l = keyframes.length; i < l; i++) {
                values[i] = keyframes[i].value;
            }

            return values;
        } else {
            console.warn("[MdxSD::getValues] Called on an SD that doesn't use a global sequence")
            return [];
        }
    }
};

function MdxSdContainer(container, model) {
    var sd = [];

    // The SD container doesn't exist if a model had no nodes, and a fake node was injected.
    if (container) {
        var tracks = container.sd;
        var keys = Object.keys(tracks || {});


        for (var i = 0, l = keys.length; i < l; i++) {
            var type = keys[i];
            var track = tracks[type];

            sd[track.sdIndex] = new MdxSD(track, model);
        }
    }

    this.sd = sd;
}

MdxSdContainer.prototype = {
    getValue(i, instance, defval) {
        var sd = this.sd[i];

        if (sd) {
            return sd.getValue(instance);
        }

        return defval;
    },

    isVariant(i, sequence) {
        var sd = this.sd[i];

        if (sd) {
            return sd.isVariant(sequence);
        }

        return false;
    },

    getKMTFValue(instance, defval) {
        return this.getValue(0, instance, defval);
    },

    getKMTAValue(instance, defval) {
        return this.getValue(1, instance, defval);
    },

    getKTATValue(instance, defval) {
        return this.getValue(2, instance, defval);
    },

    getKTARValue(instance, defval) {
        return this.getValue(3, instance, defval);
    },

    getKTASValue(instance, defval) {
        return this.getValue(4, instance, defval);
    },

    getKGAOValue(instance, defval) {
        return this.getValue(5, instance, defval);
    },

    getKGACValue(instance, defval) {
        return this.getValue(6, instance, defval);
    },

    getKLASValue(instance, defval) {
        return this.getValue(7, instance, defval);
    },

    getKLAEValue(instance, defval) {
        return this.getValue(8, instance, defval);
    },

    getKLACValue(instance, defval) {
        return this.getValue(9, instance, defval);
    },

    getKLAIValue(instance, defval) {
        return this.getValue(10, instance, defval);
    },

    getKLBIValue(instance, defval) {
        return this.getValue(11, instance, defval);
    },

    getKLBCValue(instance, defval) {
        return this.getValue(12, instance, defval);
    },

    getKLAVValue(instance, defval) {
        return this.getValue(13, instance, defval);
    },

    getKATVValue(instance, defval) {
        return this.getValue(14, instance, defval);
    },

    getKPEEValue(instance, defval) {
        return this.getValue(15, instance, defval);
    },

    getKPEGValue(instance, defval) {
        return this.getValue(16, instance, defval);
    },

    getKPLNValue(instance, defval) {
        return this.getValue(17, instance, defval);
    },

    getKPLTValue(instance, defval) {
        return this.getValue(18, instance, defval);
    },

    getKPELValue(instance, defval) {
        return this.getValue(19, instance, defval);
    },

    getKPESValue(instance, defval) {
        return this.getValue(20, instance, defval);
    },

    getKPEVValue(instance, defval) {
        return this.getValue(21, instance, defval);
    },

    getKP2SValue(instance, defval) {
        return this.getValue(22, instance, defval);
    },

    getKP2RValue(instance, defval) {
        return this.getValue(23, instance, defval);
    },

    getKP2LValue(instance, defval) {
        return this.getValue(24, instance, defval);
    },

    getKP2GValue(instance, defval) {
        return this.getValue(25, instance, defval);
    },

    getKP2EValue(instance, defval) {
        return this.getValue(26, instance, defval);
    },

    getKP2NValue(instance, defval) {
        return this.getValue(27, instance, defval);
    },

    getKP2WValue(instance, defval) {
        return this.getValue(28, instance, defval);
    },

    getKP2VValue(instance, defval) {
        return this.getValue(29, instance, defval);
    },

    getKRHAValue(instance, defval) {
        return this.getValue(30, instance, defval);
    },

    getKRHBValue(instance, defval) {
        return this.getValue(31, instance, defval);
    },

    getKRALValue(instance, defval) {
        return this.getValue(32, instance, defval);
    },

    getKRCOValue(instance, defval) {
        return this.getValue(33, instance, defval);
    },

    getKRTXValue(instance, defval) {
        return this.getValue(34, instance, defval);
    },

    getKRVSValue(instance, defval) {
        return this.getValue(35, instance, defval);
    },

    getKCTRValue(instance, defval) {
        return this.getValue(36, instance, defval);
    },

    getKTTRValue(instance, defval) {
        return this.getValue(37, instance, defval);
    },

    getKCRLValue(instance, defval) {
        return this.getValue(38, instance, defval);
    },

    getKGTRValue(instance, defval) {
        return this.getValue(39, instance, defval);
    },

    getKGRTValue(instance, defval) {
        return this.getValue(40, instance, defval);
    },

    getKGSCValue(instance, defval) {
        return this.getValue(41, instance, defval);
    },

    isKMTFVariant(sequence) {
        return this.isVariant(0, sequence);
    },

    isKMTAVariant(sequence) {
        return this.isVariant(1, sequence);
    },

    isKTATVariant(sequence) {
        return this.isVariant(2, sequence);
    },

    isKTARVariant(sequence) {
        return this.isVariant(3, sequence);
    },

    isKTASVariant(sequence) {
        return this.isVariant(4, sequence);
    },

    isKGAOVariant(sequence) {
        return this.isVariant(5, sequence);
    },

    isKGACVariant(sequence) {
        return this.isVariant(6, sequence);
    },

    isKLASVariant(sequence) {
        return this.isVariant(7, sequence);
    },

    isKLAEVariant(sequence) {
        return this.isVariant(8, sequence);
    },

    isKLACVariant(sequence) {
        return this.isVariant(9, sequence);
    },

    isKLAIVariant(sequence) {
        return this.isVariant(10, sequence);
    },

    isKLBIVariant(sequence) {
        return this.isVariant(11, sequence);
    },

    isKLBCVariant(sequence) {
        return this.isVariant(12, sequence);
    },

    isKLAVVariant(sequence) {
        return this.isVariant(13, sequence);
    },

    isKATVVariant(sequence) {
        return this.isVariant(14, sequence);
    },

    isKPEEVariant(sequence) {
        return this.isVariant(15, sequence);
    },

    isKPEGVariant(sequence) {
        return this.isVariant(16, sequence);
    },

    isKPLNVariant(sequence) {
        return this.isVariant(17, sequence);
    },

    isKPLTVariant(sequence) {
        return this.isVariant(18, sequence);
    },

    isKPELVariant(sequence) {
        return this.isVariant(19, sequence);
    },

    isKPESVariant(sequence) {
        return this.isVariant(20, sequence);
    },

    isKPEVVariant(sequence) {
        return this.isVariant(21, sequence);
    },

    isKP2SVariant(sequence) {
        return this.isVariant(22, sequence);
    },

    isKP2RVariant(sequence) {
        return this.isVariant(23, sequence);
    },

    isKP2LVariant(sequence) {
        return this.isVariant(24, sequence);
    },

    isKP2GVariant(sequence) {
        return this.isVariant(25, sequence);
    },

    isKP2EVariant(sequence) {
        return this.isVariant(26, sequence);
    },

    isKP2NVariant(sequence) {
        return this.isVariant(27, sequence);
    },

    isKP2WVariant(sequence) {
        return this.isVariant(28, sequence);
    },

    isKP2VVariant(sequence) {
        return this.isVariant(29, sequence);
    },

    isKRHAVariant(sequence) {
        return this.isVariant(30, sequence);
    },

    isKRHBVariant(sequence) {
        return this.isVariant(31, sequence);
    },

    isKRALVariant(sequence) {
        return this.isVariant(32, sequence);
    },

    isKRCOVariant(sequence) {
        return this.isVariant(33, sequence);
    },

    isKRTXVariant(sequence) {
        return this.isVariant(34, sequence);
    },

    isKRVSVariant(sequence) {
        return this.isVariant(35, sequence);
    },

    isKCTRVariant(sequence) {
        return this.isVariant(36, sequence);
    },

    isKTTRVariant(sequence) {
        return this.isVariant(37, sequence);
    },

    isKCRLVariant(sequence) {
        return this.isVariant(38, sequence);
    },

    isKGTRVariant(sequence) {
        return this.isVariant(39, sequence);
    },

    isKGRTVariant(sequence) {
        return this.isVariant(40, sequence);
    },

    isKGSCVariant(sequence) {
        return this.isVariant(41, sequence);
    },

    getKMTF() {
        return this.sd[0];
    },

    getKMTA() {
        return this.sd[1];
    },

    getKTAT() {
        return this.sd[2];
    },

    getKTAR() {
        return this.sd[3];
    },

    getKTAS() {
        return this.sd[4];
    },

    getKGAO() {
        return this.sd[5];
    },

    getKGAC() {
        return this.sd[6];
    },

    getKLAS() {
        return this.sd[7];
    },

    getKLAE() {
        return this.sd[8];
    },

    getKLAC() {
        return this.sd[9];
    },

    getKLAI() {
        return this.sd[10];
    },

    getKLBI() {
        return this.sd[11];
    },

    getKLBC() {
        return this.sd[12];
    },

    getKLAV() {
        return this.sd[13];
    },

    getKATV() {
        return this.sd[14];
    },

    getKPEE() {
        return this.sd[15];
    },

    getKPEG() {
        return this.sd[16];
    },

    getKPLN() {
        return this.sd[17];
    },

    getKPLT() {
        return this.sd[18];
    },

    getKPEL() {
        return this.sd[19];
    },

    getKPES() {
        return this.sd[20];
    },

    getKPEV() {
        return this.sd[21];
    },

    getKP2S() {
        return this.sd[22];
    },

    getKP2R() {
        return this.sd[23];
    },

    getKP2L() {
        return this.sd[24];
    },

    getKP2G() {
        return this.sd[25];
    },

    getKP2E() {
        return this.sd[26];
    },

    getKP2N() {
        return this.sd[27];
    },

    getKP2W() {
        return this.sd[28];
    },

    getKP2V() {
        return this.sd[29];
    },

    getKRHA() {
        return this.sd[30];
    },

    getKRHB() {
        return this.sd[31];
    },

    getKRAL() {
        return this.sd[32];
    },

    getKRCO() {
        return this.sd[33];
    },

    getKRTX() {
        return this.sd[34];
    },

    getKRVS() {
        return this.sd[35];
    },

    getKCTR() {
        return this.sd[36];
    },

    getKTTR() {
        return this.sd[37];
    },

    getKCRL() {
        return this.sd[38];
    },

    getKGTR() {
        return this.sd[39];
    },

    getKGRT() {
        return this.sd[40];
    },

    getKGSC() {
        return this.sd[41];
    }
};
function MdxSkeleton(instance) {
    let model = instance.model,
        nodes = model.nodes,
        bones = model.bones,
        hierarchy = model.hierarchy;

    Skeleton.call(this, instance, nodes.length);

    this.sortedNodes = [];

    for (let i = 0, l = nodes.length; i < l; i++) {
        // Set the node pivots
        this.nodes[i].setPivot(nodes[i].pivot);

        // Set the node parent references
        this.nodes[i].setParent(this.getNode(nodes[i].parentId));

        // The sorted version of the nodes, for straight iteration in update()
        this.sortedNodes[i] = this.nodes[hierarchy[i]];
    }

    // The sorted version of the bone references in the model, for straight iteration in updateHW()
    this.bones = [];
    for (let i = 0, l = bones.length; i < l; i++) {
        this.bones[i] = this.nodes[bones[i].node.index];
    }

    this.modelNodes = model.sortedNodes;

    this.instance = instance;

    this.boneArray = null;
}

MdxSkeleton.prototype = {
    update() {
        if (this.boneArray) {
            const nodes = this.sortedNodes,
                modelNodes = this.modelNodes,
                instance = this.instance;

            for (let i = 0, l = nodes.length; i < l; i++) {
                let node = nodes[i],
                    modelNode = modelNodes[i],
                    translation = modelNode.getTranslation(instance),
                    rotation = modelNode.getRotation(instance),
                    scale = modelNode.getScale(instance);

                if (modelNode.billboarded) {
                    const camera = instance.bucket.modelView.scene.camera;

                    var blarg = [0, 0, 0, 1];

                    //quat.conjugate(blarg, node.worldRotation);
                    
                    
                    quat.rotateZ(blarg, blarg, -Math.PI / 2);
                    quat.rotateY(blarg, blarg, - Math.PI / 2);
                    quat.mul(blarg, camera.inverseRotation, blarg);

                    //quat.copy(blarg, camera.inverseRotation)
                    //quat.mul(blarg, blarg, node.parent.worldRotation);

                    //quat.copy(rotation, blarg);

                   // quat.copy(rotation, camera.inverseRotation)
                    //rotation = camera.inverseRotation;

                    rotation = blarg;
                }

                node.setTransformation(translation, rotation, scale);
            }

            const bones = this.bones,
                boneArray = this.boneArray;


            for (let i = 0, l = bones.length; i < l; i++) {
                boneArray.set(bones[i].worldMatrix, i * 16 + 16);
            }
        }
    }
};

mix(MdxSkeleton.prototype, Skeleton.prototype);
function MdxCollisionShape(collisionshape, model, gl) {
    this.node = collisionshape.node;

    var v = collisionshape.vertices;
    var radius = collisionshape.radius;
    var shape;

    if (collisionshape.type === 0) {
        shape = gl.createCube(v[0], v[1], v[2], v[0], v[1], v[2]);
        //} else if (collisionshape.type === 1) {
        //shape = gl.newPlane(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2]);
    } else if (collisionshape.type === 2) {
        shape = gl.createSphere(v[0], v[1], v[2], 9, 9, radius);
        //} else {
        //shape = gl.newCylinder(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2], 8, 2, boundsRadius);
    }

    this.shape = shape;
}

MdxCollisionShape.prototype = {
    render(skeleton, shader, gl) {
        var ctx = gl.ctx;

        if (this.shape) {
            gl.pushMatrix();

            gl.multMat(skeleton.nodes[this.node].worldMatrix);

            ctx.uniformMatrix4fv(shader.variables.u_mvp, false, gl.getViewProjectionMatrix());

            this.shape.renderLines(shader);

            gl.popMatrix();
        }
    }
};
function MdxCamera(camera, model) {
    this.name = camera.name;
    this.position = camera.position;
    this.fieldOfView = camera.fieldOfView;
    this.farClippingPlane = camera.farClippingPlane;
    this.nearClippingPlane = camera.nearClippingPlane;
    this.targetPosition = camera.targetPosition;
    this.sd = new MdxSdContainer(camera.tracks, model);
}

MdxCamera.prototype = {
    getPositionTranslation(instance) {
        return this.sd.getKCTRValue(instance, this.position);
    },

    getTargetTranslation(instance) {
        return this.sd.getKTTRValue(instance, this.targetPosition);
    },

    getRotation(instance) {
        return this.sd.getKCRLValue(instance, 0);
    }
};
function MdxShallowGeoset(offsets, uvSetSize, elements, model) {
    this.model = model;
    this.offsets = offsets;
    this.uvSetSize = uvSetSize;
    this.elements = elements;
}

MdxShallowGeoset.prototype = {
    bind(shader, coordId) {
        let gl = this.model.env.gl,
            offsets = this.offsets,
            attribs = shader.attribs;

        gl.vertexAttribPointer(attribs.get("a_position"), 3, gl.FLOAT, false, 12, offsets[0]);
        gl.vertexAttribPointer(attribs.get("a_bones"), 4, gl.UNSIGNED_BYTE, false, 4, offsets[3]);
        gl.vertexAttribPointer(attribs.get("a_boneNumber"), 4, gl.UNSIGNED_BYTE, false, 4, offsets[4]);
        gl.vertexAttribPointer(attribs.get("a_normal"), 3, gl.FLOAT, false, 12, offsets[1]);
        gl.vertexAttribPointer(attribs.get("a_uv"), 2, gl.FLOAT, false, 8, offsets[2] + coordId * this.uvSetSize);
    },

    render(instances) {
        let gl = this.model.gl;

        gl.extensions.instancedArrays.drawElementsInstancedANGLE(gl.TRIANGLES, this.elements, gl.UNSIGNED_SHORT, this.offsets[5], instances);
    }
};

function MdxGeoset(geoset, geosetAnimations) {
    let positions = geoset.vertices,
        normals = geoset.normals,
        textureCoordinateSets = geoset.textureCoordinateSets,
        uvsetSize = textureCoordinateSets[0].length,
        vertices = positions.length / 3,
        uvs,
        boneIndices = new Uint8Array(vertices * 4),
        boneNumbers = new Uint32Array(vertices),
        matrixGroups = geoset.matrixGroups,
        matrixIndexes = geoset.matrixIndexes,
        slices = [],
        i, l, j, k;

    // Make one typed array for the texture coordinates, in case there are multiple ones
    if (textureCoordinateSets.length > 1) {
        uvs = new Float32Array(textureCoordinateSets.length * uvsetSize);

        for (i = 0, l = textureCoordinateSets.length; i < l; i++) {
            uvs.set(textureCoordinateSets[i], i * uvsetSize);
        }
    } else {
        uvs = textureCoordinateSets[0];
    }

    // Parse the bone indices by slicing the matrix groups
    for (i = 0, l = matrixGroups.length, k = 0; i < l; i++) {
        slices.push(matrixIndexes.subarray(k, k + matrixGroups[i]));
        k += matrixGroups[i];
    }

    // Construct the final bone arrays
    for (i = 0, l = vertices, k = 0; i < l; i++) {
        let slice = slices[geoset.vertexGroups[i]],
            bones = 0;

        // 1 is added to every index for shader optimization (index 0 is a zero matrix)
        for (j = 0; j < 4; j++, k++) {
            if (slice && j < slice.length) {
                boneIndices[k] = slice[j] + 1;
                bones += 1;
            } else {
                boneIndices[k] = 0;
            }
        }

        boneNumbers[i] = bones;
    }

    this.index = geoset.index;
    this.materialId = geoset.materialId;
    this.locationArray = positions;
    this.normalArray = normals;
    this.uvsArray = uvs;
    this.boneIndexArray = boneIndices;
    this.boneNumberArray = boneNumbers;
    this.faceArray = geoset.faces;
    this.uvSetSize = uvsetSize * 4;

    for (i = 0, l = geosetAnimations.length; i < l; i++) {
        if (geosetAnimations[i].geosetId === geoset.index) {
            this.geosetAnimation = geosetAnimations[i];
            break;
        }
    }
}

MdxGeoset.prototype = {
    getAlpha(instance) {
        if (this.geosetAnimation) {
            return this.geosetAnimation.getAlpha(instance);
        }

        return 1;
    },

    isAlphaVariant(sequence) {
        if (this.geosetAnimation) {
            return this.geosetAnimation.isAlphaVariant(sequence);
        }

        return false;
    },

    calculateExtent() {
        const positions = this.locationArray;
        let minX = 1E9, minY = 1E9, minZ = 1E9, maxX = -1E9, maxY = -1E9, maxZ = -1E9;

        for (let i = 0, l = positions.length; i < l; i += 3) {
            let x = positions[i],
                y = positions[i + 1],
                z = positions[i + 2];

            if (x > maxX) {
                maxX = x;
            } else if (x < minX) {
                minX = x;
            }

            if (y > maxY) {
                maxY = y;
            } else if (y < minY) {
                minY = y;
            }

            if (z > maxZ) {
                maxZ = z;
            } else if (z < minZ) {
                minZ = z;
            }
        }

        let dX = maxX - minX,
            dY = maxY - minY,
            dZ = maxZ - minZ;

        this.extent = { radius: Math.sqrt(dX * dX + dY * dY + dZ * dZ) / 2, min: [minX, minY, minZ], max: [maxX, maxY, maxZ] };
    }
};
function MdxBatch(index, layer, geoset) {
    this.index = index;
    this.layer = layer;
    this.geoset = geoset;
}

MdxBatch.prototype = {
    shouldRender(instance) {
        if (this.layer.getAlpha(instance) < 0.75 || this.geoset.getAlpha(instance) < 0.75) {
            return 0;
        }

        return 1;
    }
};

var MdxFilterModeToRenderOrder = {
    0: 0, // Opaque
    1: 1, // 1bit Alpha
    2: 2, // 8bit Alpha
    3: 3, // Additive
    4: 3, // Add Alpha (according to Magos)
    5: 3, // Modulate
    6: 3  // Modulate 2X
};

function MdxLayer(layer, layerId, priorityPlane, model) {
    let filterMode = Math.min(layer.filterMode, 6),
        textureAnimationId = layer.textureAnimationId,
        gl = model.gl;

    this.gl = gl;
    this.index = layerId;
    this.priorityPlane = priorityPlane;
    this.filterMode = filterMode;
    this.twoSided = layer.twoSided;
    this.noDepthTest = layer.noDepthTest;
    this.noDepthSet = layer.noDepthSet;
    this.textureId = layer.textureId;
    this.coordId = layer.coordId;
    this.alpha = layer.alpha;
    this.renderOrder = MdxFilterModeToRenderOrder[filterMode];
    this.sd = new MdxSdContainer(layer.tracks, model);

    if (textureAnimationId !== -1) {
        let textureAnimation = model.textureAnimations[textureAnimationId];

        if (textureAnimation) {
            this.textureAnimation = textureAnimation;
        } else {
            console.warn("Layer " + layerId + " is referencing a nonexistent texture animation " + textureAnimationId);
        }
    }

    this.depthMaskValue = (filterMode === 0 || filterMode === 1) ? 1 : 0;
    this.alphaTestValue = (filterMode === 1) ? 1 : 0;
    this.blendValue = (filterMode > 1) ? true : false;

    if (this.blendValue) {
        switch (filterMode) {
            case 2:
                this.blendSrc = gl.SRC_ALPHA;
                this.blendDst = gl.ONE_MINUS_SRC_ALPHA;
                break;
            case 3:
                this.blendSrc = gl.ONE;
                this.blendDst = gl.ONE;
                break;
            case 4:
                this.blendSrc = gl.SRC_ALPHA;
                this.blendDst = gl.ONE;
                break;
            case 5:
                this.blendSrc = gl.ZERO;
                this.blendDst = gl.SRC_COLOR;
                break;
            case 6:
                this.blendSrc = gl.DST_COLOR;
                this.blendDst = gl.SRC_COLOR;
                break;
        }
    }

    this.uvDivisor = new Float32Array([1, 1]);
    this.isTextureAnim = false;
}

MdxLayer.prototype = {
    bind(shader) {
        const gl = this.gl;

        gl.uniform1f(shader.uniforms.get("u_alphaTest"), this.alphaTestValue);

        if (this.blendValue) {
            gl.enable(gl.BLEND);
            gl.blendFunc(this.blendSrc, this.blendDst);
        } else {
            gl.disable(gl.BLEND);
        }

        if (this.twoSided) {
            gl.disable(gl.CULL_FACE);
        } else {
            gl.enable(gl.CULL_FACE);
        }

        if (this.noDepthTest) {
            gl.disable(gl.DEPTH_TEST);
        } else {
            gl.enable(gl.DEPTH_TEST);
        }

        if (this.noDepthSet) {
            gl.depthMask(0);
        } else {
            gl.depthMask(this.depthMaskValue);
        }
    },

    setAtlas(atlas) {
        this.textureId = atlas.textureId;
        this.uvDivisor.set([atlas.columns, atlas.rows]);
        this.isTextureAnim = true;
    },

    getAllTextureIds() {
        var kmtf = this.sd.getKMTF();

        if (kmtf) {
            var values = kmtf.getValues();

            // Remove duplicate elements but keep the unique ones in order
            return values.unique();
        } else {
            return [this.textureId];
        }
    },

    getAlpha(instance) {
        return this.sd.getKMTAValue(instance, this.alpha);
    },

    isAlphaVariant(sequence) {
        return this.sd.isKMTAVariant(sequence);
    },

    getTextureId(instance) {
        return this.sd.getKMTFValue(instance, this.textureId);
    }
};
function MdxGeosetAnimation(geosetAnimation, model) {
    this.alpha = geosetAnimation.alpha;
    this.color = [...geosetAnimation.color].reverse();
    this.geosetId = geosetAnimation.geosetId;
    this.sd = new MdxSdContainer(geosetAnimation.tracks, model);
}

MdxGeosetAnimation.prototype = {
    getAlpha(instance) {
        // The alpha variable doesn't seem to actually be used by the game?
        return this.sd.getKGAOValue(instance, 1);
    },

    isAlphaVariant(sequence) {
        return this.sd.isKGAOVariant(sequence);
    },

    getColor(instance) {
        // NOTE: BGRA data, it gets sizzled in the shader
        let color = this.sd.getKGACValue(instance, this.color);

        // Some Blizzard models have values greater than 1, which messes things up.
        // Geoset animations are supposed to modulate colors, not intensify them.
        color[0] = Math.min(color[0], 1);
        color[1] = Math.min(color[1], 1);
        color[2] = Math.min(color[2], 1);

        return color;
    }
};
function MdxTextureAnimation(textureAnimation, model) {
    this.sd = new MdxSdContainer(textureAnimation.tracks, model);
}

MdxTextureAnimation.prototype = {
    getTranslation(instance) {
        return this.sd.getKTATValue(instance, vec3.ZERO);
    },

    getRotation(instance) {
        return this.sd.getKTARValue(instance, quat.DEFAULT);
    },

    getScale(instance) {
        return this.sd.getKTASValue(instance, vec3.ONE);
    }
};
function MdxNode(object, model, pivots) {
    var pivot = pivots[object.objectId];

    this.name = object.name;
    this.objectId = object.objectId;
    this.parentId = object.parentId;
    this.pivot = pivot ? pivot.value : [0, 0, 0];
    this.billboarded = object.billboarded;
    this.modelSpace = object.modelSpace;
    this.xYQuad = object.xYQuad;
    this.sd = new MdxSdContainer(object.tracks, model);

    if (object.objectId === object.parentId) {
        this.parentId = -1;
    }
}

MdxNode.prototype = {
    getTranslation(instance) {
        return this.sd.getKGTRValue(instance, vec3.ZERO);
    },

    getRotation(instance) {
        return this.sd.getKGRTValue(instance, quat.DEFAULT);
    },

    getScale(instance) {
        return this.sd.getKGSCValue(instance, vec3.ONE);
    },

    isVariant(sequence) {
        var sd = this.sd;

        return sd.isKGTRVariant(sequence) || sd.isKGRTVariant(sequence) || sd.isKGSCVariant(sequence);
    }
};
function MdxAttachment(attachment, model) {
    const path = attachment.path.replace(/\\/g, "/").toLowerCase().replace(".mdl", ".mdx");

    this.node = attachment.node;
    this.path = path;
    this.attachmentId = attachment.attachmentId;
    this.sd = new MdxSdContainer(attachment.tracks, model);

    // Second condition is against custom resources using arbitrary paths...
    if (path !== "" && path.indexOf(".mdx") != -1) {
        this.attachedModel = model.env.load(path, model.pathSolver);
    }
}

MdxAttachment.prototype = {
    getVisibility(instance) {
        return this.sd.getKATVValue(instance, 1);
    }
};
function MdxEventObjectSpn(emitter) {
    var viewer = emitter.viewer;
    var pathSolver = emitter.pathSolver;
    var instance = viewer.loadInternalResource(pathSolver(emitter.path), pathSolver);

    instance.setSequence(0);
    instance.setLocation(emitter.node.worldLocation);
    instance.setScale(emitter.node.scale[0]); // Assuming uniform scale
    instance.setRotationQuat(emitter.node.worldRotation);
    
    this.instance = instance;
}

MdxEventObjectSpn.prototype = {
    update(emitter) {
        this.instance.update();
    },
    
    render(emitter) {
        this.instance.render();
    },
    
    renderEmitters: function (emitter) {
        this.instance.renderEmitters();
    },
    
    ended() {
        var instance = this.instance;
        
        if (instance.ready && instance.instance.frame >= instance.instance.model.sequences[0].interval[1]) {
            return true;
        }
        
        return false;
    }
};
function MdxEventObjectSpl(emitter) {
    var viewer = emitter.viewer;
    var ctx = viewer.gl.ctx;
    
    this.emitter = emitter;

    if (!emitter.buffer) {
        emitter.buffer = ctx.createBuffer();
        emitter.data = new Float32Array(30);

        ctx.bindBuffer(ctx.ARRAY_BUFFER, emitter.buffer);
        ctx.bufferData(ctx.ARRAY_BUFFER, emitter.data, ctx.DYNAMIC_DRAW);
    }
    
    this.time = 0;
    this.endTime = emitter.firstIntervalTime + emitter.secondIntervalTime;
    this.location = vec3.clone(emitter.node.worldLocation);
    this.scale = vec3.clone(emitter.node.worldScale);
    this.color = vec4.create();
    this.index = 0;
}

MdxEventObjectSpl.prototype = {
    update(emitter) {
        var viewer = emitter.viewer;
        var dt = viewer.frameTime / 100;
        
        this.time = Math.min(this.time + dt, this.endTime);
        
        var time = this.time;
        var first = emitter.firstIntervalTime;
        var second = emitter.secondIntervalTime;
        var tempFactor;
        var index;
        var color = this.color;
        
        if (time < first) {
            tempFactor = time / first;
            
            vec4.lerp(color, emitter.colors[0], emitter.colors[1], tempFactor);
            index = Math.lerp(emitter.firstInterval[0], emitter.firstInterval[1], tempFactor);
        } else {
            tempFactor = (time - first) / second;
            
            vec4.lerp(color, emitter.colors[1], emitter.colors[2], tempFactor);
            index = Math.lerp(emitter.secondInterval[0], emitter.secondInterval[1], tempFactor);
        }
        
        this.index = Math.floor(index);
    },
    
    updateHW(emitter) {
        var viewer = emitter.viewer;
        var columns = emitter.columns;
        var position = this.location;
        var nodeScale = this.scale;
        var scale = emitter.scale;
        var index = this.index
        var left = index % columns;
        var top = Math.floor(index / columns);
        var right = left + 1;
        var bottom = top + 1;
        var color = this.color;
        var r = Math.floor(color[0]);
        var g = Math.floor(color[1]);
        var b = Math.floor(color[2]);
        var a = Math.floor(color[3]);
        var px = position[0];
        var py = position[1];
        var pz = position[2];
        var v1x = px - scale * nodeScale[0];
        var v1y = py - scale * nodeScale[1];
        var v1z = pz;
        var v2x = px - scale * nodeScale[0];
        var v2y = py + scale * nodeScale[1];
        var v2z = pz;
        var v3x = px + scale * nodeScale[0];
        var v3y = py + scale * nodeScale[1];
        var v3z = pz;
        var v4x = px + scale * nodeScale[0];
        var v4y = py - scale * nodeScale[1];
        var v4z = pz;
        var lta = encodeFloat3(left, top, a);
        var lba = encodeFloat3(left, bottom, a);
        var rta = encodeFloat3(right, top, a);
        var rba = encodeFloat3(right, bottom, a);
        var rgb = encodeFloat3(r, g, b);
        var data = this.emitter.data;
        
        data[0] = v1x;
        data[1] = v1y;
        data[2] = v1z;
        data[3] = lta;
        data[4] = rgb;

        data[5] = v2x;
        data[6] = v2y;
        data[7] = v2z;
        data[8] = lba;
        data[9] = rgb;

        data[10] = v3x;
        data[11] = v3y;
        data[12] = v3z;
        data[13] = rba;
        data[14] = rgb;

        data[15] = v1x;
        data[16] = v1y;
        data[17] = v1z;
        data[18] = lta;
        data[19] = rgb;

        data[20] = v3x;
        data[21] = v3y;
        data[22] = v3z;
        data[23] = rba;
        data[24] = rgb;

        data[25] = v4x;
        data[26] = v4y;
        data[27] = v4z;
        data[28] = rta;
        data[29] = rgb;
    },
    
    render(emitter) {
        var viewer = emitter.viewer;
        var gl = viewer.gl;
        var ctx = gl.ctx;
        
        var shader = gl.bindShader("wparticles");

        ctx.uniformMatrix4fv(shader.variables.u_mvp, false, gl.getViewProjectionMatrix());
        ctx.uniform1i(shader.variables.u_texture, 0);
        
        ctx.disable(ctx.CULL_FACE);
        ctx.enable(ctx.DEPTH_TEST);
        ctx.depthMask(0);
        ctx.enable(ctx.BLEND);
        
        switch (this.blendMode) {
            // Blend
            case 0:
                ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE_MINUS_SRC_ALPHA);
                break;
            // Additive
            case 1:
                ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE);
                break;
            // Modulate
            case 2:
                ctx.blendFunc(ctx.ZERO, ctx.SRC_COLOR);
                break;
            // Modulate 2X
            case 3:
                ctx.blendFunc(ctx.DEST_COLOR, ctx.SRC_COLOR);
                break;
            // Alpha Key
            case 4:
                // ??
                break;
        }
        
        viewer.gl.bindTexture(emitter.texture, null, 0);
        
        ctx.uniform2fv(shader.variables.u_dimensions, emitter.dimensions);

        this.updateHW(emitter, viewer);

        ctx.bindBuffer(ctx.ARRAY_BUFFER, this.emitter.buffer);
        ctx.bufferSubData(ctx.ARRAY_BUFFER, 0, this.emitter.data);

        ctx.vertexAttribPointer(shader.variables.a_position, 3, ctx.FLOAT, false, 20, 0);
        ctx.vertexAttribPointer(shader.variables.a_uva_rgb, 2, ctx.FLOAT, false, 20, 12);

        ctx.drawArrays(ctx.TRIANGLES, 0, 6);
    },
    
    renderEmitters(emitter) {

    },
    
    ended() {
        return (this.time >= this.endTime);
    }
};
function MdxEventObjectUbr(emitter) {
    var viewer = emitter.viewer;
    var ctx = viewer.gl.ctx;
    
    this.emitter = emitter;

    if (!emitter.buffer) {
        emitter.buffer = ctx.createBuffer();
        emitter.data = new Float32Array(30);

        ctx.bindBuffer(ctx.ARRAY_BUFFER, emitter.buffer);
        ctx.bufferData(ctx.ARRAY_BUFFER, emitter.data, ctx.DYNAMIC_DRAW);
    }

    this.time = 0;
    this.endTime = emitter.firstIntervalTime + emitter.secondIntervalTime + emitter.thirdIntervalTime;
    this.location = vec3.clone(emitter.node.worldLocation);
    this.scale = vec3.clone(emitter.node.scale);
    this.color = vec4.create();
    this.index = 0;
}

MdxEventObjectUbr.prototype = {
    update(emitter) {
        var viewer = emitter.viewer;
        var dt = viewer.frameTime / 100;
        
        this.time = Math.min(this.time + dt, this.endTime);
        
        var time = this.time;
        var first = emitter.firstIntervalTime;
        var second = emitter.secondIntervalTime;
        var third = emitter.thirdIntervalTime;
        var tempFactor;
        var index;
        var color = this.color;
        
        if (time < first) {
            tempFactor = time / first;
            
            vec4.lerp(color, emitter.colors[0], emitter.colors[1], tempFactor);
        } else if (time < first + second) {
            vec4.copy(color, emitter.colors[1]);
        } else {
            tempFactor = (time - first - second) / third;
            
            vec4.lerp(color, emitter.colors[1], emitter.colors[2], tempFactor);
        }
    },
    
    updateHW: MdxEventObjectSpl.prototype.updateHW,    
    render: MdxEventObjectSpl.prototype.render,
    renderEmitters: MdxEventObjectSpl.prototype.renderEmitters,
    ended: MdxEventObjectSpl.prototype.ended
};
function MdxEventObjectEmitter(eventObject, model, instance, viewer, pathSolver) {
    var node = instance.skeleton.nodes[eventObject.node.index];
    var name = node.nodeImpl.name;
    var type = name.substring(0, 3);
    var path = name.substring(4);
    
    // No difference?
    if (type === "FPT") {
        type = "SPL";
    }
    
    this.model = model;
    this.instance = instance;
    this.type = type;
    this.node = node;
    this.globalSequenceId = eventObject.globalSequenceId;
    this.globalSequences = model.globalSequences;
    this.sequences = model.sequences;
    this.tracks = eventObject.tracks;
    this.lastTrack = vec3.create();
    this.eventObjects = [];
    this.viewer = viewer;
    this.pathSolver = pathSolver;

    this.id = path;

    // Load the appropriate SLK, and request it to call this emitter's setup function
    if (type === "SPN") {
        viewer.load("Splats/SpawnData.slk", pathSolver).requestSetup(this);
    } else if (type === "SPL") {
        viewer.load("Splats/SplatData.slk", pathSolver).requestSetup(this);
    } else if (type === "UBR") {
        viewer.load("Splats/UberSplatData.slk", pathSolver).requestSetup(this);
    }
    
    this.track = vec3.create();
}

MdxEventObjectEmitter.prototype = {
    setup(slk) {
        var row = slk.map[this.id];
        
        if (row) {
            var type = this.type;

            if (type === "SPN") {
                this.path = row.Model.replace(".mdl", ".mdx");
            } else if (type === "SPL") {
                // While every SLK row comes with the file, they all point to this texture, might as well just load it without checking
                this.texture = this.viewer.load("replaceabletextures/splats/splat01mature.blp", this.pathSolver);

                this.rows = row.Rows;
                this.columns = row.Columns;
                this.blendMode = row.BlendMode;
                this.scale = row.Scale;
                this.firstIntervalTime = row.Lifespan;
                this.secondIntervalTime = row.Decay;
                this.firstInterval = [row.UVLifespanStart, row.UVLifespanEnd, row.LifespanRepeat];
                this.secondInterval = [row.UVDecayStart, row.UVDecayEnd, row.DecayRepeat];
                this.colors = [[row.StartR, row.StartG, row.startB, row.startA], [row.MiddleR, row.MiddleG, row.MiddleB, row.MiddleA], [row.EndR, row.EndG, row.EndB, row.EndA]];

                this.dimensions = [this.columns, this.rows];

                
            } else {
                this.texture = this.viewer.load("replaceabletextures/splats/" + row.file + ".blp", this.pathSolver);
                this.blendMode = row.BlendMode;
                this.scale = row.Scale
                this.firstIntervalTime = row.BirthTime;
                this.secondIntervalTime = row.PauseTime;
                this.thirdIntervalTime = row.Decay;
                this.colors = [[row.StartR, row.StartG, row.startB, row.startA], [row.MiddleR, row.MiddleG, row.MiddleB, row.MiddleA], [row.EndR, row.EndG, row.EndB, row.EndA]];

                this.dimensions = [1, 1];
                this.columns = 1;
            }

            this.ready = true;
        } else {
            console.warn("[MdxEventObjectEmitter:setup] No valid SLK row");
        }
    },

    update(allowCreate, sequence, frame, counter, viewer) {
        if (this.ready) {
            var eventObjects = this.eventObjects;
            var eventObject;
            var track = this.getValue(sequence, frame, counter, this.track);
            
            if (track[0] === 1 && (track[0] !== this.lastTrack[0] || track[1] !== this.lastTrack[1])) {
                switch (this.type) {
                    case "SPN":
                        eventObject = new MdxEventObjectSpn(this);
                        break;
                    case "SPL":
                        eventObject = new MdxEventObjectSpl(this);
                        break;
                    case "UBR":
                        eventObject = new MdxEventObjectUbr(this);
                        break;
                }
                
                eventObjects.push(eventObject);
            }
            
            this.lastTrack[0] = track[0];
            this.lastTrack[1] = track[1];
            
            for (var i = 0, l = eventObjects.length; i < l; i++) {
                eventObjects[i].update(this);
            }
            
            if (eventObjects.length) {
                if (eventObjects[0].ended()) {
                    eventObjects.shift();
                }
            }
        }
    },

    render() {
        if (this.ready) {
            var eventObjects = this.eventObjects;
            
            for (var i = 0, l = eventObjects.length; i < l; i++) {
                eventObjects[i].render(this);
            }
        }
    },
    
    renderEmitters() {
        if (this.ready) {
            var eventObjects = this.eventObjects;
            
            for (var i = 0, l = eventObjects.length; i < l; i++) {
                eventObjects[i].renderEmitters(this);
            }
        }
    },
    
    getValue(sequence, frame, counter, out) {
        if (this.globalSequenceId !== -1 && this.globalSequences) {
            var duration = this.globalSequences[this.globalSequenceId];

            return this.getValueAtTime(counter % duration , 0, duration, out);
        } else if (sequence !== -1) {
            var interval = this.sequences[sequence].interval;

            return this.getValueAtTime(frame, interval[0], interval[1], out);
        } else {
            out[0] = 0;
            out[1] = 0;
            return out;
        }
    },
    
    getValueAtTime(frame, start, end, out) {
        var tracks = this.tracks;
        
        if (frame < start || frame > end) {
            out[0] = 0;
            out[1] = 0;
            return out;
        }
        
        for (var i = tracks.length - 1; i > -1; i--) {
            if (tracks[i] < start) {
                out[0] = 0;
                out[1] = i;
                return out;
            } else if (tracks[i] <= frame) {
                out[0] = 1;
                out[1] = i;
                return out;
            }
        }
        
        out[0] = 0;
        out[1] = 0;
        return out;
    }
};
function MdxParticle(emitter) {
    this.emitter = emitter;

    this.spawnedInstance = null;

    this.position = vec3.create();
    this.velocity = vec3.create();
    this.orientation = 0;
    this.gravity = 0;
}

MdxParticle.prototype = {
    reset() {
        const emitter = this.emitter;

        var scale = emitter.node.worldScale;
        var speed = emitter.getSpeed();
        var latitude = emitter.getLatitude();
        var longitude = emitter.getLongitude();
        var lifespan = emitter.getLifespan();
        var gravity = emitter.getGravity() * scale[2];
        var position = this.position;
        var worldMatrix = emitter.node.worldMatrix;

        this.alive = true;

        this.health = lifespan;

        vec3.transformMat4(position, emitter.node.pivot, emitter.node.worldMatrix);

        var velocity = emitter.heapVelocity;
        var rotation = emitter.heapMat;
        var velocityStart = emitter.heapVel1;
        var velocityEnd = vec3.heap;

        mat4.identity(rotation);
        mat4.rotateZ(rotation, rotation, Math.randomRange(-Math.PI, Math.PI));
        mat4.rotateY(rotation, rotation, Math.randomRange(-latitude, latitude));

        vec3.transformMat4(velocity, vec3.UNIT_Z, rotation);
        vec3.normalize(velocity, velocity);

        vec3.add(velocityEnd, position, velocity);

        vec3.transformMat4(velocityStart, position, worldMatrix);
        vec3.transformMat4(velocityEnd, velocityEnd, worldMatrix);

        vec3.subtract(velocity, velocityEnd, velocityStart);
        vec3.normalize(velocity, velocity);
        vec3.scale(velocity, velocity, speed);

        vec3.multiply(this.velocity, velocity, scale);

        this.orientation = Math.randomRange(0, Math.PI * 2);
        this.gravity = gravity;

        if (!this.spawnedInstance) {
            this.spawnedInstance = emitter.spawnModel.addInstance().setSequence(0);
        } else {
            this.spawnedInstance.rendered = true;
        }

        this.spawnedInstance.rotate(quat.setAxisAngle([], [0, 0, 1], this.orientation));
    },

    update() {
        if (this.alive) {
            const frameTimeS = this.spawnedInstance.env.frameTime * 0.001;

            this.health -= frameTimeS;

            this.velocity[2] -= this.gravity * frameTimeS;

            vec3.scaleAndAdd(this.position, this.position, this.velocity, frameTimeS);

            this.spawnedInstance.setLocation(this.position);
            this.spawnedInstance.setScale(this.emitter.node.worldScale);
        }
    },

    kill() {
        this.alive = false;
        this.spawnedInstance.rendered = false;
    }
};
function MdxParticleEmitter(instance, emitter) {
    const model = instance.model;

    var i, l;
    var keys = Object.keys(emitter);

    for (i = keys.length; i--;) {
        this[keys[i]] = emitter[keys[i]];
    }

    this.lastCreation = 0;

    var path = emitter.path.replace(/\\/g, "/").toLowerCase().replace(".mdl", ".mdx");

    this.instance = instance;
    this.spawnModel = model.env.load(path, model.pathSolver);

    this.node = instance.skeleton.nodes[emitter.node.index];
    this.sd = new MdxSdContainer(emitter.tracks, model);

    var particles;

    // This is the maximum number of particles that are going to exist at the same time
    if (emitter.tracks.emissionRate) {
        var tracks = emitter.tracks.emissionRate;
        var biggest = 0;

        for (i = 0, l = tracks.length; i < l; i++) {
            var track = tracks[i];

            if (track.vector > biggest) {
                biggest = track.vector;
            }
        }
        // For a reason I can't understand, biggest*lifespan isn't enough for emission rate tracks, multiplying by 2 seems to be the lowest reasonable value that works
        particles = Math.round(biggest * Math.ceil(emitter.lifespan) * 2);
    } else {
        particles = Math.round(emitter.emissionRate * Math.ceil(emitter.lifespan));
    }


    

    this.particles = [];
    this.reusables = [];

    for (let i = 0; i < particles; i++) {
        this.particles[i] = new MdxParticle(this);
        this.reusables.push(i);
    }
    

    // To avoid heap alocations
    this.heapVelocity = vec3.create();
    this.heapMat = mat4.create();
    this.heapVel1 = vec3.create();
    this.heapVel3 = vec3.create();
}

MdxParticleEmitter.prototype = {
    update(allowCreate) {
        const particles = this.particles,
            reusables = this.reusables;

        for (let i = 0, l = particles.length; i < l; i++) {
            const particle = particles[i];

            if (particle.alive) {
                if (particle.health <= 0) {
                    particle.kill();

                    reusables.push(i);
                } else {
                    particle.update();
                }
            }
        }

        if (allowCreate && this.shouldRender()) {
            this.lastCreation += 1;

            const amount = this.getEmissionRate() * this.instance.env.frameTime * 0.001 * this.lastCreation;

            if (amount >= 1) {
                this.lastCreation = 0;

                for (let i = 0; i < amount; i++) {
                    if (reusables.length > 0) {
                        particles[reusables.pop()].reset();
                    }
                }
            }
        }
    },

    render() {
        
    },

    shouldRender() {
        return this.getVisibility(this.instance) > 0.75;
    },

    getSpeed() {
        return this.sd.getKPESValue(this.instance, this.speed);
    },

    getLatitude() {
        return this.sd.getKPLTValue(this.instance, this.latitude);
    },

    getLongitude() {
        return this.sd.getKPLNValue(this.instance, this.longitude);
    },

    getLifespan() {
        return this.sd.getKPELValue(this.instance, this.lifespan);
    },

    getGravity() {
        return this.sd.getKPEGValue(this.instance, this.gravity);
    },

    getEmissionRate() {
        return this.sd.getKPEEValue(this.instance, this.emissionRate);
    },

    getVisibility() {
        return this.sd.getKPEVValue(this.instance, 1);
    }
};
function MdxParticle2() {
    this.id = 0;
    this.health = 0;
    this.head = true;
    this.position = [];
    this.worldLocation = [];
    this.velocity = [];
    this.color = [];
    this.gravity = 0;
    this.scale = 1;
    this.index = 0;
}

MdxParticle2.prototype = {
    reset(emitter, head, id, instance) {
        const node = instance.skeleton.nodes[emitter.node.index];

        var pivot = node.pivot;
        var worldMatrix = node.worldMatrix;
        var scale = node.worldScale;
        var width = emitter.getWidth(instance) * 0.5;
        var length = emitter.getLength(instance) * 0.5;
        var speed = emitter.getSpeed(instance) + Math.randomRange(-emitter.variation, emitter.variation);
        var latitude = Math.toRad(emitter.getLatitude(instance));
        var gravity = emitter.getGravity(instance) * scale[2];
        var color = emitter.colors[0];
        var localPosition = emitter.particleLocalPosition;
        var position = emitter.particlePosition;
        var rotation = emitter.particleRotation;
        var velocity = emitter.particleVelocity;
        var velocityStart = emitter.particleVelocityStart;
        var velocityEnd = emitter.particleVelocityEnd;
        var modelSpace = emitter.modelSpace;
        
        localPosition[0] = pivot[0] + Math.randomRange(-width, width);
        localPosition[1] = pivot[1] + Math.randomRange(-length, length);
        localPosition[2] = pivot[2];
        
        if (modelSpace) {
            vec3.copy(position, localPosition);
        } else {
            vec3.transformMat4(position, localPosition, worldMatrix);
        }
        
        mat4.identity(rotation);
        mat4.rotateZ(rotation, rotation, Math.randomRange(-Math.PI, Math.PI));
        mat4.rotateY(rotation, rotation, Math.randomRange(-latitude, latitude));

        vec3.transformMat4(velocity, vec3.UNIT_Z, rotation);
        vec3.normalize(velocity, velocity);
        
        if (emitter.modelSpace) {
            vec3.scale(velocity, velocity, speed);
        } else {
            vec3.add(velocityEnd, position, velocity);

            vec3.transformMat4(velocityStart, position, worldMatrix);
            vec3.transformMat4(velocityEnd, velocityEnd, worldMatrix);

            vec3.subtract(velocity, velocityEnd, velocityStart);
            vec3.normalize(velocity, velocity);
            vec3.scale(velocity, velocity, speed);
        }
        
        if (!head) {
            var tailLength = emitter.tailLength * 0.5;

            vec3.scaleAndAdd(position, velocity, -tailLength);
        }

        this.node = node;
        this.id = id;
        this.health = emitter.lifespan;
        this.head = head;

        vec3.copy(this.position, position);
        vec3.multiply(this.velocity, velocity, scale);
        vec4.copy(this.color, color);

        this.gravity = gravity;
        this.scale = 1;
        this.index = 0;
    },

    update(emitter) {
        var dt = emitter.model.env.frameTime * 0.001;
        var position = this.position;

        this.health -= dt;
        this.velocity[2] -= this.gravity * dt;
        
        vec3.scaleAndAdd(position, position, this.velocity, dt);
        
        if (emitter.modelSpace) {
            vec3.transformMat4(this.worldLocation, position, this.node.worldMatrix);
        } else {
            vec3.copy(this.worldLocation, position);
        }
        
        var lifeFactor = (emitter.lifespan - this.health) / emitter.lifespan;
        var tempFactor;
        var scale;
        var index;
        
        if (lifeFactor < emitter.timeMiddle) {
            tempFactor = lifeFactor / emitter.timeMiddle;
        
            scale = Math.lerp(emitter.segmentScaling[0], emitter.segmentScaling[1], tempFactor);
            vec4.lerp(this.color, emitter.colors[0], emitter.colors[1], tempFactor);
            
            if (this.head) {
                index = Math.lerp(emitter.headInterval[0], emitter.headInterval[1], tempFactor);
            } else {
                index = Math.lerp(emitter.tailInterval[0], emitter.tailInterval[1], tempFactor);
            }
        } else {
            tempFactor = (lifeFactor - emitter.timeMiddle) / (1 - emitter.timeMiddle);
            
            scale = Math.lerp(emitter.segmentScaling[1], emitter.segmentScaling[2], tempFactor);
            vec4.lerp(this.color, emitter.colors[1], emitter.colors[2], tempFactor);
            
            if (this.head) {
                index = Math.lerp(emitter.headDecayInterval[0], emitter.headDecayInterval[1], tempFactor);
            } else {
                index = Math.lerp(emitter.tailDecayInterval[0], emitter.tailDecayInterval[1], tempFactor);
            }
        }

        this.index = Math.floor(index);
        this.scale = scale;
    }
};
function MdxParticleEmitter2(emitter, model) {
    let gl = model.env.gl;

    mix(this, emitter);

    this.model = model;

    this.head = (this.headOrTail === 0 || this.headOrTail === 2);
    this.tail = (this.headOrTail === 1 || this.headOrTail === 2);
    this.particlesPerEmit = (this.headOrTail === 2) ? 2 : 1;

    this.bytesPerParticle = 4 * 30; // 30 floats per particle

    this.buffer = new ResizeableBuffer(gl);

    this.particles = [];
    this.openSlots = [];
    this.activeSlots = [];
    this.currentSlot = 0;

    this.cellWidth = 1 / this.columns;
    this.cellHeight = 1 / this.rows;
    this.colors = [];

    var colors = this.segmentColor;
    var alpha = this.segmentAlpha;

    for (let i = 0; i < 3; i++) {
        this.colors[i] = [Math.floor(colors[i][0] * 255), Math.floor(colors[i][1] * 255), Math.floor(colors[i][2] * 255), alpha[i]];
    }

    let modelNode = this.model.nodes[this.node.index];
    this.xYQuad = modelNode.xYQuad;
    this.modelSpace = modelNode.modelSpace;

    this.sd = new MdxSdContainer(emitter.tracks, model);

    // Avoid heap alocations in Particle2.reset
    this.particleLocalPosition = vec3.create();
    this.particlePosition = vec3.create();
    this.particleRotation = mat4.create();
    this.particleVelocity = vec3.create();
    this.particleVelocityStart = vec3.create();
    this.particleVelocityEnd = vec3.create();
    

    this.dimensions = [this.columns, this.rows];
    
    this.currentEmission = 0;

    let blendSrc, blendDst;

    switch (this.filterMode) {
        // Blend
        case 0:
            blendSrc = gl.SRC_ALPHA;
            blendDst = gl.ONE_MINUS_SRC_ALPHA;
            break;
            // Additive
        case 1:
            blendSrc = gl.SRC_ALPHA;
            blendDst = gl.ONE;
            break;
            // Modulate
        case 2:
            blendSrc = gl.ZERO;
            blendDst = gl.SRC_COLOR;
            break;
            // Modulate 2X
        case 3:
            blendSrc = gl.DEST_COLOR;
            blendDst = gl.SRC_COLOR;
            break;
            // Add Alpha
        case 4:
            blendSrc = gl.SRC_ALPHA;
            blendDst = gl.ONE;
            break;
    }

    this.blendSrc = blendSrc;
    this.blendDst = blendDst;
}

MdxParticleEmitter2.prototype = {
    emitParticle(isHead, instance) {
        let particles = this.particles,
            openSlots = this.openSlots,
            activeSlots = this.activeSlots,
            size = (activeSlots.length + this.particlesPerEmit) * this.bytesPerParticle;

        if (this.buffer.byteLength < size) {
            this.buffer.resize(size);
        }

        if (openSlots.length) {
            const index = openSlots.pop();

            particles[index].reset(this, isHead, index, instance);
            activeSlots.push(index);
        } else {
            const particle = new MdxParticle2();

            particle.reset(this, isHead, this.currentSlot, instance);
            activeSlots.push(this.currentSlot);

            particles[this.currentSlot] = particle;
            this.currentSlot += 1;
        }
    },

    emit(instance) {
        if (this.head) {
            this.emitParticle(true, instance);
        }

        if (this.tail) {
            this.emitParticle(false, instance);
        }
    },

    update() {
        var particles = this.particles;
        var openSlots = this.openSlots;
        var activeSlots = this.activeSlots;
        var activeParticlesCount = activeSlots.length;
        var i, l;
        var particle;

        if (activeSlots.length > 0) {
            // First stage: remove dead particles.
            // The used particles array is a queue, dead particles will always come first.
            // As of the time of writing, the easiest and fastest way to implement a queue in Javascript is a normal array.
            // To add items, you push, to remove items, the array is reversed and you pop.
            // So the first stage reverses the array, and then keeps checking the last element for its health.
            // As long as we hit a dead particle, pop, and check the new last element.

            // Ready for pop mode
            activeSlots.reverse();

            particle = particles[activeSlots[activeSlots.length - 1]];
            while (particle && particle.health <= 0) {
                activeSlots.pop();
                this.openSlots.push(particle.id);

                // Need to recalculate the length each time
                particle = particles[activeSlots[activeSlots.length - 1]];
            }

            // Ready for push mode
            activeSlots.reverse()

            // Second stage: update the living particles.
            // All the dead particles were removed, so a simple loop is all that's required.
            for (i = 0, l = activeSlots.length; i < l; i++) {
                particle = particles[activeSlots[i]];

                particle.update(this);
            }

            this.updateHW();
        }
    },

    updateHW() {
        var activeSlots = this.activeSlots;
        var data = this.buffer.float32array;
        var particles = this.particles;
        var columns = this.columns;
        var particle, index, position, color;
        var pv1, pv2, pv3, pv4, csx, csy, csz;
        var rect;

        /// NOTE: This needs to change when/if I make particle emitters per-model-view as planned.
        let camera = this.model.env.scenes[0].camera;

        // Choose between a default rectangle or billboarded one
        if (this.xYQuad) {
            rect = camera.vectors;
        } else {
            rect = camera.billboardedVectors;
        }

        pv1 = rect[0];
        pv2 = rect[1];
        pv3 = rect[2];
        pv4 = rect[3];
        csx = rect[4];
        csy = rect[5];
        csz = rect[6];

        var scale, textureIndex, left, top, right, bottom, r, g, b, a, px, py, pz;
        var v1x, v1y, v1z, v2x, v2y, v2z, v3x, v3y, v3z, v4x, v4y, v4z;
        var lta, lba, rta, rba, rgb;

        for (var i = 0, l = activeSlots.length; i < l; i++) {
            particle = particles[activeSlots[i]];

            const node = particle.node,
                nodeScale = node.worldScale;

            index = i * 30;
            position = particle.worldLocation;
            scale = particle.scale;
            textureIndex = particle.index;
            left = textureIndex % columns;
            top = Math.floor(textureIndex / columns);
            right = left + 1;
            bottom = top + 1;
            color = particle.color;
            r = Math.floor(color[0]);
            g = Math.floor(color[1]);
            b = Math.floor(color[2]);
            a = Math.floor(color[3]);
            px = position[0];
            py = position[1];
            pz = position[2];

            if (particle.head) {
                v1x = px + pv1[0] * scale * nodeScale[0];
                v1y = py + pv1[1] * scale * nodeScale[1];
                v1z = pz + pv1[2] * scale * nodeScale[2];
                v2x = px + pv2[0] * scale * nodeScale[0];
                v2y = py + pv2[1] * scale * nodeScale[1];
                v2z = pz + pv2[2] * scale * nodeScale[2];
                v3x = px + pv3[0] * scale * nodeScale[0];
                v3y = py + pv3[1] * scale * nodeScale[1];
                v3z = pz + pv3[2] * scale * nodeScale[2];
                v4x = px + pv4[0] * scale * nodeScale[0];
                v4y = py + pv4[1] * scale * nodeScale[1];
                v4z = pz + pv4[2] * scale * nodeScale[2];
            } else {
                var tailLength = this.tailLength;
                var v = particle.velocity;
                var offsetx = tailLength * v[0];
                var offsety = tailLength * v[1];
                var offsetz = tailLength * v[2];

                var px2 = px + offsetx;
                var py2 = py + offsety;
                var pz2 = pz + offsetz;

                px -= offsetx;
                py -= offsety;
                pz -= offsetz;
                /*
                v1x = px2 - csx[0] * scale + csz[0] * scale;
                v1y = py2 - csx[1] * scale + csz[1] * scale;
                v1z = pz2 - csx[2] * scale + csz[2] * scale;

                v2x = px - csx[0] * scale - csz[0] * scale;
                v2y = py - csx[1] * scale - csz[1] * scale;
                v2z = pz - csx[2] * scale - csz[2] * scale;
                v3x = px + csx[0] * scale - csz[0] * scale;
                v3y = py + csx[1] * scale - csz[1] * scale;
                v3z = pz + csx[2] * scale - csz[2] * scale;
                v4x = px2 + csx[0] * scale + csz[0] * scale;
                v4y = py2 + csx[1] * scale + csz[1] * scale;
                v4z = pz2 + csx[2] * scale + csz[2] * scale;
                */
                v1x = px2 - csx[0] * scale * nodeScale[0];
                v1y = py2 - csx[1] * scale * nodeScale[1];
                v1z = pz2 - csx[2] * scale * nodeScale[2];

                v2x = px - csx[0] * scale * nodeScale[0];
                v2y = py - csx[1] * scale * nodeScale[1];
                v2z = pz - csx[2] * scale * nodeScale[2];

                v3x = px + csx[0] * scale * nodeScale[0];
                v3y = py + csx[1] * scale * nodeScale[1];
                v3z = pz + csx[2] * scale * nodeScale[2];

                v4x = px2 + csx[0] * scale * nodeScale[0];
                v4y = py2 + csx[1] * scale * nodeScale[1];
                v4z = pz2 + csx[2] * scale * nodeScale[2];
            }

            lta = encodeFloat3(left, top, a);
            lba = encodeFloat3(left, bottom, a);
            rta = encodeFloat3(right, top, a);
            rba = encodeFloat3(right, bottom, a);
            rgb = encodeFloat3(r, g, b);

            data[index + 0] = v1x;
            data[index + 1] = v1y;
            data[index + 2] = v1z;
            data[index + 3] = lta;
            data[index + 4] = rgb;

            data[index + 5] = v2x;
            data[index + 6] = v2y;
            data[index + 7] = v2z;
            data[index + 8] = lba;
            data[index + 9] = rgb;

            data[index + 10] = v3x;
            data[index + 11] = v3y;
            data[index + 12] = v3z;
            data[index + 13] = rba;
            data[index + 14] = rgb;

            data[index + 15] = v1x;
            data[index + 16] = v1y;
            data[index + 17] = v1z;
            data[index + 18] = lta;
            data[index + 19] = rgb;

            data[index + 20] = v3x;
            data[index + 21] = v3y;
            data[index + 22] = v3z;
            data[index + 23] = rba;
            data[index + 24] = rgb;

            data[index + 25] = v4x;
            data[index + 26] = v4y;
            data[index + 27] = v4z;
            data[index + 28] = rta;
            data[index + 29] = rgb;
        }
    },

    render(shader, modelView) {
        var gl = this.model.env.gl;
        var particles = this.activeSlots.length;

        if (particles > 0) {
            gl.disable(gl.CULL_FACE);
            gl.enable(gl.DEPTH_TEST);
            gl.depthMask(0);
            gl.enable(gl.BLEND);
            gl.blendFunc(this.blendSrc, this.blendDst);

            this.updateHW();

            gl.uniform2fv(shader.uniforms.get("u_dimensions"), this.dimensions);



            /// NOTE TO SELF: ALL OF THE RENDERING CODE BELOW NEEDS TO BE IN A PER-MODEL-VIEW LOOP
            /// That means:
            ///     Layer 1: Model emitter = Parser emiter (metadata)
            ///              Can run the rendering-related code above if I can make it in a non-messy way. No big deal if it runs per view.
            ///     Layer 2: Particle2Emitter in ModelView
            ///              Runs the code below, since each view has its own texture, and thus requires a separate draw call.
            ///     Layer 3: Particle2EmitterView in ModelInstance
            ///              Emits particles via the emitters as usual.


            this.model.bindTexture(this.textureId, modelView);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer.buffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.buffer.float32array.subarray(0, particles * 30));

            //console.log(particles * 30, this.resizeableBuffer.float32array.length)
            gl.vertexAttribPointer(shader.attribs.get("a_position"), 3, gl.FLOAT, false, 20, 0);
            gl.vertexAttribPointer(shader.attribs.get("a_uva_rgb"), 2, gl.FLOAT, false, 20, 12);

            gl.drawArrays(gl.TRIANGLES, 0, particles * 6);
        }
    },

    shouldRender(instance) {
        return this.getVisibility(instance) > 0.75;
    },

    getWidth(instance) {
        return this.sd.getKP2WValue(instance, this.width);
    },

    getLength(instance) {
        return this.sd.getKP2NValue(instance, this.length);
    },

    getSpeed(instance) {
        return this.sd.getKP2SValue(instance, this.speed);
    },

    getLatitude(instance) {
        return this.sd.getKP2LValue(instance, this.latitude);
    },

    getGravity(instance) {
        return this.sd.getKP2GValue(instance, this.gravity);
    },

    getEmissionRate(instance) {
        return this.sd.getKP2EValue(instance, this.emissionRate);
    },

    getVisibility(instance) {
        return this.sd.getKP2VValue(instance, 1);
    }

    //getVariation(sequence, frame, counter) {
    //    return this.sd.getKP2R(sequence, frame, counter, ?);
    //}
};
function MdxParticleEmitter2View(instance, emitter) {
    this.instance = instance;
    this.emitter = emitter;
    this.currentEmission = 0;
}

MdxParticleEmitter2View.prototype = {
    update(allowCreate) {
        if (allowCreate && this.shouldRender()) {
            let emitter = this.emitter;

            this.currentEmission += this.getEmissionRate() * this.instance.model.env.frameTime * 0.001;

            if (this.currentEmission >= 1) {
                for (let i = 0, l = Math.floor(this.currentEmission); i < l; i++) {
                    emitter.emit(this.instance);

                    this.currentEmission -= 1;
                }
            }
        }
    },

    shouldRender() {
        return this.getVisibility() > 0.75;
    },

    getWidth() {
        return this.emitter.getWidth(this.instance);
    },

    getLength() {
        return this.emitter.getLength(this.instance);
    },

    getSpeed() {
        return this.emitter.getSpeed(this.instance);
    },

    getLatitude() {
        return this.emitter.getLatitude(this.instance);
    },

    getGravity() {
        return this.emitter.getGravity(this.instance);
    },

    getEmissionRate() {
        return this.emitter.getEmissionRate(this.instance);
    },

    getVisibility() {
        return this.emitter.getVisibility(this.instance);
    }

    //getVariation(sequence, frame, counter) {
    //    return this.sd.getKP2R(sequence, frame, counter, ?);
    //}
};
function MdxRibbon() {
    this.location = vec3.create();
    this.health = 0;
    this.p1 = vec3.create();
    this.p2 = vec3.create();
    this.lastRibbon = null;
}

MdxRibbon.prototype = {
    reset(emitter, view, slot) {
        let instance = view.instance,
            node = instance.skeleton.nodes[emitter.node.index],
            location = node.pivot,
            p1 = this.p1,
            p2 = this.p2;

        p1[0] = location[0];
        p1[1] = location[1] - emitter.getHeightBelow(instance);
        p1[2] = location[2];
        vec3.transformMat4(p1, p1, node.worldMatrix);

        p2[0] = location[0];
        p2[1] = location[1] + emitter.getHeightAbove(instance);
        p2[2] = location[2];
        vec3.transformMat4(p2, p2, node.worldMatrix);

        this.view = view;
        this.lastRibbon = view.lastRibbon;
        this.health = emitter.lifespan;
        this.slot = slot;

        view.activeRibbons += 1;
    },

    update(emitter) {
        let dt = emitter.model.env.frameTime * 0.001,
            zvelocity = emitter.gravity * dt * dt;

        this.health -= dt;
        this.p1[2] -= zvelocity;
        this.p2[2] -= zvelocity;
    },

    kill() {
        this.view.activeRibbons -= 1;
    }
};
function MdxRibbonEmitter(emitter, model) {
    let gl = model.env.gl;

    mix(this, emitter);

    this.model = model;

    this.lastCreation = 0;
    this.ribbons = [];
    this.openSlots = [];
    this.activeSlots = [];
    this.currentSlot = 0;

    this.buffer = new ResizeableBuffer(gl);

    this.cellWidth = 1 / this.columns;
    this.cellHeight = 1 / this.rows;

    this.layers = model.materials[this.materialId];

    this.sd = new MdxSdContainer(emitter.tracks, model);

    // Avoid heap allocations
    this.colorVec = vec3.create();
    this.modifierVec = vec4.create();
    this.uvoffsetVec = vec3.create();
    this.defaultUvoffsetVec = vec3.fromValues(0, 0, 0);
}

MdxRibbonEmitter.prototype = {
    emit(view) {
        let ribbons = this.ribbons,
            openSlots = this.openSlots,
            activeSlots = this.activeSlots;

        if (this.buffer.float32array.length < (activeSlots.length + this.particlesPerEmit) * 30) {
            this.buffer.resize((activeSlots.length + this.particlesPerEmit) * this.bytesPerParticle);
        }

        if (openSlots.length) {
            const slot = openSlots.pop();

            ribbons[slot].reset(this, view, slot);
            activeSlots.push(slot);

            return ribbons[slot];
        } else {
            const ribbon = new MdxRibbon();

            ribbon.reset(this, view, this.currentSlot);
            activeSlots.push(this.currentSlot);

            ribbons[this.currentSlot] = ribbon;
            this.currentSlot += 1;

            return ribbon;
        }
    },

    update() {
        var ribbons = this.ribbons;
        var openSlots = this.openSlots;
        var activeSlots = this.activeSlots;
        var activeParticlesCount = activeSlots.length;
        var i, l;
        var ribbon;

        if (activeSlots.length > 0) {
            // First stage: remove dead particles.
            // The used particles array is a queue, dead particles will always come first.
            // As of the time of writing, the easiest and fastest way to implement a queue in Javascript is a normal array.
            // To add items, you push, to remove items, the array is reversed and you pop.
            // So the first stage reverses the array, and then keeps checking the last element for its health.
            // As long as we hit a dead particle, pop, and check the new last element.

            // Ready for pop mode
            activeSlots.reverse();

            ribbon = ribbons[activeSlots[activeSlots.length - 1]];
            while (ribbon && ribbon.health <= 0) {
                activeSlots.pop();
                this.openSlots.push(ribbon.slot);

                ribbon.kill();

                // Need to recalculate the length each time
                ribbon = ribbons[activeSlots[activeSlots.length - 1]];
            }

            // Ready for push mode
            activeSlots.reverse()

            // Second stage: update the living ribbons.
            // All the dead ribbons were removed, so a simple loop is all that's required.
            for (i = 0, l = activeSlots.length; i < l; i++) {
                ribbons[activeSlots[i]].update(this);
            }

            //this.updateHW();
        }
    },

    render(sequence, frame, counter, textureMap, shader, viewer) {
        var ctx = viewer.gl.ctx;
        var i, l;
        var ribbonCount = Math.min(this.ribbons.length, this.maxRibbons);

        if (ribbonCount > 2) {
            var textureSlot = this.getTextureSlot(sequence, frame, counter);
            //var uvOffsetX = (textureSlot % this.columns) / this.columns;
            var uvOffsetY = Math.floor(textureSlot / this.rows) / this.rows;
            var uvFactor = 1 / ribbonCount * this.cellWidth;
            var top = uvOffsetY;
            var bottom = uvOffsetY + this.cellHeight;
            var data = this.emitter.data;
            var index, ribbon, left, right, v1, v2;
            var quads = 0;

            let ribbons = this.ribbons;

            for (i = 0; i < ribbonCount; i++) {
                let ribbon = ribbons[i],
                    lastRibbon = ribbon.lastRibbon;

                // Only add a quad if this isn't the first ribbon of a chain
                if (lastRibbon) {
                    let index = quads * 20,
                        left = (ribbonCount - i) * uvFactor,
                        right = left - uvFactor,
                        v1 = ribbon.p2,
                        v2 = ribbon.p1;

                    data[index + 0] = v1[0];
                    data[index + 1] = v1[1];
                    data[index + 2] = v1[2];
                    data[index + 3] = left;
                    data[index + 4] = top;

                    data[index + 5] = v2[0];
                    data[index + 6] = v2[1];
                    data[index + 7] = v2[2];
                    data[index + 8] = right;
                    data[index + 9] = bottom;
                }
            }

            ctx.bindBuffer(ctx.ARRAY_BUFFER, this.emitter.buffer);
            ctx.bufferSubData(ctx.ARRAY_BUFFER, 0, this.emitter.data);

            ctx.vertexAttribPointer(shader.variables.a_position, 3, ctx.FLOAT, false, 20, 0);
            ctx.vertexAttribPointer(shader.variables.a_uv, 2, ctx.FLOAT, false, 20, 12);

            var textureId, color, uvoffset, modifier = this.modifierVec;
            var layer, layers = this.layers;
            
            for (i = 0, l = layers.length; i < l; i++) {
                layer = layers[i].layer;

                layer.bind(shader, ctx);

                textureId = layer.getTextureId(sequence, frame, counter);

                this.model.bindTexture(this.textures[textureId], textureMap[this.model.texturePaths[textureId]], viewer);

                color = this.getColor(sequence, frame, counter);
                uvoffset = this.defaultUvoffsetVec;

                modifier[0] = color[0];
                modifier[1] = color[1];
                modifier[2] = color[2];
                modifier[3] = this.getAlpha(sequence, frame, counter);

                ctx.uniform4fv(shader.variables.u_modifier, modifier);

                if (layer.textureAnimationId !== -1 && this.model.textureAnimations) {
                    var textureAnimation = this.model.textureAnimations[layer.textureAnimationId];
                    // What is Z used for?
                    uvoffset = textureAnimation.getTranslation(sequence, frame, counter);
                }

                ctx.uniform3fv(shader.variables.u_uv_offset, uvoffset);

                ctx.drawArrays(ctx.TRIANGLE_STRIP, 0, ribbonCount * 2);

                layer.unbind(shader, ctx);
            }
        }
    },

    shouldRender(instance) {
        return this.getVisibility(instance) > 0.75;
    },

    getHeightBelow(instance) {
        return this.sd.getKRHBValue(instance, this.heightBelow);
    },

    getHeightAbove(instance) {
        return this.sd.getKRHAValue(instance, this.heightAbove);
    },

    getTextureSlot(instance) {
        return this.sd.getKRTXValue(instance, 0);
    },

    getColor(instance) {
        return this.sd.getKRCOValue(instance, this.color);
    },

    getAlpha(instance) {
        return this.sd.getKRALValue(instance, this.alpha);
    },

    getVisibility(instance) {
        return this.sd.getKRVSValue(instance, 1);
    }
};
function MdxRibbonEmitterView(instance, emitter) {
    this.instance = instance;
    this.emitter = emitter;
    this.currentEmission = 0;
    this.lastRibbon = null;
    this.activeRibbons = 0;
}

MdxRibbonEmitterView.prototype = {
    update(allowCreate) {
        /*
        if (allowCreate && this.shouldRender(instance)) {
            this.lastCreation += 1;

            var amount = this.emissionRate * viewer.frameTime * 0.001 * this.lastCreation;

            if (amount >= 1) {
                this.lastCreation = 0;

                for (i = 0; i < amount; i++) {
                    this.ribbons.push(new MdxRibbon(this, instance));
                }
            }
        }
        */

        if (allowCreate && this.shouldRender()) {
            let emitter = this.emitter;

            this.currentEmission += emitter.emissionRate * this.instance.model.env.frameTime * 0.001;

            if (this.currentEmission >= 1) {
                for (let i = 0, l = Math.floor(this.currentEmission); i < l; i++) {
                    this.lastRibbon = emitter.emit(this);

                    this.currentEmission -= 1;
                }
            }
        }
    },

    shouldRender() {
        return this.getVisibility(this.instance) > 0.75;
    },

    getHeightBelow() {
        return this.emitter.getHeightBelow(this.instance);
    },

    getHeightAbove() {
        return this.emitter.getHeightAbove(this.instance);
    },

    getTextureSlot() {
        return this.emitter.getTextureSlot(this.instance);
    },

    getColor() {
        return this.emitter.getColor(this.instance);
    },

    getAlpha() {
        return this.emitter.getAlpha(this.instance);
    },

    getVisibility() {
        return this.emitter.getVisibility(this.instance);
    }
};
/**
 * @class
 * @classdesc An MDX bucket.
 * @extends Bucket
 * @memberOf Mdx
 * @param {MdxModelView} env The model view that this bucket belongs to.
 */
function MdxBucket(modelView) {
    Bucket.call(this, modelView);

    const model = this.model;
    const env = model.env;
    const gl = env.gl;

    this.env = env;

    // POT required because for some reason, on some drivers, NPOT makes rendering go crazy.
    var numberOfBones = Math.powerOfTwo(model.bones.length + 1);

    this.boneArrayInstanceSize = numberOfBones * 16;
    this.boneArray = new Float32Array(this.boneArrayInstanceSize * this.size);

    this.updateBoneTexture = new Uint8Array([1]);
    this.boneTexture = gl.createTexture();
    this.boneTextureWidth = numberOfBones * 4;
    this.boneTextureHeight = this.size;
    this.vectorSize = 1 / this.boneTextureWidth;
    this.rowSize = 1 / this.boneTextureHeight;

    gl.activeTexture(gl.TEXTURE15);
    gl.bindTexture(gl.TEXTURE_2D, this.boneTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.boneTextureWidth, this.boneTextureHeight, 0, gl.RGBA, gl.FLOAT, null);

    // Team colors (per instance)
    this.updateTeamColors = new Uint8Array(1);
    this.teamColorArray = new Uint8Array(this.size);
    this.teamColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.teamColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.teamColorArray, gl.DYNAMIC_DRAW);

    // Tint color (per instance)
    this.updateTintColors = new Uint8Array(1);
    this.tintColorArray = new Uint8Array(3 * this.size).fill(255); // Tint color initialized to white
    this.tintColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.tintColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.tintColorArray, gl.DYNAMIC_DRAW);

    // Batch visibility (per instance per batch)
    this.updateBatches = new Uint8Array(model.batches.length);
    this.batchVisibilityArrays = [];
    this.batchVisibilityBuffers = [];

    // Geoset colors (per instance per batch)
    // While the RGB color is per-geoset, the alpha is per-layer, so I'll just keep it per-batch meanwhile
    /// ------------------
    /// TODO: Split the RGB and A channels, this will allow far less writing
    /// -----------------
    this.geosetColorArrays = [];
    this.geosetColorBuffers = [];

    // Texture coordinate animations (per instance per layer)
    this.updateUvOffsets = new Uint8Array(1);
    this.uvOffsetArrays = [];
    this.uvOffsetBuffers = [];

    if (model.batches.length) {
        for (var i = 0, l = model.batches.length; i < l; i++) {
            this.batchVisibilityArrays[i] = new Uint8Array(this.size);
            this.batchVisibilityBuffers[i] = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.batchVisibilityBuffers[i]);
            gl.bufferData(gl.ARRAY_BUFFER, this.batchVisibilityArrays[i], gl.DYNAMIC_DRAW);

            this.geosetColorArrays[i] = new Uint8Array(4 * this.size).fill(255); // Geoset colors are initialized to white
            this.geosetColorBuffers[i] = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.geosetColorBuffers[i]);
            gl.bufferData(gl.ARRAY_BUFFER, this.geosetColorArrays[i], gl.DYNAMIC_DRAW);
        }

        for (var i = 0, l = model.layers.length; i < l; i++) {
            this.uvOffsetArrays[i] = new Float32Array(4 * this.size);
            this.uvOffsetBuffers[i] = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.uvOffsetBuffers[i]);
            gl.bufferData(gl.ARRAY_BUFFER, this.uvOffsetArrays[i], gl.DYNAMIC_DRAW);
        }
    }
}

MdxBucket.prototype = {
    update() {
        const gl = this.env.gl,
            size = this.instances.length;

        this.updateBatches.fill(0);

        Bucket.prototype.update.call(this);

        if (this.updateBoneTexture[0]) {
            gl.activeTexture(gl.TEXTURE15);
            gl.bindTexture(gl.TEXTURE_2D, this.boneTexture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.boneTextureWidth, size, gl.RGBA, gl.FLOAT, this.boneArray);

            this.updateBoneTexture[0] = 0;
        }

        if (this.updateTeamColors[0]) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.teamColorBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.teamColorArray.subarray(0, size));

            this.updateTeamColors[0] = 0;
        }

        if (this.updateTintColors[0]) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.tintColorBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.tintColorArray.subarray(0, 3 * size));

            this.updateTintColors[0] = 0;
        }

        for (var i = 0, l = this.batchVisibilityArrays.length; i < l; i++) {
            //if (this.updateBatches[i]) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.batchVisibilityBuffers[i]);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.batchVisibilityArrays[i].subarray(0, size));

                gl.bindBuffer(gl.ARRAY_BUFFER, this.geosetColorBuffers[i]);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.geosetColorArrays[i].subarray(0, 4 * size));
            //}
        }

        //console.log(this.batchVisibilityArrays)

        if (this.updateUvOffsets[0]) {
            for (var i = 0, l = this.uvOffsetArrays.length; i < l; i++) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.uvOffsetBuffers[i]);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.uvOffsetArrays[i].subarray(0, 4 * size));
            }

            this.updateUvOffsets[0] = 0;
        }
    },

    getSharedData(index) {
        var data = {
            bucket: this,
            boneArray: new Float32Array(this.boneArray.buffer, this.boneArrayInstanceSize * 4 * index, this.boneArrayInstanceSize),
            geosetColorArrays: [],
            uvOffsetArrays: [],
            teamColorArray: new Uint8Array(this.teamColorArray.buffer, index, 1),
            tintColorArray: new Uint8Array(this.tintColorArray.buffer, 3 * index, 3),
            batchVisibilityArrays: []
        };

        for (var i = 0, l = this.batchVisibilityArrays.length; i < l; i++) {
            data.batchVisibilityArrays[i] = new Uint8Array(this.batchVisibilityArrays[i].buffer, index, 1);
            data.geosetColorArrays[i] = new Uint8Array(this.geosetColorArrays[i].buffer, 4 * index, 4);
        }

        for (var i = 0, l = this.uvOffsetArrays.length; i < l; i++) {
            data.uvOffsetArrays[i] = new Float32Array(this.uvOffsetArrays[i].buffer, 4 * 4 * index, 4);
        }

        return data;
    }
};

mix(MdxBucket.prototype, Bucket.prototype);
/**
 * @class
 * @classdesc An MDX model view.
 * @extends ModelView
 * @memberOf Mdx
 * @param {MdxModel} model The model that this view belongs to.
 */
function MdxModelView(model) {
    ModelView.call(this, model);

    /** @member {Texture[]} */
    this.textures = [];
}

mix(MdxModelView.prototype, ModelView.prototype);
/**
 * @class
 * @classdesc A Warcraft 3 model.
 * @extends Model
 * @memberOf Mdx
 * @param {ModelViewer} env The model viewer object that this texture belongs to.
 * @param {function} pathSolver A function that solves paths. See more {@link PathSolver here}.
 */
function MdxModel(env, pathSolver) {
    Model.call(this, env, pathSolver);
}

MdxModel.prototype = {
    get Handler() {
        return Mdx;
    },

    initialize(src) {
        var parser = MdxParser(new BinaryReader(src));

        if (!parser) {
            this.onerror("InvalidSource", "WrongMagicNumber");
            return false;
        }

        var objects, i, l, j, k;
        var chunks = parser.chunks;

        this.parser = parser;
        this.name = chunks.MODL.name;
        this.sequences = [];
        this.textures = [];
        this.geosets = [];
        this.cameras = [];
        this.particleEmitters = [];
        this.particleEmitters2 = [];
        this.ribbonEmitters = [];
        this.boundingShapes = [];
        this.attachments = [];

        this.texturePaths = [];

        this.replaceables = [];

        this.textureAtlases = {};

        if (chunks.TEXS) {
            objects = chunks.TEXS.elements;

            for (i = 0, l = objects.length; i < l; i++) {
                this.loadTexture(objects[i], this.pathSolver);
            }
        }

        if (chunks.SEQS) {
            this.sequences = chunks.SEQS.elements;
        }

        if (chunks.GLBS) {
            this.globalSequences = chunks.GLBS.elements;
        }

        var nodes = parser.nodes;
        var pivots;

        if (chunks.PIVT) {
            pivots = chunks.PIVT.elements;
        } else {
            pivots = [{ value: [0, 0, 0] }];
        }

        this.nodes = [];
        this.sortedNodes = [];

        for (i = 0, l = nodes.length; i < l; i++) {
            this.nodes[i] = new MdxNode(nodes[i], this, pivots);
        }

        if (this.nodes.length === 0) {
            this.nodes[0] = new MdxNode({ objectId: 0, parentId: -1 }, this, pivots);
        }

        // This list is used to access all the nodes in a loop while keeping the hierarchy in mind.
        this.hierarchy = this.setupHierarchy([], this.nodes, -1);

        for (i = 0, l = this.nodes.length; i < l; i++) {
            this.sortedNodes[i] = this.nodes[this.hierarchy[i]];
        }

        // Checks what sequences are variant or not
        this.setupVariants();

        if (chunks.BONE) {
            this.bones = chunks.BONE.elements;
        } else {
            // If there are no bones, reference the injected root node, since the shader requires at least one bone
            this.bones = [{ node: { objectId: 0, index: 0 } }];
        }

        this.textureAnimations = this.transformElements(chunks.TXAN, MdxTextureAnimation);

        if (chunks.MTLS) {
            objects = chunks.MTLS.elements;

            var materials = [];

            var layerId = 0;

            this.layers = [];

            for (i = 0, l = objects.length; i < l; i++) {
                var layers = objects[i].layers;

                materials[i] = [];

                for (j = 0, k = layers.length; j < k; j++) {
                    var layer = new MdxLayer(layers[j], layerId, objects[i].priorityPlane, this);

                    layerId += 1;

                    materials[i][j] = layer;
                    this.layers.push(layer);

                    this.setupVaryingTextures(layer);
                }
            }

            this.materials = materials;
        }

        this.geosetAnimations = this.transformElements(chunks.GEOA, MdxGeosetAnimation);

        if (chunks.GEOS) {
            let geosets = chunks.GEOS.elements,
                opaqueBatches = [],
                translucentBatches = [],
                batchId = 0;

            for (i = 0, l = geosets.length; i < l; i++) {
                let geoset = geosets[i],
                    layers = materials[geoset.materialId],
                    mesh = new MdxGeoset(geoset, this.geosetAnimations);

                this.geosets.push(mesh);

                for (j = 0, k = layers.length; j < k; j++) {
                    layer = layers[j];

                    var batch = new MdxBatch(batchId, layer, mesh);

                    if (layer.filterMode < 2) {
                        opaqueBatches.push(batch);
                    } else {
                        translucentBatches.push(batch);
                    }

                    batchId += 1;
                }
            }

            translucentBatches.sort(function (a, b) {
                return a.layer.priorityPlane > b.layer.priorityPlane;
            });

            this.batches = opaqueBatches.concat(translucentBatches);
            this.opaqueBatches = opaqueBatches;
            this.translucentBatches = translucentBatches;
        } else {
            this.batches = [];
        }

        this.setupGeosets();

        this.cameras = this.transformElements(chunks.CAMS, MdxCamera);

        if (chunks.PREM) {
            this.particleEmitters = chunks.PREM.elements;
        }

        if (chunks.PRE2) {
            this.particleEmitters2 = this.transformElements(chunks.PRE2, MdxParticleEmitter2);
        }

        if (chunks.RIBB) {
            this.ribbonEmitters = this.transformElements(chunks.RIBB, MdxRibbonEmitter);
        }

        this.boundingShapes = [];
        if (chunks.CLID) {
            this.boundingShapes = chunks.CLID.elements;
        }

        this.attachments = this.transformElements(chunks.ATCH, MdxAttachment);

        if (chunks.EVTS) {
            this.eventObjects = chunks.EVTS.elements;
        }

        this.calculateExtent();

        return true;
    },

    isVariant(sequence) {
        let nodes = this.nodes;

        for (let i = 0, l = nodes.length; i < l; i++) {
            if (nodes[i].isVariant(sequence)) {
                return true;
            }
        }
        
        return false;
    },

    setupVariants() {
        let variants = [];

        for (let i = 0, l = this.sequences.length; i < l; i++) {
            variants[i] = this.isVariant(i);
        }

        this.variants = variants;
    },

    setupVaryingTextures(layer) {
        // Get all unique texture IDs used by this layer
        let textureIds = layer.getAllTextureIds();

        if (textureIds.length > 1) {
            let hash = hashFromArray(textureIds),
                textures = [];

            // Grab all of the textures
            for (let i = 0, l = textureIds.length; i < l; i++) {
                textures[i] = this.textures[textureIds[i]];
            }
            
            // When all of the textures are loaded, it's time to construct a texture atlas
            this.env.whenLoaded(textures, () => {
                let textureAtlases = this.textureAtlases;

                // Cache atlases
                if (!textureAtlases[hash]) {
                    let images = [];

                    // Grab all the ImageData objects from the loaded textures
                    for (let i = 0, l = textures.length; i < l; i++) {
                        images[i] = textures[i].imageData;
                    }

                    // Finally create the atlas
                    let atlasData = createTextureAtlas(images);

                    textureAtlases[hash] = { textureId: this.textures.length, columns: atlasData.columns, rows: atlasData.rows };
                    
                    this.textures.push(this.env.load(atlasData.texture));
                }

                // Tell the layer to use this texture atlas, instead of its original texture
                layer.setAtlas(textureAtlases[hash]);
            });
        }
    },

    setupGeosets() {
        let geosets = this.geosets;

        if (geosets.length > 0) {
            let gl = this.gl,
                shallowGeosets = [],
                typedArrays = [],
                totalArrayOffset = 0,
                elementTypedArrays = [],
                totalElementOffset = 0,
                i, l;

            for (i = 0, l = geosets.length; i < l; i++) {
                let geoset = geosets[i],
                    vertices = geoset.locationArray,
                    normals = geoset.normalArray,
                    uvSets = geoset.uvsArray,
                    boneIndices = geoset.boneIndexArray,
                    boneNumbers = geoset.boneNumberArray,
                    faces = geoset.faceArray,
                    verticesOffset = totalArrayOffset,
                    normalsOffset = verticesOffset + vertices.byteLength,
                    uvSetsOffset = normalsOffset + normals.byteLength,
                    boneIndicesOffset = uvSetsOffset + uvSets.byteLength,
                    boneNumbersOffset = boneIndicesOffset + boneIndices.byteLength;

                shallowGeosets[i] = new MdxShallowGeoset([verticesOffset, normalsOffset, uvSetsOffset, boneIndicesOffset, boneNumbersOffset, totalElementOffset], geoset.uvSetSize, faces.length, this);

                typedArrays.push([verticesOffset, vertices]);
                typedArrays.push([normalsOffset, normals]);
                typedArrays.push([uvSetsOffset, uvSets]);
                typedArrays.push([boneIndicesOffset, boneIndices]);
                typedArrays.push([boneNumbersOffset, boneNumbers]);

                elementTypedArrays.push([totalElementOffset, faces]);

                totalArrayOffset = boneNumbersOffset + boneNumbers.byteLength;
                totalElementOffset += faces.byteLength;
            }

            let arrayBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, arrayBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, totalArrayOffset, gl.STATIC_DRAW);

            for (i = 0, l = typedArrays.length; i < l; i++) {
                gl.bufferSubData(gl.ARRAY_BUFFER, typedArrays[i][0], typedArrays[i][1]);
            }

            let faceBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, faceBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, totalElementOffset, gl.STATIC_DRAW);

            for (i = 0, l = elementTypedArrays.length; i < l; i++) {
                gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, elementTypedArrays[i][0], elementTypedArrays[i][1]);
            }

            this.__webglArrayBuffer = arrayBuffer;
            this.__webglElementBuffer = faceBuffer;
            this.shallowGeosets = shallowGeosets;
        }
    },

    setupHierarchy(hierarchy, nodes, parent) {
        for (let i = 0, l = nodes.length; i < l; i++) {
            let node = nodes[i];

            if (node.parentId === parent) {
                hierarchy.push(i);

                this.setupHierarchy(hierarchy, nodes, node.objectId);
            }
        }

        return hierarchy;
    },

    transformElements(chunk, Func, gl) {
        var output = [];

        if (chunk) {
            var elements = chunk.elements;

            for (var i = 0, l = elements.length; i < l; i++) {
                output[i] = new Func(elements[i], this);
            }
        }

        return output;
    },

    loadTexture(texture, pathSolver) {
        var path = texture.path;
        var replaceableId = texture.replaceableId;

        if (replaceableId !== 0) {
            path = "replaceabletextures/" + Mdx.replaceableIdToName[replaceableId] + ".blp";
        }

        this.replaceables.push(replaceableId);

        this.textures.push(this.env.load(path, pathSolver));
        this.texturePaths.push(normalizePath(path));
    },

    calculateExtent() {
        var meshes = this.geosets;
        var mesh;
        var min, max;
        var x, y, z;
        var minX = 1E9, minY = 1E9, minZ = 1E9;
        var maxX = -1E9, maxY = -1E9, maxZ = -1E9;
        var dX, dY, dZ;
        var i, l;

        for (i = 0, l = meshes.length; i < l; i++) {
            mesh = meshes[i];
            mesh.calculateExtent();

            min = mesh.extent.min;
            max = mesh.extent.max;
            x = min[0];
            y = min[1];
            z = min[2];

            if (x < minX) {
                minX = x;
            }

            if (y < minY) {
                minY = y;
            }

            if (z < minZ) {
                minZ = z;
            }

            x = max[0];
            y = max[1];
            z = max[2];

            if (x > maxX) {
                maxX = x;
            }

            if (y > maxY) {
                maxY = y;
            }

            if (z > maxZ) {
                maxZ = z;
            }
        }

        dX = maxX - minX;
        dY = maxY - minY;
        dZ = maxZ - minZ;

        this.extent = {radius: Math.sqrt(dX * dX + dY * dY + dZ * dZ) / 2, min: [minX, minY, minZ], max: [maxX, maxY, maxZ] };
    },

    update() {
        if (!window.oops) {
            window.oops = 1;

            console.warn("[MdxModel.update] Do I really want this stuff here?");
        }

        Model.prototype.update.call(this);

        let emitters = this.particleEmitters2;
        if (emitters) {
            for (let i = 0, l = emitters.length; i < l; i++) {
                emitters[i].update();
            }
        }

        emitters = this.ribbonEmitters;
        if (emitters) {
            for (let i = 0, l = emitters.length; i < l; i++) {
                emitters[i].update();
            }
        }
    },

    bind(bucket) {
        const webgl = this.env.webgl;
        var gl = this.gl;

        // HACK UNTIL I IMPLEMENT MULTIPLE SHADERS AGAIN
        var shader = Mdx.standardShader;
        webgl.useShaderProgram(shader);
        this.shader = shader;

        const instancedArrays = gl.extensions.instancedArrays;
        const attribs = shader.attribs;
        const uniforms = shader.uniforms;

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.__webglElementBuffer);

        gl.uniformMatrix4fv(uniforms.get("u_mvp"), false, bucket.modelView.scene.camera.worldProjectionMatrix);

        gl.uniform1i(uniforms.get("u_texture"), 0);

        // Team colors
        let teamColor = attribs.get("a_teamColor");
        gl.bindBuffer(gl.ARRAY_BUFFER, bucket.teamColorBuffer);
        gl.vertexAttribPointer(teamColor, 1, gl.UNSIGNED_BYTE, false, 1, 0);
        instancedArrays.vertexAttribDivisorANGLE(teamColor, 1);

        // Tint colors
        let tintColor = attribs.get("a_tintColor");
        gl.bindBuffer(gl.ARRAY_BUFFER, bucket.tintColorBuffer);
        gl.vertexAttribPointer(tintColor, 3, gl.UNSIGNED_BYTE, true, 3, 0); // normalize the colors from [0, 255] to [0, 1] here instead of in the pixel shader
        instancedArrays.vertexAttribDivisorANGLE(tintColor, 1);

        gl.activeTexture(gl.TEXTURE15);
        gl.bindTexture(gl.TEXTURE_2D, bucket.boneTexture);
        gl.uniform1i(uniforms.get("u_boneMap"), 15);
        gl.uniform1f(uniforms.get("u_vector_size"), bucket.vectorSize);
        gl.uniform1f(uniforms.get("u_row_size"), bucket.rowSize);

        gl.bindBuffer(gl.ARRAY_BUFFER, bucket.instanceIdBuffer);
        gl.vertexAttribPointer(attribs.get("a_InstanceID"), 1, gl.UNSIGNED_SHORT, false, 2, 0);
        instancedArrays.vertexAttribDivisorANGLE(attribs.get("a_InstanceID"), 1);
    },

    unbind() {
        let gl = this.gl,
            instancedArrays = gl.extensions.instancedArrays,
            attribs = this.shader.attribs;

        // Reset gl values to default, to play nice with other handlers
        gl.depthMask(1);
        gl.disable(gl.BLEND);
        gl.enable(gl.CULL_FACE);
        gl.enable(gl.DEPTH_TEST);

        // Reset the attributes to play nice with other handlers
        instancedArrays.vertexAttribDivisorANGLE(attribs.get("a_teamColor"), 0);
        instancedArrays.vertexAttribDivisorANGLE(attribs.get("a_tintColor"), 0);
        instancedArrays.vertexAttribDivisorANGLE(attribs.get("a_InstanceID"), 0);
        instancedArrays.vertexAttribDivisorANGLE(attribs.get("a_batchVisible"), 0);
        instancedArrays.vertexAttribDivisorANGLE(attribs.get("a_geosetColor"), 0);
        instancedArrays.vertexAttribDivisorANGLE(attribs.get("a_uvOffset"), 0);
    },

    renderBatch(bucket, batch) {
        let gl = this.gl,
            instancedArrays = gl.extensions.instancedArrays,
            shader = this.shader,
            attribs = this.shader.attribs,
            uniforms = shader.uniforms,
            layer = batch.layer,
            shallowGeoset = this.shallowGeosets[batch.geoset.index],
            replaceable = this.replaceables[layer.textureId],
            colorMode = 0;

        layer.bind(shader);

        // Team color
        if (replaceable === 1) {
            colorMode = 1;
        // Team glow
        } else if (replaceable === 2) {
            colorMode = 2;
        }
        
        gl.uniform1f(uniforms.get("u_colorMode"), colorMode);

        // If this is team color/glow, bind the black texture to avoid WebGL errors.
        // Otherwise, bind the texture used by this layer.
        if (colorMode) {
            this.bindTexture();
        } else {
            this.bindTexture(layer.textureId, bucket.modelView);

            // Does this layer use texture animations with multiple textures?
            gl.uniform1f(uniforms.get("u_isTextureAnim"), layer.isTextureAnim);
        }

        // Batch visibilities
        let batchVisible = attribs.get("a_batchVisible");
        gl.bindBuffer(gl.ARRAY_BUFFER, bucket.batchVisibilityBuffers[batch.index]);
        gl.vertexAttribPointer(batchVisible, 1, gl.UNSIGNED_BYTE, false, 1, 0);
        instancedArrays.vertexAttribDivisorANGLE(batchVisible, 1);

        // Geoset colors
        let geosetColor = attribs.get("a_geosetColor");
        gl.bindBuffer(gl.ARRAY_BUFFER, bucket.geosetColorBuffers[batch.index]);
        gl.vertexAttribPointer(geosetColor, 4, gl.UNSIGNED_BYTE, true, 4, 0);
        instancedArrays.vertexAttribDivisorANGLE(geosetColor, 1);

        // Texture coordinate animations
        let uvOffset = attribs.get("a_uvOffset");
        gl.bindBuffer(gl.ARRAY_BUFFER, bucket.uvOffsetBuffers[layer.index]);
        gl.vertexAttribPointer(uvOffset, 4, gl.FLOAT, false, 16, 0);
        instancedArrays.vertexAttribDivisorANGLE(uvOffset, 1);

        // Texture coordinate divisor
        // Used for layers that use image animations, in order to scale the coordinates to match the generated texture atlas
        gl.uniform2f(uniforms.get("u_uvScale"), 1 / layer.uvDivisor[0], 1 / layer.uvDivisor[1]);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.__webglArrayBuffer);
        shallowGeoset.bind(shader, layer.coordId);

        shallowGeoset.render(bucket.instances.length);
    },

    renderBatches(bucket, batches) {
        if (batches && batches.length) {
            const updateBatches = bucket.updateBatches;

            this.bind(bucket);

            for (let i = 0, l = batches.length; i < l; i++) {
                const batch = batches[i];

                if (updateBatches[batch.index]) {
                    this.renderBatch(bucket, batch);
                }
            }

            this.unbind();
        }
    },

    renderOpaque(bucket) {
        this.renderBatches(bucket, this.opaqueBatches);
    },

    renderTranslucent(bucket) {
        this.renderBatches(bucket, this.translucentBatches);
    },

    renderEmitters(bucket) {
        let webgl = this.env.webgl,
            gl = this.env.gl,
            emitters = this.particleEmitters2;

        if (emitters.length) {
            gl.depthMask(0);
            gl.enable(gl.BLEND);
            gl.disable(gl.CULL_FACE);

            var shader = Mdx.particleShader;
            webgl.useShaderProgram(shader);

            gl.uniformMatrix4fv(shader.uniforms.get("u_mvp"), false, bucket.modelView.scene.camera.worldProjectionMatrix);

            gl.uniform1i(shader.uniforms.get("u_texture"), 0);

            for (let i = 0, l = emitters.length; i < l; i++) {
                emitters[i].render(shader, bucket.modelView);
            }

            gl.depthMask(1);
        }

        gl.depthMask(1);
        gl.disable(gl.BLEND);
        gl.enable(gl.CULL_FACE);
    },

    bindTexture(textureId, view) {
        let texture;

        if (view) {
            texture = view.textures[textureId];
        }

        this.env.webgl.bindTexture(texture || this.textures[textureId], 0);
    },
};

mix(MdxModel.prototype, Model.prototype);
/**
 * @class
 * @classdesc An MDX model instance.
 * @extends ModelInstance
 * @memberOf Mdx
 * @param {ModelViewer} env The model viewer object that this texture belongs to.
 */
function MdxModelInstance(env) {
    ModelInstance.call(this, env);
}

MdxModelInstance.prototype = {
    initialize() {
        var model = this.model;
        var pathSolver = model.pathSolver;

        this.skeleton = new MdxSkeleton(this, model);

        this.particleEmitters = [];
        if (model.particleEmitters && model.particleEmitters.length > 0) {
            const objects = model.particleEmitters;

            for (let i = 0, l = objects.length; i < l; i++) {
                this.particleEmitters[i] = new MdxParticleEmitter(this, objects[i]);
            }
        }

        this.particleEmitters2 = [];
        if (model.particleEmitters2 && model.particleEmitters2.length > 0) {
            const objects = model.particleEmitters2;
            
            for (let i = 0, l = objects.length; i < l; i++) {
                this.particleEmitters2[i] = new MdxParticleEmitter2View(this, objects[i]);
            }
        }

        this.ribbonEmitters = [];
        if (model.ribbonEmitters && model.ribbonEmitters.length > 0) {
            const objects = model.ribbonEmitters;

            for (i = 0, l = objects.length; i < l; i++) {
                this.ribbonEmitters[i] = new MdxRibbonEmitterView(this, objects[i]);
            }
        }

        //let extent = this.model.parser.chunks.MODL.extent;
        //this.boundingShape = new BoundingShape();
        //this.boundingShape.fromBounds(extent.min, extent.max);
        //this.boundingShape.setParent(this);

        //-------------------------------------------------------------------------------------------------------
        // NOTE: If I ever want to re-implement bounding shape rendering, this is pretty much how it should work
        //       Possibly always create unit geometries and scale the instances, to avoid creating many models
        //       This will allow me to introduce instanced rendering for SimpleMesh if I want to at some point
        //       E.g. createSphere(1, 12, 12)
        //            ...
        //            instance.setUniformScale(radius)
        //-------------------------------------------------------------------------------------------------------
        var boundingShapes = model.boundingShapes;
        boundingShapes = [];
        for (var i = 0, l = boundingShapes.length; i < l; i++) {
            var boundingShape = boundingShapes[i];

            if (boundingShape.type === 0) {
                var vertices = boundingShape.vertices,
                    x1 = vertices[0],
                    y1 = vertices[1],
                    z1 = vertices[2],
                    x2 = vertices[3],
                    y2 = vertices[4],
                    z2 = vertices[5];

                var boundingModel = viewer.load({ geometry: createCube((x2 - x1) / 2, (y2 - y1) / 2, (z2 - z1) / 2), material: { renderMode: 1 } }, Geo.pathSolver);
                var instance = boundingModel.addInstance();
                instance.dontInheritScale = false; // Override since the bounding shapes should scale with the instance
                instance.setLocation([(x2 + x1) / 2, (y2 + y1) / 2, (z2 + z1) / 2]);
                instance.setParent(this.skeleton.nodes[boundingShape.node.index]);
            } else if (boundingShape.type === 2) {
                var boundingModel = viewer.load({ geometry: createSphere(boundingShape.radius, 12, 12), material: { renderMode: 1 } }, Geo.pathSolver);
                var instance = boundingModel.addInstance();
                instance.dontInheritScale = false; // Override since the bounding shapes should scale with the instance
                instance.setLocation(boundingShape.vertices);
                instance.setParent(this.skeleton.nodes[boundingShape.node.index]);
            }
        }

        if (0) {
            let extent = model.extent,
                min = extent.min,
                max = extent.max,
                dx = (max[0] - min[0]) / 2,
                dy = (max[1] - min[1]) / 2,
                dz = (max[2] - min[2]) / 2;

            // Viewer X = Game Y
            // Viewer Y = Game Z
            // Viewer Z = Game X

            console.log(dx, dy, dz);
            //let shape = createSphere(model.extent.radius, 12, 12);
            let shape = createCube(dx, dy, dz);
            var boundingModel = viewer.load({ geometry: shape, material: { renderMode: 1, edgeColor: [150, 200, 150] } }, Geo.pathSolver);
            var instance = boundingModel.addInstance();
            instance.dontInheritScale = false; // Override since the bounding shapes should scale with the instance
            //instance.move([dx / 2, dy / 2, dz / 2]);
            instance.setParent(this);


            shape = createSphere(model.extent.radius, 12, 12);
            boundingModel = viewer.load({ geometry: shape, material: { renderMode: 1, edgeColor: [150, 200, 150] } }, Geo.pathSolver);
            instance = boundingModel.addInstance();
            instance.dontInheritScale = false; // Override since the bounding shapes should scale with the instance
            //instance.move([dx / 2, dy / 2, dz / 2]);
            instance.setParent(this);

            console.log(model.extent)
        }

        //-------------------------------------------------------------------------------------------------------

        this.modelAttachments = [];
        
        const attachments = model.attachments;

        for (let i = 0, l = attachments.length; i < l; i++) {
            const attachment = attachments[i],
                attachedModel = attachment.attachedModel;

            if (attachedModel) {
                const instance = attachedModel.addInstance();

                instance.setSequenceLoopMode(2);
                instance.setParent(this.skeleton.nodes[attachment.node.objectId]);
                instance.dontInheritScale = false;

                this.modelAttachments.push([attachment, instance]);
            }
        }
        
        this.eventObjectEmitters = [];
        
        //if (model.eventObjects) {
        //    objects = model.eventObjects;
            
        //    for (i = 0, l = objects.length; i < l; i++) {
        //        this.eventObjectEmitters[i] = new MdxEventObjectEmitter(objects[i], model, this, viewer, pathSolver);
        //    }
        //}

        this.sequence = -1;
        this.sequenceLoopMode = 0;
        this.sequenceObject = null;
        this.allowParticleSpawn = false;
    },

    setSharedData(sharedData) {
        this.bucket = sharedData.bucket;

        this.skeleton.boneArray = sharedData.boneArray;

        // Update once at setup, since it might not be updated later, depending on sequence variancy
        this.skeleton.update();

        this.geosetColorArrays = sharedData.geosetColorArrays;
        this.uvOffsetArrays = sharedData.uvOffsetArrays;

        this.teamColorArray = sharedData.teamColorArray;
        this.tintColorArray = sharedData.tintColorArray;

        this.batchVisibilityArrays = sharedData.batchVisibilityArrays;
    },

    updateEmitters() {
        let allowCreate = this.allowParticleSpawn,
            emitters;

        emitters = this.particleEmitters;
        for (let i = 0, l = emitters.length; i < l; i++) {
            emitters[i].update(allowCreate);
        }

        emitters = this.particleEmitters2;
        for (let i = 0, l = emitters.length; i < l; i++) {
            emitters[i].update(allowCreate);
        }
        
        emitters = this.ribbonEmitters;
        for (var i = 0, l = emitters.length; i < l; i++) {
            emitters[i].update(allowCreate);
        }
        /*
        emitters = this.eventObjectEmitters;
        for (var i = 0, l = emitters.length; i < l; i++) {
            emitters[i].update(allowCreate);
        }
        */
    },

    preemptiveUpdate() {
        if (this.sequenceObject) {
            var sequence = this.sequenceObject;

            this.frame += this.env.frameTime;

            this.allowParticleSpawn = true;

            if (this.frame >= sequence.interval[1]) {
                if (this.sequenceLoopMode === 2 || (this.sequenceLoopMode === 0 && sequence.flags === 0)) {
                    this.frame = sequence.interval[0];
                } else {
                    this.frame = sequence.interval[1];
                    this.allowParticleSpawn = false;
                }

                this.dispatchEvent({ type: "seqend" });
            }
        }
    },

    update() {
        var model = this.model,
            bucket = this.bucket;

        if (this.sequenceObject && model.variants[this.sequence]) {
            this.skeleton.update();
            bucket.updateBoneTexture[0] = 1;
        }

        this.updateEmitters();

        // Model attachments
        const modelAttachments = this.modelAttachments;

        for (let i = 0, l = modelAttachments.length; i < l; i++) {
            let modelAttachment = modelAttachments[i],
                attachment = modelAttachment[0],
                instance = modelAttachment[1];

            if (attachment.getVisibility(this) > 0.1) {
                if (!instance.rendered) {
                    instance.rendered = true;
                    instance.setSequence(0);
                }
            } else {
                instance.rendered = false;
            }
        }
        
        var batches = model.batches;

        // Not every model has batches
        if (batches.length) {
            let layers = model.layers,
                geosetColorArrays = this.geosetColorArrays,
                uvOffsetArrays = this.uvOffsetArrays,
                batchVisibilityArrays = this.batchVisibilityArrays;

            // Update batch visibilities and geoset colors
            for (var i = 0, l = batches.length; i < l; i++) {
                var batch = batches[i],
                    index = batch.index,
                    geoset = batch.geoset,
                    layer = batch.layer,
                    geosetColorArray = geosetColorArrays[index];

                var batchVisibility = batch.shouldRender(this);
                batchVisibilityArrays[index][0] = batchVisibility;
                bucket.updateBatches[index] |= batchVisibility;

                if (batchVisibility) {
                    if (geoset.geosetAnimation) {
                        var tempVec3 = geoset.geosetAnimation.getColor(this);

                        geosetColorArray[0] = tempVec3[0] * 255;
                        geosetColorArray[1] = tempVec3[1] * 255;
                        geosetColorArray[2] = tempVec3[2] * 255;
                    }

                    geosetColorArray[3] = layer.getAlpha(this) * 255;
                }
            }

            // Update texture coordinates
            for (var i = 0, l = layers.length; i < l; i++) {
                var layer = layers[i],
                    index = layer.index,
                    textureAnimation = layer.textureAnimation,
                    uvOffsetArray = uvOffsetArrays[index];

                // Texture animation that works by offsetting the coordinates themselves
                if (textureAnimation) {
                    // What is Z used for?
                    var uvOffset = textureAnimation.getTranslation(this);

                    uvOffsetArray[0] = uvOffset[0];
                    uvOffsetArray[1] = uvOffset[1];

                    bucket.updateUvOffsets[0] = 1;
                }

                // Texture animation that is based on a texture atlas, where the selected tile changes
                if (layer.isTextureAnim) {
                    var uvDivisor = layer.uvDivisor;
                    var textureId = layer.getTextureId(this);

                    uvOffsetArray[2] = textureId % uvDivisor[0];
                    uvOffsetArray[3] = Math.floor(textureId / uvDivisor[1]);

                    bucket.updateUvOffsets[0] = 1;
                }
            }
        }
    },

    // This is overriden in order to update the skeleton when the parent node changes
    recalculateTransformation() {
        Node.prototype.recalculateTransformation.call(this);

        if (this.rendered) {
            this.skeleton.update();
            this.bucket.updateBoneTexture[0] = 1;
        } else {
            this.addAction(() => this.skeleton.update(), []);
        }
    },
    /*
    render: function () {
        if (this.eventObjectEmitters) {
            var emitters = this.eventObjectEmitters;
            
            for (i = 0, l = emitters.length; i < l; i++) {
                emitters[i].render();
            }
        }
    }
    */
    setTeamColor(id) {
        if (this.rendered) {
            this.teamColorArray[0] = id;
            this.bucket.updateTeamColors[0] = 1;
        } else {
            this.addAction(id => this.setTeamColor(id), [id]);
        }

        return this;
    },

    setTintColor(color) {
        if (this.rendered) {
            this.tintColorArray.set(color);
            this.bucket.updateTintColors[0] = 1;
        } else {
            this.addAction(id => this.setTintColor(color), [color]);
        }

        return this;
    },

    setSequence(id) {
        if (this.rendered) {
            var sequences = this.model.sequences.length;

            if (id < sequences) {
                this.sequence = id;

                if (id === -1) {
                    this.frame = 0;

                    this.sequenceObject = null;
                } else {
                    var sequence = this.model.sequences[id];

                    this.frame = sequence.interval[0];

                    this.sequenceObject = sequence;
                }

                // Update the skeleton in case this sequence isn't vareiant, and thus it won't get updated in the update function
                this.skeleton.update();
            }
        } else {
            this.addAction(id => this.setSequence(id), [id]);
        }

        return this;
    },

    setSequenceLoopMode(mode) {
        if (this.rendered) {
            this.sequenceLoopMode = mode;
        } else {
            this.addAction(mode => this.setSequenceLoopMode(mode), [mode]);
        }

        return this;

    },

    getAttachment(id) {
        var attachment = this.model.attachments[id];

        if (attachment) {
            return this.skeleton.nodes[attachment.node.index];
        } else {
            return this.skeleton.nodes[0];
        }
    }
};

mix(MdxModelInstance.prototype, ModelInstance.prototype);
const Mdx = {
    initialize(env) {
        env.addHandler(Blp);
        env.addHandler(Tga);
        env.addHandler(Slk);
        env.addHandler(NativeTexture); // Needed for texture atlases

        this.standardShader = env.webgl.createShaderProgram(env.sharedShaders.boneTexture + MdxShaders.vs_main, "#define STANDARD_PASS\n" + MdxShaders.ps_main);
        this.particleShader = env.webgl.createShaderProgram(env.sharedShaders.decodeFloat + MdxShaders.vs_particles, MdxShaders.ps_particles);
        //this.ribbonShader = env.webgl.createShaderProgram(MdxShaders.vs_ribbons, "#define STANDARD_PASS\n" + MdxShaders.ps_main);

        // If a shader failed to compile, don't allow the handler to be registered, and send an error instead.
        if (!this.standardShader.loaded || !this.particleShader.loaded) {
            return false;
        }

        const teamColors = [[255, 3, 3], [0, 66, 255], [28, 230, 185], [84, 0, 129], [255, 252, 1], [254, 138, 14], [32, 192, 0], [229, 91, 176], [149, 150, 151], [126, 191, 241], [16, 98, 70], [78, 42, 4], [40, 40, 40], [0, 0, 0]];
        
        this.teamColors = 14;

        const webgl = env.webgl,
            gl = env.gl;

        webgl.useShaderProgram(this.standardShader);

        for (let i = 0; i < 14; i++) {
            const color = teamColors[i];

            gl.uniform3fv(this.standardShader.uniforms.get("u_teamColors[" + i + "]"), [color[0] / 255, color[1] / 255, color[2] / 255]);
        }

        this.replaceableIdToName = {
            1: "TeamColor/TeamColor00",
            2: "TeamGlow/TeamGlow00",
            11: "Cliff/Cliff0",
            21: "", // Used by all cursor models (HumanCursor, OrcCursor, UndeadCursor, NightElfCursor)
            31: "LordaeronTree/LordaeronSummerTree",
            32: "AshenvaleTree/AshenTree",
            33: "BarrensTree/BarrensTree",
            34: "NorthrendTree/NorthTree",
            35: "Mushroom/MushroomTree",
            36: "RuinsTree/RuinsTree",
            37: "OutlandMushroomTree/MushroomTree"
        };

        return true;
    },

    get extension() {
        return ".mdx";
    },

    get Constructor() {
        return MdxModel;
    },

    get ModelView() {
        return MdxModelView;
    },

    get Instance() {
        return MdxModelInstance;
    },

    get Bucket() {
        return MdxBucket;
    },

    get binaryFormat() {
        return true;
    }
};

mix(Mdx, ModelHandler);
const M3Shaders = {
    "vs_common": `
        vec3 TBN(vec3 vector, vec3 tangent, vec3 binormal, vec3 normal) {
            return vec3(dot(vector, tangent), dot(vector, binormal), dot(vector, normal));
        }

        vec4 decodeVector(vec4 v) {
            return ((v / 255.0) * 2.0) - 1.0;
        }
    `,

    "vs_main": `
        uniform mat4 u_mvp;
        uniform mat4 u_mv;
        uniform vec3 u_eyePos;
        uniform vec3 u_lightPos;
        uniform float u_firstBoneLookupIndex;
        uniform float u_boneWeightPairsCount;
        uniform vec3 u_teamColors[14];

        attribute vec3 a_position;
        attribute vec4 a_normal;
        attribute vec2 a_uv0;

        #ifdef EXPLICITUV1
        attribute vec2 a_uv1;
        #endif
        #ifdef EXPLICITUV2
        attribute vec2 a_uv1, a_uv2;
        #endif
        #ifdef EXPLICITUV3
        attribute vec2 a_uv1, a_uv2, a_uv3;
        #endif

        attribute vec4 a_tangent;
        attribute vec4 a_bones;
        attribute vec4 a_weights;
        attribute float a_teamColor;
        attribute vec3 a_tintColor;

        varying vec3 v_normal;
        varying vec4 v_uv[2]; // Pack 4 vec2 in 2 vec4, to reduce the varyings count
        varying vec3 v_lightDir;
        //varying vec3 v_eyeVec;
        varying vec3 v_halfVec;
        varying vec3 v_teamColor;
        //varying vec3 v_tintColor;

        void transform(inout vec3 position, inout vec3 normal, inout vec3 tangent, inout vec3 binormal, vec4 bones, vec4 weights) {
            if (u_boneWeightPairsCount > 0.0) {
                mat4 bone;

                if (u_boneWeightPairsCount == 1.0) {
                    bone = boneAtIndex(bones[0], a_InstanceID);
                } else {
                    bone += boneAtIndex(bones[0], a_InstanceID) * weights[0];
                    bone += boneAtIndex(bones[1], a_InstanceID) * weights[1];
                    bone += boneAtIndex(bones[2], a_InstanceID) * weights[2];
                    bone += boneAtIndex(bones[3], a_InstanceID) * weights[3];
                }

                position = vec3(bone * vec4(position, 1.0));
                normal = mat3(bone) * normal;
                tangent = vec3(bone * vec4(tangent, 0.0));
                binormal = vec3(bone * vec4(binormal, 0.0));
            } 
        }

        void main() {
            vec4 decodedNormal = decodeVector(a_normal);

            vec3 position = a_position;
            vec3 normal = decodedNormal.xyz;
            vec3 tangent = vec3(decodeVector(a_tangent));
            vec3 binormal = cross(normal, tangent) * decodedNormal.w;

            transform(position, normal, tangent, binormal, a_bones +u_firstBoneLookupIndex, a_weights / 255.0);

            mat3 mv = mat3(u_mv);

            vec3 position_mv = (u_mv * vec4(position, 1)).xyz;

            vec3 n = normalize(mv * normal);
            vec3 t = normalize(mv * tangent);
            vec3 b = normalize(mv * binormal);

            vec3 lightDir = normalize(u_lightPos - position_mv);
            v_lightDir = normalize(TBN(lightDir, t, b, n));

            vec3 eyeVec = normalize(u_eyePos - position_mv);
            vec3 halfVec = normalize(eyeVec - u_lightPos);

            //v_eyeVec = TBN(eyeVec, t, b, n);
            v_halfVec = TBN(halfVec, t, b, n);

            v_normal = n;

            vec4 uv0, uv1;

            uv0.xy = a_uv0 / 2048.0;

            #ifdef EXPLICITUV1
                uv0.zw = a_uv1 / 2048.0;
            #endif

            #ifdef EXPLICITUV2
                uv1.xy = a_uv2 / 2048.0;
            #endif

            #ifdef EXPLICITUV3
                uv1.zw = a_uv3 / 2048.0;
            #endif

            v_uv[0]= uv0;
            v_uv[1] = uv1;

            v_teamColor = u_teamColors[int(a_teamColor)];
	        //v_tintColor = a_tintColor;

            gl_Position = u_mvp * vec4(position, 1.0);
        }
    `,

    "ps_common": `
        varying vec3 v_normal;
        varying vec4 v_uv[2];
        varying vec3 v_lightDir;
        //varying vec3 v_eyeVec;
        varying vec3 v_halfVec;
        varying vec3 v_teamColor;
        //varying vec3 v_tintColor;

        struct LayerSettings {
            bool enabled;
            float op;
            float channels;
            float teamColorMode;
            //vec3 multAddAlpha;
            //bool useAlphaFactor;
            bool invert;
            //bool multColor;
            //bool addColor;
            bool clampResult;
            //bool useConstantColor;
            //vec4 constantColor;
            //float uvSource;
            float uvCoordinate;
            //float fresnelMode;
            //float fresnelTransformMode;
            //mat4 fresnelTransform;
            //bool fresnelClamp;
            //vec3 fresnelExponentBiasScale;
        };

        #define SPECULAR_RGB 0.0
        #define SPECULAR_A_ONLY 1.0

        #define FRESNELMODE_NONE 0.0
        #define FRESNELMODE_STANDARD 1.0
        #define FRESNELMODE_INVERTED 2.0

        #define FRESNELTRANSFORM_NONE 0.0
        #define FRESNELTRANSFORM_SIMPLE 1.0
        #define FRESNELTRANSFORM_NORMALIZED 2.0

        #define UVMAP_EXPLICITUV0 0.0
        #define UVMAP_EXPLICITUV1 1.0
        #define UVMAP_REFLECT_CUBICENVIO 2.0
        #define UVMAP_REFLECT_SPHERICALENVIO 3.0
        #define UVMAP_PLANARLOCALZ 4.0
        #define UVMAP_PLANARWORLDZ 5.0
        #define UVMAP_PARTICLE_FLIPBOOK 6.0
        #define UVMAP_CUBICENVIO 7.0
        #define UVMAP_SPHERICALENVIO 8.0
        #define UVMAP_EXPLICITUV2 9.0
        #define UVMAP_EXPLICITUV3 10.0
        #define UVMAP_PLANARLOCALX 11.0
        #define UVMAP_PLANARLOCALY 12.0
        #define UVMAP_PLANARWORLDX 13.0
        #define UVMAP_PLANARWORLDY 14.0
        #define UVMAP_SCREENSPACE 15.0
        #define UVMAP_TRIPLANAR_LOCAL 16.0
        #define UVMAP_TRIPLANAR_WORLD 17.0
        #define UVMAP_TRIPLANAR_WORLD_LOCAL_Z 18.0

        #define CHANNELSELECT_RGB 0.0
        #define CHANNELSELECT_RGBA 1.0
        #define CHANNELSELECT_A 2.0
        #define CHANNELSELECT_R 3.0
        #define CHANNELSELECT_G 4.0
        #define CHANNELSELECT_B 5.0

        #define TEAMCOLOR_NONE 0.0
        #define TEAMCOLOR_DIFFUSE 1.0
        #define TEAMCOLOR_EMISSIVE 2.0

        #define LAYEROP_MOD 0.0
        #define LAYEROP_MOD2X 1.0
        #define LAYEROP_ADD 2.0
        #define LAYEROP_LERP 3.0
        #define LAYEROP_TEAMCOLOR_EMISSIVE_ADD 4.0
        #define LAYEROP_TEAMCOLOR_DIFFUSE_ADD 5.0
        #define LAYEROP_ADD_NO_ALPHA 6.0
        /*
        float calculateFresnelTerm(vec3 normal, vec3 eyeToVertex, float exponent, mat4 fresnelTransform, float fresnelTransformMode, bool fresnelClamp) {
            vec3 fresnelDir = eyeToVertex;
            float result;
  
            if (fresnelTransformMode != FRESNELTRANSFORM_NONE) {
                fresnelDir = (fresnelTransform * vec4(fresnelDir, 1.0)).xyz;
    
                if (fresnelTransformMode == FRESNELTRANSFORM_NORMALIZED) {
                    fresnelDir = normalize(fresnelDir);
                }
            }
  
            if (fresnelClamp) {
                result = 1.0 - clamp(-dot(normal, fresnelDir), 0.0, 1.0);
            } else {
                result = 1.0 - abs(dot(normal, fresnelDir));
            }
  
            result = max(result, 0.0000001);
  
            return pow(result, exponent);
        }
        */
        vec3 combineLayerColor(vec4 color, vec3 result, LayerSettings layerSettings) {
            if (layerSettings.op == LAYEROP_MOD) {
                result *= color.rgb;
            } else if (layerSettings.op == LAYEROP_MOD2X) {
                result *= color.rgb * 2.0;
            } else if (layerSettings.op == LAYEROP_ADD) {
                result += color.rgb * color.a;
            } else if (layerSettings.op == LAYEROP_ADD_NO_ALPHA) {
                result += color.rgb;
            } else if (layerSettings.op == LAYEROP_LERP) {
                result = mix(result, color.rgb, color.a);
            } else if (layerSettings.op == LAYEROP_TEAMCOLOR_EMISSIVE_ADD) {
                result += color.a * v_teamColor;
            } else if (layerSettings.op == LAYEROP_TEAMCOLOR_DIFFUSE_ADD) {
                result += color.a * v_teamColor;
            }

            return result;
        }

        vec4 chooseChannel(float channel, vec4 texel) {
            if (channel == CHANNELSELECT_R) {
                texel = texel.rrrr;
            } else if (channel == CHANNELSELECT_G) {
                texel = texel.gggg;
            } else if (channel == CHANNELSELECT_B) {
                texel = texel.bbbb;
            } else if (channel == CHANNELSELECT_A) {
                texel = texel.aaaa;
            } else if (channel == CHANNELSELECT_RGB) {
                texel.a = 1.0;
            }

            return texel;
        }

        vec2 getUV(LayerSettings layerSettings) {
            if (layerSettings.uvCoordinate == 1.0) {
                return v_uv[0].zw;
            } else if (layerSettings.uvCoordinate == 2.0) {
                return v_uv[1].xy;
            } else if (layerSettings.uvCoordinate == 3.0) {
                return v_uv[1].zw;
            }

            return v_uv[0].xy;
        }

        vec4 sampleLayer(sampler2D layer, LayerSettings layerSettings) {
            //if (layerSettings.useConstantColor) {
            //  return layerSettings.constantColor;
            //}

            return texture2D(layer, getUV(layerSettings));
        }

        vec4 computeLayerColor(sampler2D layer, LayerSettings layerSettings) {
            vec4 color = sampleLayer(layer, layerSettings);

            //if (layerSettings.useMask) {
            //    result *= mask;
            //}

            vec4 result = chooseChannel(layerSettings.channels, color);

            //if (layerSettings.useAlphaFactor) {
            //    result.a *= layerSettings.multiplyAddAlpha.z;
            //}

            if (layerSettings.teamColorMode == TEAMCOLOR_DIFFUSE) {
                result = vec4(mix(v_teamColor, result.rgb, color.a), 1.0);
            } else if (layerSettings.teamColorMode == TEAMCOLOR_EMISSIVE) {
                result = vec4(mix(v_teamColor, result.rgb, color.a), 1.0);
            }

            if (layerSettings.invert) {
                result = vec4(1.0) - result;
            }

            //if (layerSettings.multiplyEnable) {
            //    result *= layerSettings.multiplyAddAlpha.x;
            //}

            //if (layerSettings.addEnable) {
            //    result += layerSettings.multiplyAddAlpha.y;
            //}

            if (layerSettings.clampResult) {
                result = clamp(result, 0.0, 1.0);
            }

            /*
            if (layerSettings.fresnelMode != FRESNELMODE_NONE) {
            float fresnelTerm = calculateFresnelTerm(v_normal, v_eyeVec, layerSettings.fresnelExponentBiasScale.x, layerSettings.fresnelTransform, layerSettings.fresnelTransformMode, layerSettings.fresnelClamp);

            if (layerSettings.fresnelMode == FRESNELMODE_INVERTED) {
            fresnelTerm = 1.0 - fresnelTerm;
            }

            fresnelTerm = clamp(fresnelTerm * layerSettings.fresnelExponentBiasScale.z + layerSettings.fresnelExponentBiasScale.y, 0.0, 1.0);

            result *= fresnelTerm;
            }
            */
            return result;
        }

        vec3 decodeNormal(sampler2D map) {
            vec4 texel = texture2D(map, v_uv[0].xy);
            vec3 normal;

            normal.xy = 2.0 * texel.wy -1.0;
            normal.z = sqrt(max(0.0, 1.0 -dot(normal.xy, normal.xy)));

            return normal;
        }

        vec4 computeSpecular(sampler2D specularMap, LayerSettings layerSettings, float specularity, float specMult, vec3 normal) {
            vec4 color;

            if (layerSettings.enabled) {
                color = computeLayerColor(specularMap, layerSettings);
            } else {
                color = vec4(0);
            }

            float factor = pow(max(-dot(v_halfVec, normal), 0.0), specularity) * specMult;

            return color * factor;
        }
    `,

    "ps_main": `
        uniform float u_specularity;
        uniform float u_specMult;
        uniform float u_emisMult;
        uniform vec4 u_lightAmbient;

        uniform LayerSettings u_diffuseLayerSettings;
        uniform sampler2D u_diffuseMap;
        uniform LayerSettings u_decalLayerSettings;
        uniform sampler2D u_decalMap;
        uniform LayerSettings u_specularLayerSettings;
        uniform sampler2D u_specularMap;
        uniform LayerSettings u_glossLayerSettings;
        uniform sampler2D u_glossMap;
        uniform LayerSettings u_emissiveLayerSettings;
        uniform sampler2D u_emissiveMap;
        uniform LayerSettings u_emissive2LayerSettings;
        uniform sampler2D u_emissive2Map;
        uniform LayerSettings u_evioLayerSettings;
        uniform sampler2D u_evioMap;
        uniform LayerSettings u_evioMaskLayerSettings;
        uniform sampler2D u_evioMaskMap;
        uniform LayerSettings u_alphaLayerSettings;
        uniform sampler2D u_alphaMap;
        uniform LayerSettings u_alphaMaskLayerSettings;
        uniform sampler2D u_alphaMaskMap;
        uniform LayerSettings u_normalLayerSettings;
        uniform sampler2D u_normalMap;
        uniform LayerSettings u_heightLayerSettings;
        uniform sampler2D u_heightMap;
        uniform LayerSettings u_lightMapLayerSettings;
        uniform sampler2D u_lightMapMap;
        uniform LayerSettings u_aoLayerSettings;
        uniform sampler2D u_aoMap;

        void main() {
            vec3 color;
            vec4 final = u_lightAmbient;
            vec3 normal;
            vec3 lightMapDiffuse;

            if (u_normalLayerSettings.enabled) {
                normal = decodeNormal(u_normalMap);
            } else {
                normal = v_normal;
            }

            float lambertFactor = max(dot(normal, v_lightDir), 0.0);

            if (lambertFactor > 0.0) {
                if (u_diffuseLayerSettings.enabled) {
                    vec4 diffuseColor = computeLayerColor(u_diffuseMap, u_diffuseLayerSettings);

                    color = combineLayerColor(diffuseColor, color, u_diffuseLayerSettings);
                }

                if (u_decalLayerSettings.enabled) {
                    vec4 decalColor = computeLayerColor(u_decalMap, u_decalLayerSettings);

                    color = combineLayerColor(decalColor, color, u_decalLayerSettings);
                }

                vec4 specularColor = computeSpecular(u_specularMap, u_specularLayerSettings, u_specularity, u_specMult, normal);

                if (u_lightMapLayerSettings.enabled) {
                    vec4 lightMapColor = computeLayerColor(u_lightMapMap, u_lightMapLayerSettings) * 2.0;

                    lightMapDiffuse = lightMapColor.rgb;
                }

                //final.rgb = color * lightMapDiffuse + specularColor.rgb;
                final.rgb = (color +specularColor.rgb) * lambertFactor;

                bool addEmissive = false;
                vec3 emissiveColor;
                vec4 tempColor;

                if (u_emissiveLayerSettings.enabled) {
                    tempColor = computeLayerColor(u_emissiveMap, u_emissiveLayerSettings);

                    if (u_emissiveLayerSettings.op == LAYEROP_MOD || u_emissiveLayerSettings.op == LAYEROP_MOD2X || u_emissiveLayerSettings.op == LAYEROP_LERP) {
                        final.rgb = combineLayerColor(tempColor, final.rgb, u_emissiveLayerSettings);
                    } else {
                        emissiveColor = combineLayerColor(tempColor, emissiveColor, u_emissiveLayerSettings);
                        addEmissive = true;
                    }
                }

                if (u_emissive2LayerSettings.enabled) {
                    tempColor = computeLayerColor(u_emissive2Map, u_emissive2LayerSettings);

                    if (!addEmissive && (u_emissive2LayerSettings.op == LAYEROP_MOD || u_emissive2LayerSettings.op == LAYEROP_MOD2X || u_emissive2LayerSettings.op == LAYEROP_LERP)) {
                        final.rgb = combineLayerColor(tempColor, final.rgb, u_emissive2LayerSettings);
                    } else {
                        emissiveColor = combineLayerColor(tempColor, emissiveColor, u_emissive2LayerSettings);
                        addEmissive = true;
                    }
                }

                if (addEmissive) {
                    final.rgb += emissiveColor * u_emisMult;
                }
            }

            gl_FragColor = final;
        }
    `
};
const M3Parser = (function () {
    function Event(reader, version, index) {
        this.version = version;
        this.name = new Reference(reader, index);
        this.unknown0 = readInt32(reader);
        this.unknown1 = readInt16(reader);
        this.unknown2 = readUint16(reader);
        this.matrix = readMatrix(reader);
        this.unknown3 = readInt32(reader);
        this.unknown4 = readInt32(reader);
        this.unknown5 = readInt32(reader);

        if (version > 0) {
            this.unknown6 = readInt32(reader);
            this.unknown7 = readInt32(reader);
        }

        if (version > 1) {
            this.unknown8 = readInt32(reader);
        }
    }

    function BoundingSphere(reader) {
        this.min = readVector3(reader);
        this.max = readVector3(reader);
        this.radius = readFloat32(reader);
    }

    function SD(reader, version, index) {
        this.keys = new Reference(reader, index);
        this.flags = readUint32(reader);
        this.biggestKey = readUint32(reader);
        this.values = new Reference(reader, index);
    }

    function AnimationReference(reader, Func) {
        this.interpolationType = readUint16(reader);
        this.animFlags = readUint16(reader);
        this.animId = readUint32(reader);
        this.initValue = Func(reader);
        this.nullValue = Func(reader);

        skip(reader, 4); // ?
    }

    function BoundingShape(reader) {
        this.shape = readUint32(reader); // 0 cube
        // 1 sphere
        // 2 cylinder
        this.bone = readInt16(reader);
        this.unknown0 = readUint16(reader);
        this.matrix = readMatrix(reader);
        this.unknown1 = readUint32(reader);
        this.unknown2 = readUint32(reader);
        this.unknown3 = readUint32(reader);
        this.unknown4 = readUint32(reader);
        this.unknown5 = readUint32(reader);
        this.unknown6 = readUint32(reader);
        this.size = readVector3(reader);
    }

    function Layer(reader, version, index) {
        this.version = version;
        this.unknown0 = readUint32(reader);
        this.imagePath = new Reference(reader, index);
        this.color = new AnimationReference(reader, readPixel);
        this.flags = readUint32(reader); // 0x4 textureWrapX
        // 0x8 textureWrapY
        // 0x10 invertColor
        // 0x20 clampColor
        // 0x100 useParticleFlipBook
        // 0x200 isVideo
        // 0x400 colorEnabled
        // 0x4000 ignoredFresnelFlag1
        // 0x8000 ignoredFresnelFlag2
        // 0x10000 fresnelLocalTransform
        // 0x20000 fresnelDoNotMirror
        this.uvSource = readUint32(reader);
        this.colorChannelSetting = readUint32(reader); // 0 RGB
        // 1 RGBA
        // 2 A
        // 3 R
        // 4 G
        // 5 B
        this.brightMult = new AnimationReference(reader, readFloat32);
        this.midtoneOffset = new AnimationReference(reader, readFloat32);
        this.unknown1 = readUint32(reader);

        if (version > 23) {
            this.noiseAmp = readFloat32(reader);
            this.noiseFreq = readFloat32(reader);
        }

        this.rttChannel = readInt32(reader);
        this.videoFrameRate = readUint32(reader);
        this.videoStartFrame = readUint32(reader);
        this.videoEndFrame = readInt32(reader);
        this.videoMode = readUint32(reader);
        this.videoSyncTiming = readUint32(reader);
        this.videoPlay = new AnimationReference(reader, readUint32);
        this.videoRestart = new AnimationReference(reader, readUint32);
        this.flipBookRows = readUint32(reader);
        this.flipBookColumns = readUint32(reader);
        this.flipBookFrame = new AnimationReference(reader, readUint16);
        this.uvOffset = new AnimationReference(reader, readVector2);
        this.uvAngle = new AnimationReference(reader, readVector3);
        this.uvTiling = new AnimationReference(reader, readVector2);
        this.unknown2 = new AnimationReference(reader, readUint32);
        this.unknown3 = new AnimationReference(reader, readFloat32);
        this.brightness = new AnimationReference(reader, readFloat32);

        if (version > 23) {
            this.triPlanarOffset = new AnimationReference(reader, readVector3);
            this.triPlanarScale = new AnimationReference(reader, readVector3);
        }

        this.unknown4 = readInt32(reader);
        this.fresnelType = readUint32(reader);
        this.fresnelExponent = readFloat32(reader);
        this.fresnelMin = readFloat32(reader);
        this.fresnelMaxOffset = readFloat32(reader);
        this.unknown5 = readFloat32(reader);

        if (version > 24) {
            this.unknown6 = read(reader, 8);
            this.fresnelInvertedMaskX = readFloat32(reader);
            this.fresnelInvertedMaskY = readFloat32(reader);
            this.fresnelInvertedMaskZ = readFloat32(reader);
            this.fresnelRotationYaw = readFloat32(reader);
            this.fresnelRotationPitch = readFloat32(reader);
            this.unknown7 = readUint32(reader);
        }
    }

    function StandardMaterial(reader, version, index) {
        this.version = version;
        this.name = new Reference(reader, index);
        this.additionalFlags = readUint32(reader); // 0x1 useDepthBlendFalloff
        // 0x4 makesUseOfVertexColor
        // 0x8 makesUseOfVertexAlpha
        // 0x200 ?
        this.flags = readUint32(reader); // 0x1 useVertexColor
        // 0x2 useVertexAlpha
        // 0x4 unfogged
        // 0x8 twoSided
        // 0x10 unshaded
        // 0x20 noShadowsCast
        // 0x40 noHitTest
        // 0x80 noShadowsReceived
        // 0x100 depthPrepass
        // 0x200 useTerrainHDR
        // 0x400 ?
        // 0x800 splatUVfix
        // 0x1000 softBlending
        // 0x2000 ?
        // 0x4000 ?
        // 0x8000 decalLighting
        // 0x10000 transparency
        // 0x20000 ?
        // 0x40000 disableSoft
        // 0x80000 doubleLambert
        // 0x100000 hairLayerSorting
        // 0x200000 acceptSplatsOnly
        // 0x400000 decalRequiredOnLowEnd
        // 0x800000 emissiveRequiredOnLowEnd
        // 0x1000000 specularRequiredOnLowEnd
        // 0x2000000 acceptSplats
        // 0x4000000 backgroundObject
        // 0x10000000 zpFillRequiredOnLowEnd
        // 0x20000000 excludeFromHighlighting
        // 0x40000000 clampOutput
        // 0x80000000 geometryVisible
        this.blendMode = readUint32(reader); // 0 opaque
        // 1 blend
        // 2 additive
        // 3 probably addAlpha
        // 4 mod
        // 5 mod2x
        this.priority = readInt32(reader);
        this.usedRTTChannels = readUint32(reader); // 0x1 channel0
        // 0x2 channel1
        // 0x4 channel2
        // 0x8 channel3
        // 0x10 channel4
        // 0x20 channel5
        // 0x40 channel6
        this.specularity = readFloat32(reader);
        this.depthBlendFalloff = readFloat32(reader);
        this.cutoutThresh = readUint8(reader);
        this.unknown1 = readUint8(reader); // ?
        this.unknown2 = readUint8(reader); // ?
        this.unknown3 = readUint8(reader); // ?
        this.specMult = readFloat32(reader);
        this.emisMult = readFloat32(reader);
        this.diffuseLayer = new Reference(reader, index);
        this.decalLayer = new Reference(reader, index);
        this.specularLayer = new Reference(reader, index);

        if (version > 15) {
            this.glossLayer = new Reference(reader, index);
        } else {
            this.glossLayer = new FakeReference();
        }

        this.emissiveLayer = new Reference(reader, index);
        this.emissive2Layer = new Reference(reader, index);
        this.evioLayer = new Reference(reader, index);
        this.evioMaskLayer = new Reference(reader, index);
        this.alphaMaskLayer = new Reference(reader, index);
        this.alphaMask2Layer = new Reference(reader, index);
        this.normalLayer = new Reference(reader, index);
        this.heightLayer = new Reference(reader, index);
        this.lightMapLayer = new Reference(reader, index);
        this.ambientOcclusionLayer = new Reference(reader, index);

        if (version > 18) {
            this.unknown4 = new Reference(reader, index) // Unknown layer
            this.unknown5 = new Reference(reader, index) // Unknown layer
            this.unknown6 = new Reference(reader, index) // Unknown layer
            this.unknown7 = new Reference(reader, index) // Unknown layer
        }

        this.unknown8 = readUint32(reader); // ?
        this.layerBlendType = readUint32(reader);
        this.emisBlendType = readUint32(reader);
        this.emisMode = readUint32(reader);
        this.specType = readUint32(reader);

        this.unknown9 = new AnimationReference(reader, readFloat32); // ?
        this.unknown10 = new AnimationReference(reader, readUint32); // ?

        if (version > 18) {
            this.unknown11 = read(reader, 12); // ?
        }
    }

    function MaterialReference(reader, version, index) {
        this.materialType = readUint32(reader);
        this.materialIndex = readUint32(reader);
    }

    function Camera(reader, indexEntries, version) {
        this.version = version;
        this.bone = readUint32(reader);
        this.name = parseReferenceString(reader, indexEntries);
        this.fieldOfView = new AnimationReference(reader, readFloat32);
        this.unknown0 = readUint32(reader);
        this.farClip = new AnimationReference(reader, readFloat32);
        this.nearClip = new AnimationReference(reader, readFloat32);
        this.clip2 = new AnimationReference(reader, readFloat32);
        this.focalDepth = new AnimationReference(reader, readFloat32);
        this.falloffStart = new AnimationReference(reader, readFloat32);
        this.falloffEnd = new AnimationReference(reader, readFloat32);
        this.depthOfField = new AnimationReference(reader, readFloat32);
    }
    /*
    function SHBX(reader, indexEntries, version) {
    this.version = version;
    }
    */
    function Light(reader, indexEntries, version) {
        this.version = version;
        this.type = readUint8(reader);
        this.unknown0 = readUint8(reader);
        this.bone = readInt16(reader);
        this.flags = readUint32(reader); // 0x1 shadowCast
        // 0x2 specular
        // 0x4 unknown
        // 0x8 turnOn
        this.unknown1 = readUint32(reader);
        this.unknown2 = readInt32(reader);
        this.lightColor = new AnimationReference(reader, readVector3);
        this.lightIntensity = new AnimationReference(reader, readFloat32);
        this.specularColor = new AnimationReference(reader, readVector3);
        this.specularIntensity = new AnimationReference(reader, readFloat32);
        this.attenuationFar = new AnimationReference(reader, readFloat32);
        this.unknown3 = readFloat32(reader);
        this.attenuationNear = new AnimationReference(reader, readFloat32);
        this.hotSpot = new AnimationReference(reader, readFloat32);
        this.falloff = new AnimationReference(reader, readFloat32);
    }

    function AttachmentPoint(reader, version, index) {
        this.version = version;
        this.unknown = readInt32(reader);
        this.name = new Reference(reader, index);
        this.bone = readUint32(reader);
    }

    function MSEC(reader, version, index) {
        this.unknown0 = readUint32(reader);
        this.boundings = new AnimationReference(reader, BoundingSphere);
    }

    function Batch(reader, version, index) {
        this.unknown0 = readUint32(reader);
        this.regionIndex = readUint16(reader);
        this.unknown1 = readUint32(reader);
        this.materialReferenceIndex = readUint16(reader);
        this.unknown2 = readUint16(reader);
    }

    function Region(reader, version, index) {
        this.unknown0 = readUint32(reader);
        this.unknown1 = readUint32(reader);
        this.firstVertexIndex = readUint32(reader);
        this.verticesCount = readUint32(reader);
        this.firstTriangleIndex = readUint32(reader);
        this.triangleIndicesCount = readUint32(reader);
        this.bonesCount = readUint16(reader);
        this.firstBoneLookupIndex = readUint16(reader);
        this.boneLookupIndicesCount = readUint16(reader);
        this.unknown2 = readUint16(reader);
        this.boneWeightPairsCount = readUint8(reader);
        this.unknown3 = readUint8(reader);
        this.rootBoneIndex = readUint16(reader);

        if (version > 3) {
            this.unknown4 = readUint32(reader);
        }

        if (version > 4) {
            this.unknown5 = read(reader, 8);
        }
    }

    function Division(reader, version, index) {
        this.version = version;
        this.triangles = new Reference(reader, index);
        this.regions = new Reference(reader, index);
        this.batches = new Reference(reader, index);
        this.MSEC = new Reference(reader, index);
        this.unknown0 = readUint32(reader);
    }

    function Bone(reader, version, index) {
        this.version = version;
        this.unknown0 = readInt32(reader);
        this.name = new Reference(reader, index);
        this.flags = readUint32(reader); // 0x1 inheritTranslation
        // 0x2 inheritScale
        // 0x4 inheritRotation
        // 0x10 billboard1
        // 0x40 billboard2
        // 0x100 twoDProjection
        // 0x200 animated
        // 0x400 inverseKinematics
        // 0x800 skinned
        // 0x2000 real -- what does this mean?
        this.parent = readInt16(reader);
        this.unknown1 = readUint16(reader);
        this.location = new AnimationReference(reader, readVector3);
        this.rotation = new AnimationReference(reader, readVector4);
        this.scale = new AnimationReference(reader, readVector3);
        this.visibility = new AnimationReference(reader, readUint32);
    }

    function STS(reader, version, index) {
        this.version = version;
        this.animIds = new Reference(reader, index);

        skip(reader, 16); // ?
    }

    function STG(reader, version, index) {
        this.version = version;
        this.name = new Reference(reader, index);
        this.stcIndices = new Reference(reader, index);
    }

    function STC(reader, version, index) {
        this.version = version;
        this.name = new Reference(reader, index);
        this.runsConcurrent = readUint16(reader);
        this.priority = readUint16(reader);
        this.stsIndex = readUint16(reader);
        this.stsIndexCopy = readUint16(reader); // ?
        this.animIds = new Reference(reader, index);
        this.animRefs = new Reference(reader, index);

        skip(reader, 4); // ?

        this.sd = [
            new Reference(reader, index),
            new Reference(reader, index),
            new Reference(reader, index),
            new Reference(reader, index),
            new Reference(reader, index),
            new Reference(reader, index),
            new Reference(reader, index),
            new Reference(reader, index),
            new Reference(reader, index),
            new Reference(reader, index),
            new Reference(reader, index),
            new Reference(reader, index),
            new Reference(reader, index)
        ];
    }

    function Sequence(reader, version, index) {
        this.version = version;

        skip(reader, 8); // ?

        this.name = new Reference(reader, index);
        this.interval = readUint32Array(reader, 2);
        this.movementSpeed = readFloat32(reader);
        this.flags = readUint32(reader); // 0x1 notLooping
        // 0x2 alwaysGlobal
        // 0x8 globalInPreviewer
        this.frequency = readUint32(reader);

        skip(reader, 12); // ?

        if (version < 2) {
            skip(reader, 4); // ?
        }

        this.boundingSphere = new BoundingSphere(reader);

        skip(reader, 12); // ?
    }

    function Model(reader, version, index) {
        this.version = version;
        this.modelName = new Reference(reader, index);
        this.flags = readUint32(reader); // 0x100000 hasMesh
        this.sequences = new Reference(reader, index);
        this.stc = new Reference(reader, index);
        this.stg = new Reference(reader, index);
        this.unknown0 = readFloat32(reader);
        this.unknown1 = readFloat32(reader);
        this.unknown2 = readFloat32(reader);
        this.unknown3 = readFloat32(reader);
        this.sts = new Reference(reader, index);
        this.bones = new Reference(reader, index);
        this.numberOfBonesToCheckForSkin = readUint32(reader);
        this.vertexFlags = readUint32(reader); // 0x200 hasVertexColors
        // 0x20000 hasVertices
        // 0x40000 useUVChannel1
        // 0x80000 useUVChannel2
        // 0x100000 useUVChannel3
        this.vertices = new Reference(reader, index);
        this.divisions = new Reference(reader, index);
        this.boneLookup = new Reference(reader, index);
        this.boundings = BoundingSphere(reader);
        this.unknown4To20 = readUint32Array(reader, 16);
        this.attachmentPoints = new Reference(reader, index);
        this.attachmentPointAddons = new Reference(reader, index);
        this.ligts = new Reference(reader, index);
        this.shbxData = new Reference(reader, index);
        this.cameras = new Reference(reader, index);
        this.unknown21 = new Reference(reader, index);
        this.materialReferences = new Reference(reader, index);
        this.materials = [
            new Reference(reader, index), // Standard
            new Reference(reader, index), // Displacement
            new Reference(reader, index), // Composite
            new Reference(reader, index), // Terrain
            new Reference(reader, index), // Volume
            new Reference(reader, index), // ?
            new Reference(reader, index)  // Creep

        ];

        if (version > 24) {
            this.materials.push(new Reference(reader, index)); // Volume noise
        }

        if (version > 25) {
            this.materials.push(new Reference(reader, index)); // Splat terrain bake
        }

        if (version > 27) {
            this.materials.push(new Reference(reader, index)); // ?
        }

        if (version > 28) {
            this.materials.push(new Reference(reader, index)); // Lens flare
        }

        this.particleEmitters = new Reference(reader, index);
        this.particleEmitterCopies = new Reference(reader, index);
        this.ribbonEmitters = new Reference(reader, index);
        this.projections = new Reference(reader, index);
        this.forces = new Reference(reader, index);
        this.warps = new Reference(reader, index);
        this.unknown22 = new Reference(reader, index); // ?
        this.rigidBodies = new Reference(reader, index);
        this.unknown23 = new Reference(reader, index); // ?
        this.physicsJoints = new Reference(reader, index);

        if (version > 27) {
            this.clothBehavior = new Reference(reader, index);
        }

        this.unknown24 = new Reference(reader, index); // ?
        this.ikjtData = new Reference(reader, index);
        this.unknown25 = new Reference(reader, index); // ?

        if (version > 24) {
            this.unknown26 = new Reference(reader, index); // ?
        }

        this.partsOfTurrentBehaviors = new Reference(reader, index);
        this.turrentBehaviors = new Reference(reader, index);
        this.absoluteInverseBoneRestPositions = new Reference(reader, index);
        this.tightHitTest = new BoundingShape(reader);
        this.fuzzyHitTestObjects = new Reference(reader, index);
        this.attachmentVolumes = new Reference(reader, index);
        this.attachmentVolumesAddon0 = new Reference(reader, index);
        this.attachmentVolumesAddon1 = new Reference(reader, index);
        this.billboardBehaviors = new Reference(reader, index);
        this.tmdData = new Reference(reader, index);
        this.unknown27 = readUint32(reader); // ?
        this.unknown28 = new Reference(reader, index); // ?

    }

    function MD34(reader, version, index) {
        this.tag = readUint32(reader);
        this.offset = readUint32(reader);
        this.entries = readUint32(reader);
        this.model = new Reference(reader, index);
    }

    function UnsupportedEntry(reader, version, index) {

    }

    function FakeReference() {

    }

    FakeReference.prototype = {
        getAll() {
            return [];
        },

        get() {

        }
    };

    function Reference(reader, index) {
        this.index = index;
        this.entries = readUint32(reader);
        this.id = readUint32(reader);
        this.flags = readUint32(reader);
    }

    Reference.prototype = {
        getAll() {
            let id = this.id;

            // For empty references (e.g. Layer.imagePath)
            if (id === 0 || this.entries === 0) {
                return [];
            }

            return this.index[id].entries;
        },

        get() {
            return this.getAll()[0];
        }
    };

    const TagMapping = {
        // Objects
        [TagToUint("MD34")]: [0, MD34, { 11: 24 }],
        [TagToUint("MODL")]: [0, Model, { 23: 784, 25: 808, 26: 820, 28: 844, 29: 856 }],
        [TagToUint("SEQS")]: [0, Sequence, { 1: 96, 2: 92 }],
        [TagToUint("STC_")]: [0, STC, { 4: 204 }],
        [TagToUint("STG_")]: [0, STG, { 0: 24 }],
        [TagToUint("STS_")]: [0, STS, { 0: 28 }],
        [TagToUint("BONE")]: [0, Bone, { 1: 160 }],
        [TagToUint("DIV_")]: [0, Division, { 2: 52 }],
        [TagToUint("REGN")]: [0, Region, { 3: 36, 4: 40, 5: 48 }],
        [TagToUint("BAT_")]: [0, Batch, { 1: 14 }],
        [TagToUint("MSEC")]: [0, MSEC, { 1: 72 }],
        [TagToUint("MATM")]: [0, MaterialReference, { 0: 8 }],
        [TagToUint("MAT_")]: [0, StandardMaterial, { 15: 268, 16: 280, 17: 280, 18: 280, 19: 340 }],
        [TagToUint("LAYR")]: [0, Layer, { 22: 356, 24: 436, 25: 468, 26: 464 }],
        [TagToUint("EVNT")]: [0, Event, { 0: 96, 1: 104, 2: 108 }],
        [TagToUint("BNDS")]: [0, BoundingSphere, { 0: 28 }],
        [TagToUint("SDEV")]: [0, SD, { 0: 32 }],
        [TagToUint("SDU6")]: [0, SD, { 0: 32 }],
        [TagToUint("SDFG")]: [0, SD, { 0: 32 }],
        [TagToUint("SDS6")]: [0, SD, { 0: 32 }],
        [TagToUint("SDR3")]: [0, SD, { 0: 32 }],
        [TagToUint("SD2V")]: [0, SD, { 0: 32 }],
        [TagToUint("SD3V")]: [0, SD, { 0: 32 }],
        [TagToUint("SD4Q")]: [0, SD, { 0: 32 }],
        [TagToUint("SDCC")]: [0, SD, { 0: 32 }],
        [TagToUint("SDMB")]: [0, SD, { 0: 32 }],
        [TagToUint("FLAG")]: [0, SD, { 0: 32 }],
        // Unsupported entries
        [TagToUint("ATT_")]: [0, null, { 1: 20 }],
        [TagToUint("LITE")]: [0, null, { 7: 212 }],
        [TagToUint("ATVL")]: [0, null, { 0: 116 }],
        [TagToUint("PATU")]: [0, null, { 4: 152 }],
        [TagToUint("TRGD")]: [0, null, { 0: 24 }],
        [TagToUint("DIS_")]: [0, null, { 4: 68 }],
        [TagToUint("CMS_")]: [0, null, { 0: 24 }],
        [TagToUint("CMP_")]: [0, null, { 2: 28 }],
        [TagToUint("TER_")]: [0, null, { 0: 24, 1: 28 }],
        [TagToUint("VOL_")]: [0, null, { 0: 84 }],
        [TagToUint("VON_")]: [0, null, { 0: 268 }],
        [TagToUint("CREP")]: [0, null, { 0: 24, 1: 28 }],
        [TagToUint("STBM")]: [0, null, { 0: 48 }],
        [TagToUint("LFSB")]: [0, null, { 2: 56 }],
        [TagToUint("LFLR")]: [0, null, { 2: 80, 3: 152 }],
        [TagToUint("PAR_")]: [0, null, { 12: 1316, 17: 1460, 18: 1464, 19: 1464, 21: 1464, 22: 1484, 23: 1492, 24: 1496 }],
        [TagToUint("PARC")]: [0, null, { 0: 40 }],
        [TagToUint("PROJ")]: [0, null, { 4: 388, 5: 382 }],
        [TagToUint("PHYJ")]: [0, null, { 0: 180 }],
        [TagToUint("PHCC")]: [0, null, { 0: 76 }],
        [TagToUint("PHAC")]: [0, null, { 0: 32 }],
        [TagToUint("PHCL")]: [0, null, { 2: 128 }],
        [TagToUint("FOR_")]: [0, null, { 1: 104, 2: 104 }],
        [TagToUint("DMSE")]: [0, null, { 0: 4 }],
        [TagToUint("PHSH")]: [0, null, { 1: 132, 3: 300 }],
        [TagToUint("PHRB")]: [0, null, { 2: 104, 4: 80 }],
        [TagToUint("SSGS")]: [0, null, { 1: 108 }],
        [TagToUint("BBSC")]: [0, null, { 0: 48 }],
        [TagToUint("SRIB")]: [0, null, { 0: 272 }],
        [TagToUint("RIB_")]: [0, null, { 6: 748, 8: 756, 9: 760 }],
        [TagToUint("IKJT")]: [0, null, { 0: 32 }],
        [TagToUint("SHBX")]: [0, null, { 0: 64 }],
        [TagToUint("CAM_")]: [0, null, { 3: 180, 5: 264 }],
        [TagToUint("WRP_")]: [0, null, { 1: 132 }],
        // Typed arrays
        [TagToUint("CHAR")]: [1, readCharArray],
        [TagToUint("SCHR")]: [1, readCharArray],
        [TagToUint("U8__")]: [1, readUint8Array],
        [TagToUint("U16_")]: [1, readUint16Array],
        [TagToUint("U32_")]: [1, readUint32Array],
        [TagToUint("I32_")]: [1, readInt32Array],
        [TagToUint("REAL")]: [1, readFloat32Array],
        [TagToUint("VEC2")]: [1, readVector2Array],
        [TagToUint("VEC3")]: [1, readVector3Array],
        [TagToUint("SVC3")]: [1, readVector3Array],
        [TagToUint("VEC4")]: [1, readVector4Array],
        [TagToUint("QUAT")]: [1, readVector4Array],
        [TagToUint("IREF")]: [1, readMatrixArray]
    };

    function IndexEntry(reader, index) {
        this.index = index;
        this.tag = readUint32(reader);
        this.offset = readUint32(reader);

        const entriesCount = readUint32(reader);

        this.version = readUint32(reader);

        const mapping = TagMapping[this.tag];

        if (mapping) {
            const readerOffset = tell(reader);

            seek(reader, this.offset);

            const isTypedArray = mapping[0],
                Func = mapping[1];

            if (isTypedArray) {
                this.entries = Func(reader, entriesCount);
            } else if (Func) {
                let entries = [],
                    entrySizes = mapping[2],
                    index = this.index,
                    version = this.version,
                    entrySize = entrySizes[version];

                if (!entrySize) {
                    throw new Error("Unsupported object version - tag " + UintToTag(this.tag) + " and version " + version);
                }

                for (let i = 0, l = entriesCount; i < l; i++) {
                    entries[i] = new Func(subreader(reader, entrySize), version, index);

                    skip(reader, entrySize);
                }

                this.entries = entries;
            }

            seek(reader, readerOffset);
        } else {
            throw new Error("Unsupported object tag - tag " + UintToTag(this.tag) + " and version " + this.version);
        }
    }

    return (function (reader) {
        const header = new MD34(reader);

        if (header.tag === TagToUint("MD34")) {
            const entries = [];

            seek(reader, header.offset);

            // Read the index entries
            for (let i = 0, l = header.entries; i < l; i++) {
                entries[i] = new IndexEntry(reader, entries);
            }

            return entries[header.model.id].entries[0];
        }
    });
}());
function M3Sequence(sequence) {
    this.name = sequence.name.getAll().join("");
    this.interval = sequence.interval;
    this.movementSpeed = sequence.movementSpeed;
    this.frequency = sequence.frequency;
    this.boundingSphere = sequence.boundingSphere;
}
function M3Sd(sd) {
    this.keys = sd.keys.getAll();
    this.values = sd.values.getAll();
    this.biggestKey = sd.biggestKey;
}

function M3SdContainer(sd) {
    this.sd = sd.map((sd) => new M3Sd(sd));
}

M3SdContainer.prototype = {
    getValue(index, animationReference, frame, runsConcurrent) {
        var sd = this.sd[index];

        if (runsConcurrent) {
            frame = frame % sd.biggestKey;
        }

        var keys = sd.keys;
        var values = sd.values;

        const interval = this.getInterval(keys, frame);

        var a = interval[0];
        var b = interval[1];
        var length = keys.length;

        if (a === length) {
            if (b === length) {
                return animationReference.initValue;
            } else {
                return values[b];
            }
        }

        if (b === length || a >= b) {
            return values[a];
        }

        var t = Math.clamp((frame - keys[a]) / (keys[b] - keys[a]), 0, 1);
        
        // M3 doesn't seem to have hermite/bezier interpolations, so just feed 0 to the in/out tangents since they are not used anyway
        return Interpolator.interpolate(values[a], 0, 0, values[b], t, animationReference.interpolationType);
    },

    getInterval(keys, frame) {
        var interval = vec2.heap;

        var a = keys.length;
        var b = 0;

        while (b !== keys.length && frame > keys[b]) {
            a = b;
            b++;
        }

        interval[0] = a;
        interval[1] = b;

        return interval;
    }
};
function M3Sts(sts) {
    const animIds = sts.animIds.getAll();

    this.animIds = {};

    // Allows direct checks instead of loops
    for (let i = 0, l = animIds.length; i < l; i++) {
        this.animIds[animIds[i]] = i;
    }
}

M3Sts.prototype = {
    hasData(animRef) {
        return !!this.animIds[animRef.animId];
    }
};
function M3Stc(stc) {
    const animIds = stc.animIds.getAll();

    this.name = stc.name.getAll().join("");
    this.runsConcurrent = stc.runsConcurrent;
    this.priority = stc.priority;
    this.stsIndex = stc.stsIndex;

    const animRefs = new Uint16Array(stc.animRefs.getAll().buffer);

    this.animRefs = [];

    // Allows direct checks instead of loops
    for (let i = 0, l = animIds.length; i < l; i++) {
        this.animRefs[animIds[i]] = [animRefs[i * 2 + 1], animRefs[i * 2]];
    }

    this.sd = stc.sd.map((sd) => new M3SdContainer(sd.getAll()));
}

M3Stc.prototype = {
    getValue(animRef, instance) {
        const ref = this.animRefs[animRef.animId];

        if (ref) {
            return this.sd[ref[0]].getValue(ref[1], animRef, instance.frame, this.runsConcurrent);
        }

        return animRef.initValue;
    }
};
function M3Stg(stg, sts, stc) {
    this.name = stg.name.getAll().join("");
    this.stcIndices = stg.stcIndices.getAll();
    this.sts = sts;
    this.stc = stc;
}

M3Stg.prototype = {
    getValue(animRef, instance) {
        const stcIndices = this.stcIndices,
            stcs = this.stc,
            stss = this.sts;

        for (let i = 0, l = stcIndices.length; i < l; i++) {
            const stc = stcs[stcIndices[i]];
                sts = stss[stc.stsIndex];

            // First check if this STC actually has data for this animation reference
            if (sts.hasData(animRef)) {
                // Since this STC has data for this animation reference, return it
                return stc.getValue(animRef, instance);
            }
        }

        // No STC referenced by the STG had data for this animation reference
        return animRef.initValue;
    }
};
function M3Skeleton(instance) {
    const model = instance.model,
        bones = model.bones,
        boneLookup = model.boneLookup;

    Skeleton.call(this, instance, bones.length);

    this.instance = instance;
    this.modelNodes = bones;
    this.initialReference = model.initialReference;
    this.sts = model.sts;
    this.stc = model.stc;
    this.stg = model.stg;
    this.boneLookup = boneLookup;
    
    // Set the bone parent references
    for (var i = 0, l = bones.length; i < l; i++) {
        this.nodes[i].setParent(this.getNode(bones[i].parent));
    }

    this.boneArray = null;
}

M3Skeleton.prototype = {
    update() {
        const instance = this.instance,
            nodes = this.nodes,
            modelNodes = this.modelNodes;

        for (let i = 0, l = nodes.length; i < l; i++) {
            const modelNode = modelNodes[i],
                location = this.getValue(modelNode.location, instance),
                rotation = this.getValue(modelNode.rotation, instance),
                scale = this.getValue(modelNode.scale, instance);

            nodes[i].setTransformation(location, rotation, scale);
        }

        const sequence = instance.sequence;

        var hwbones = this.boneArray;
        var initialReferences = this.initialReference;
        var boneLookup = this.boneLookup;
        var finalMatrix;

        if (sequence === -1) {
            finalMatrix = this.parentNode.worldMatrix;
        } else {
            finalMatrix = mat4.heap;
        }

        for (var i = 0, l = boneLookup.length; i < l; i++) {
            if (sequence !== -1) {
                const bone = boneLookup[i];

                mat4.multiply(finalMatrix, nodes[bone].worldMatrix, initialReferences[bone]);
            }

            hwbones.set(finalMatrix, i * 16);
        }
    },

    getValue(animRef, instance) {
        const sequence = instance.sequence;

        if (sequence !== -1) {
            return this.stg[sequence].getValue(animRef, instance)
        }

        return animRef.initValue;
    }
};

mix(M3Skeleton.prototype, Skeleton.prototype);
function M3BoundingShape(boundingshape, bones, gl) {
    this.bone = boundingshape.bone;
    this.matrix = boundingshape.matrix;
    this.name = bones[boundingshape.bone].name;

    var size = boundingshape.size;
    var shape;

    if (boundingshape.shape === 0) {
        shape = gl.createCube(-size[0], -size[1], -size[2], size[0], size[1], size[2]);
    } else if (boundingshape.shape === 1) {
        shape = gl.createSphere(0, 0, 0, 9, 9, size[0]);
    } else {
        shape = gl.createCylinder(0, 0, 0, size[0], size[1], 9);
    }

    this.shape = shape;
}
function M3Region(region, triangles, elementArray, offset, gl) {
    let firstVertexIndex = region.firstVertexIndex,
        triangleIndicesCount = region.triangleIndicesCount,
        firstTriangleIndex = region.firstTriangleIndex;

    // Note for implementors: the one original vertex indices array could be used with access to the base-vertex draw elements function.
    // See https://www.opengl.org/sdk/docs/man3/xhtml/glDrawElementsBaseVertex.xml
    // firstTriangleIndex is the indices offset.
    // firstVertexIndex is the base vertex.
    for (let i = 0; i < triangleIndicesCount; i++) {
        elementArray[offset + i] = triangles[firstTriangleIndex + i] + firstVertexIndex;
    }

    this.gl = gl;
    this.firstBoneLookupIndex = region.firstBoneLookupIndex;
    this.boneWeightPairsCount = region.boneWeightPairsCount;
    this.offset = offset * 2;
    this.elements = triangleIndicesCount;
}

M3Region.prototype = {
    render(shader, instances) {
        let gl = this.gl;

        gl.uniform1f(shader.uniforms.get("u_firstBoneLookupIndex"), this.firstBoneLookupIndex);
        gl.uniform1f(shader.uniforms.get("u_boneWeightPairsCount"), this.boneWeightPairsCount);

        gl.extensions.instancedArrays.drawElementsInstancedANGLE(gl.TRIANGLES, this.elements, gl.UNSIGNED_SHORT, this.offset, instances);
    },
    
    getPolygonCount() {
        return this.elements / 3;
    }
};
const M3LayerTypeToTextureUnit = {
    diffuse: 1,
    decal: 2,
    specular: 3,
    gloss: 4,
    emissive: 5,
    emissive2: 6,
    evio: 7,
    evioMask: 8,
    alphaMask: 9,
    alphaMask2: 10,
    normal: 11,
    heightMap: 12,
    lightMap: 13,
    ao: 14
};

function M3Layer(material, layer, type, op) {
    var model = material.model;
    var pathSolver = model.pathSolver;;

    this.active = false;
    this.layer = layer;
    this.gl = material.gl;

    var uniform = "u_" + type;

    var settings = uniform + "LayerSettings.";

    this.uniformMap = {
        map: uniform + "Map",
        enabled: settings + "enabled",
        op: settings + "op",
        channels: settings + "channels",
        teamColorMode: settings + "teamColorMode",
        invert: settings + "invert",
        clampResult: settings + "clampResult",
        uvCoordinate: settings + "uvCoordinate"
    };

    // Since Gloss doesn't exist in all versions
    if (layer) {
        let source = layer.imagePath.getAll().join("");

        if (source.length !== 0) {
            source = source.replace("\0", "").toLowerCase();

            this.source = source;

            this.texture = model.env.load(source, pathSolver);

            this.active = true;

            var uvSource = layer.uvSource;
            var flags = layer.flags;

            this.flags = flags;
            this.colorChannels = layer.colorChannelSetting;

            this.model = model;
            this.type = type;
            this.op = op;

            var uvCoordinate = 0;

            if (uvSource === 1) {
                uvCoordinate = 1;
            } else if (uvSource === 9) {
                uvCoordinate = 2;
            } else if (uvSource === 10) {
                uvCoordinate = 3;
            }

            this.uvCoordinate = uvCoordinate;

            this.textureUnit = M3LayerTypeToTextureUnit[type];

            this.invert = flags & 0x10;
            this.clampResult = flags & 0x20;

            // I am not sure if the emissive team color mode is even used, since so far combineColors takes care of it.
            this.teamColorMode = (type === "diffuse") & 1;
        }
    }
}

M3Layer.prototype = {
    bind(shader) {
        const gl = this.gl,
            uniformMap = this.uniformMap,
            uniforms = shader.uniforms,
            active = this.active;

        gl.uniform1f(uniforms.get(uniformMap.enabled), active);

        if (active) {
            gl.uniform1i(uniforms.get(uniformMap.map), this.textureUnit);
            this.model.bindTexture(this.texture, this.textureUnit);
            
            gl.uniform1f(uniforms.get(uniformMap.op), this.op);
            gl.uniform1f(uniforms.get(uniformMap.channels), this.colorChannels);
            gl.uniform1f(uniforms.get(uniformMap.teamColorMode), this.teamColorMode);

            // Alpha is probably unknown12. Can this be confirmed?
            // Many of these flags seem to be incorrect
            //gl.setParameter(uniform + "multAddAlpha", [this.model.getValue(this.rgbMultiply, sequence, frame), this.model.getValue(this.rgbAdd, sequence, frame), 0]);
            //gl.setParameter(uniform + "useAlphaFactor", 0);

            gl.uniform1f(uniforms.get(uniformMap.invert), this.invert);

            //gl.setParameter(uniform + "multColor", 0);
            //gl.setParameter(uniform + "addColor", 0);

            gl.uniform1f(uniforms.get(uniformMap.clampResult), this.clampResult);

            //gl.setParameter(uniform + "useConstantColor", this.flags && 0x400);
            //gl.setParameter(uniform + "constantColor", this.model.getValue(this.color, sequence, frame));
            //gl.setParameter(settings + "uvSource", this.uvSource);

            gl.uniform1f(uniforms.get(uniformMap.uvCoordinate), this.uvCoordinate);
        }
    },

    unbind(shader) {
        if (this.active) {
            this.gl.uniform1f(shader.uniforms.get(this.uniformMap.enabled), 0);
        }
    }
};
function M3StandardMaterial(model, material) {
    this.model = model;
    this.gl = model.env.gl;

    this.name = material.name.getAll().join("");
    this.specialFlags = material.specialFlags;
    this.flags = material.flags;
    this.blendMode = material.blendMode;
    this.priority = material.priority;
    this.specularity = material.specularity;
    this.specMult = material.specMult;
    this.emisMult = material.emisMult;
    this.layerBlendType = material.layerBlendType;
    this.emisBlendType = material.emisBlendType;
    this.emisMode = material.emisMode;
    this.doubleSided = material.flags & 0x8;

    this.layers = [
        new M3Layer(this, material.diffuseLayer.get(), "diffuse", 2),
        new M3Layer(this, material.decalLayer.get(), "decal", 2),
        new M3Layer(this, material.specularLayer.get(), "specular", 2),
        new M3Layer(this, material.glossLayer.get(), "gloss", 2),
        new M3Layer(this, material.emissiveLayer.get(), "emissive", material.emisBlendType),
        new M3Layer(this, material.emissive2Layer.get(), "emissive2", material.emisMode),
        new M3Layer(this, material.evioLayer.get(), "evio", 2),
        new M3Layer(this, material.evioMaskLayer.get(), "evioMask", 2),
        new M3Layer(this, material.alphaMaskLayer.get(), "alphaMask", 2),
        new M3Layer(this, material.alphaMask2Layer.get(), "alphaMask2", 2),
        new M3Layer(this, material.normalLayer.get(), "normal", 2),
        new M3Layer(this, material.heightLayer.get(), "heightMap", 2),
        new M3Layer(this, material.lightMapLayer.get(), "lightMap", 2),
        new M3Layer(this, material.ambientOcclusionLayer.get(), "ao", 2)
    ];
}

M3StandardMaterial.prototype = {
    bindCommon() {
        const gl = this.gl;

        if (this.blendMode === 1) {
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.ONE, gl.ONE);
        } else if (this.blendMode === 2) {
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.ONE, gl.ONE);
        } else {
            gl.disable(gl.BLEND);
        }

        if (this.doubleSided) {
            gl.disable(gl.CULL_FACE);
        } else {
            gl.enable(gl.CULL_FACE);
        }

        // Not sure why it was disabled, or when to disable it
        gl.enable(gl.DEPTH_TEST);
    },

    bind(shader) {
        const gl = this.gl;

        this.bindCommon();

        gl.uniform1f(shader.uniforms.get("u_specularity"), this.specularity);
        gl.uniform1f(shader.uniforms.get("u_specMult"), this.specMult);
        gl.uniform1f(shader.uniforms.get("u_emisMult"), this.emisMult);
        gl.uniform4fv(shader.uniforms.get("u_lightAmbient"), [0.02, 0.02, 0.02, 0]);

        const layers = this.layers;

        layers[0].bind(shader);
        layers[1].bind(shader);
        layers[2].bind(shader);
        layers[4].bind(shader);
        layers[5].bind(shader);
        layers[10].bind(shader);
        layers[12].bind(shader);
    },

    unbind(shader) {
        const gl = this.gl;

        gl.disable(gl.BLEND);
        gl.enable(gl.CULL_FACE);

        const layers = this.layers;

        layers[0].unbind(shader);
        layers[1].unbind(shader);
        layers[2].unbind(shader);
        layers[4].unbind(shader);
        layers[5].unbind(shader);
        layers[10].unbind(shader);
        layers[12].unbind(shader);
    },

    bindDiffuse(shader) {
        this.bindCommon();

        this.layers[0].bind(shader);
    },

    bindSpecular(shader) {
        const gl = this.gl;

        this.bindCommon();

        gl.uniform1f(shader.uniforms.get("u_specularity"), this.specularity);
        gl.uniform1f(shader.uniforms.get("u_specMult"), this.specMult);

        this.layers[2].bind(shader);
    },

    bindNormalMap(shader) {
        this.bindCommon();

        this.layers[10].bind(shader);
    },

    bindEmissive(shader) {
        this.bindCommon();

        this.gl.uniform1f(shader.uniforms.get("u_emisMult"), this.emisMult);

        this.layers[4].bind(shader);
        this.layers[5].bind(shader);
    },

    bindDecal(shader) {
        this.bindCommon();

        this.layers[1].bind(shader);
    }
};
/**
 * @class
 * @classdesc An M3 bucket.
 * @extends Bucket
 * @memberOf M3
 * @param {M3ModelView} env The model view that this bucket belongs to.
 */
function M3Bucket(modelView) {
    Bucket.call(this, modelView);

    const model = this.model;
    const gl = model.gl;

    this.gl = gl;

    // POT required because for some reason, on some drivers, NPOT makes rendering go crazy.
    var numberOfBones = Math.powerOfTwo(model.initialReference.length);
    
    this.boneArrayInstanceSize = numberOfBones * 16;
    this.boneArray = new Float32Array(this.boneArrayInstanceSize * this.size);

    this.updateBoneTexture = new Uint8Array([1]);
    this.boneTexture = gl.createTexture();
    this.boneTextureWidth = numberOfBones * 4;
    this.boneTextureHeight = this.size;
    this.vectorSize = 1 / this.boneTextureWidth;
    this.rowSize = 1 / this.boneTextureHeight;

    gl.activeTexture(gl.TEXTURE15);
    gl.bindTexture(gl.TEXTURE_2D, this.boneTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.boneTextureWidth, this.boneTextureHeight, 0, gl.RGBA, gl.FLOAT, null);

    // Team colors (per instance)
    this.updateTeamColors = new Uint8Array(1);
    this.teamColorArray = new Uint8Array(this.size);
    this.teamColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.teamColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.teamColorArray, gl.DYNAMIC_DRAW);

    // Tint color (per instance)
    this.updateTintColors = new Uint8Array(1);
    this.tintColorArray = new Uint8Array(3 * this.size).fill(255); // Tint color initialized to white
    this.tintColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, this.tintColorBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, this.tintColorArray, gl.DYNAMIC_DRAW);

    // Batch visibility (per instance per batch)
    this.updateBatches = new Uint8Array(model.batches.length);
    this.batchVisibilityArrays = [];
    this.batchVisibilityBuffers = [];

    for (var i = 0, l = model.batches.length; i < l; i++) {
        this.batchVisibilityArrays[i] = new Uint8Array(this.size);
        this.batchVisibilityBuffers[i] = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.batchVisibilityBuffers[i]);
        gl.bufferData(gl.ARRAY_BUFFER, this.batchVisibilityArrays[i], gl.DYNAMIC_DRAW);
    }
}

M3Bucket.prototype = {
    update() {
        const gl = this.gl,
            size = this.instances.length;

        //this.updateBatches.fill(0);

        Bucket.prototype.update.call(this);

        //if (this.updateBoneTexture[0]) {
            gl.activeTexture(gl.TEXTURE15);
            gl.bindTexture(gl.TEXTURE_2D, this.boneTexture);
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.boneTextureWidth, size, gl.RGBA, gl.FLOAT, this.boneArray);
            //console.log(this.boneTextureWidth, size)

            //this.updateBoneTexture[0] = 0;
        //}

        if (this.updateTeamColors[0]) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.teamColorBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.teamColorArray.subarray(0, size));

            this.updateTeamColors[0] = 0;
        }

        if (this.updateTintColors[0]) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.tintColorBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.tintColorArray.subarray(0, 3 * size));

            this.updateTintColors[0] = 0;
        }
        /*
        for (var i = 0, l = this.batchVisibilityArrays.length; i < l; i++) {
            if (this.updateBatches[i]) {
                gl.bindBuffer(gl.ARRAY_BUFFER, this.batchVisibilityBuffers[i]);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.batchVisibilityArrays[i].subarray(0, size));

                gl.bindBuffer(gl.ARRAY_BUFFER, this.geosetColorBuffers[i]);
                gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.geosetColorArrays[i].subarray(0, 4 * size));
            }
        }
        */
    },

    getSharedData(index) {
        var data = {
            bucket: this,
            boneArray: new Float32Array(this.boneArray.buffer, this.boneArrayInstanceSize * 4 * index, this.boneArrayInstanceSize),
            teamColorArray: new Uint8Array(this.teamColorArray.buffer, index, 1),
            tintColorArray: new Uint8Array(this.tintColorArray.buffer, 3 * index, 3),
            batchVisibilityArrays: []
        };

        for (var i = 0, l = this.batchVisibilityArrays.length; i < l; i++) {
            data.batchVisibilityArrays[i] = new Uint8Array(this.batchVisibilityArrays[i].buffer, index, 1);
        }

        return data;
    }
};

mix(M3Bucket.prototype, Bucket.prototype);
/**
 * @class
 * @classdesc An M3 model view.
 * @extends ModelView
 * @memberOf M3
 * @param {M3Model} model The model that this view belongs to.
 */
function M3ModelView(model) {
    ModelView.call(this, model);

    /** @member {Texture[]} */
    this.textures = [];
}

mix(M3ModelView.prototype, ModelView.prototype);
/**
 * @class
 * @classdesc A Starcraft 2 model.
 * @extends Model
 * @memberOf M3
 * @param {ModelViewer} env The model viewer object that this texture belongs to.
 * @param {function} pathSolver A function that solves paths. See more {@link PathSolver here}.
 */
function M3Model(env, pathSolver) {
    Model.call(this, env, pathSolver);
}

M3Model.prototype = {
    get Handler() {
        return M3;
    },

    initialize(src) {
        var parser = M3Parser(new BinaryReader(src));

        if (!parser) {
            this.onerror("InvalidSource", "WrongMagicNumber");
            return false;
        }

        var i, l;
        var div = parser.divisions.get();

        this.parser = parser;
        this.name = parser.modelName.getAll().join("");

        this.setupGeometry(parser, div);

        this.batches = [];
        this.materials = [[], []]; // 2D array for the possibility of adding more material types in the future
        this.materialMaps = parser.materialReferences.getAll();

        var materialMaps = this.materialMaps;
        var materials = parser.materials[0].getAll();
        var batches = [];

        // Create concrete material objects for standard materials
        for (i = 0, l = materials.length; i < l; i++) {
            this.materials[1][i] = new M3StandardMaterial(this, materials[i]);
        }

        const divBatches = div.batches.getAll();

        // Create concrete batch objects
        for (i = 0, l = divBatches.length; i < l; i++) {
            var batch = divBatches[i];
            var regionId = batch.regionIndex;
            var materialMap = materialMaps[batch.materialReferenceIndex];

            if (materialMap.materialType === 1) {
                batches.push({ regionId: regionId, region: this.regions[regionId], material: this.materials[1][materialMap.materialIndex] });
            }
        }

        /*
        var batchGroups = [[], [], [], [], [], []];

        for (i = 0, l = batches.length; i < l; i++) {
        var blendMode = batches[i].material.blendMode;

        batchGroups[blendMode].push(batches[i]);
        }

        function sortByPriority(a, b) {
        var a = a.material.priority;
        var b = b.material.priority;

        if (a < b) {
        return 1;
        } else if (a == b) {
        return 0;
        } else {
        return -1;
        }
        }

        for (i = 0; i < 6; i++) {
        batchGroups[i].sort(sortByPriority);
        }
        */
        /*
        // In the EggPortrait model the batches seem to be sorted by blend mode. Is this true for every model?
        this.batches.sort(function (a, b) {
        var ba = a.material.blendMode;
        var bb = b.material.blendMode;

        if (ba < bb) {
        return -1;
        } else if (ba == bb) {
        return 0;
        } else {
        return 1;
        }
        });
        */

        //this.batches = batchGroups[0].concat(batchGroups[1]).concat(batchGroups[2]).concat(batchGroups[3]).concat(batchGroups[4]).concat(batchGroups[5]);
        
        this.batches = batches;

        var sts = parser.sts.getAll();
        var stc = parser.stc.getAll();
        var stg = parser.stg.getAll();

        this.initialReference = parser.absoluteInverseBoneRestPositions.getAll();
        this.bones = parser.bones.getAll();
        this.boneLookup = parser.boneLookup.getAll();


        let sequences = parser.sequences.getAll();

        this.sequences = [];

        for (i = 0, l = sequences.length; i < l; i++) {
            this.sequences[i] = new M3Sequence(sequences[i]);
        }

        this.sts = [];
        this.stc = [];
        this.stg = [];

        for (i = 0, l = sts.length; i < l; i++) {
            this.sts[i] = new M3Sts(sts[i]);
        }

        for (i = 0, l = stc.length; i < l; i++) {
            this.stc[i] = new M3Stc(stc[i]);
        }

        for (i = 0, l = stg.length; i < l; i++) {
            this.stg[i] = new M3Stg(stg[i], this.sts, this.stc);
        }

        this.addGlobalAnims();

        /*
        if (parser.fuzzyHitTestObjects.length > 0) {
            for (i = 0, l = parser.fuzzyHitTestObjects.length; i < l; i++) {
                this.boundingShapes[i] = new M3BoundingShape(parser.fuzzyHitTestObjects[i], parser.bones, gl);
            }
        }
        */
        /*
        if (parser.particleEmitters.length > 0) {
        this.particleEmitters = [];

        for (i = 0, l = parser.particleEmitters.length; i < l; i++) {
        this.particleEmitters[i] = new M3ParticleEmitter(parser.particleEmitters[i], this);
        }
        }
        */

        //this.attachments = parser.attachmentPoints;
        //this.cameras = parser.cameras;

        return true;
    },

    setupGeometry(parser, div) {
        const gl = this.env.gl;

        var i, l;
        var uvSetCount = 1;
        var vertexFlags = parser.vertexFlags;

        if (vertexFlags & 0x40000) {
            uvSetCount = 2;
        } else if (vertexFlags & 0x80000) {
            uvSetCount = 3;
        } else if (vertexFlags & 0x100000) {
            uvSetCount = 4;
        }

        var regions = div.regions.getAll();
        var totalElements = 0;
        var offsets = [];

        for (i = 0, l = regions.length; i < l; i++) {
            offsets[i] = totalElements;
            totalElements += regions[i].triangleIndicesCount;
        }

        var elementArray = new Uint16Array(totalElements);

        this.regions = [];

        const triangles = div.triangles.getAll();

        for (i = 0, l = regions.length; i < l; i++) {
            this.regions.push(new M3Region(regions[i], triangles, elementArray, offsets[i], gl));
        }

        this.elementBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, elementArray, gl.STATIC_DRAW);

        var arrayBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, arrayBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, parser.vertices.getAll(), gl.STATIC_DRAW);

        this.arrayBuffer = arrayBuffer;
        this.vertexSize = (7 + uvSetCount) * 4;
        this.uvSetCount = uvSetCount;
    },

    mapMaterial(index) {
        var materialMap = this.materialMaps[index];

        return this.materials[materialMap.materialType][materialMap.materialIndex];
    },

    addGlobalAnims() {
    /*
    var i, l;
    var glbirth, glstand, gldeath;
    var stgs = this.stg;
    var stg, name;

    for (i = 0, l = stgs.length; i < l; i++) {
    stg = stgs[i];
    name = stg.name.toLowerCase(); // Because obviously there will be a wrong case in some model...

    if (name === "glbirth") {
    glbirth = stg;
    } else if (name === "glstand") {
    glstand = stg;
    } else if (name === "gldeath") {
    gldeath = stg;
    }
    }

    for (i = 0, l = stgs.length; i < l; i++) {
    stg = stgs[i];
    name = stg.name.toLowerCase(); // Because obviously there will be a wrong case in some model...

    if (name !== "glbirth" && name !== "glstand" && name !== "gldeath") {
    if (name.indexOf("birth") !== -1 && glbirth) {
    stg.stcIndices = stg.stcIndices.concat(glbirth.stcIndices);
    } else  if (name.indexOf("death") !== -1 && gldeath) {
    stg.stcIndices = stg.stcIndices.concat(gldeath.stcIndices);
    } else if (glstand) {
    stg.stcIndices = stg.stcIndices.concat(glstand.stcIndices);
    }
    }
    }
    */
    },

    getValue(animRef, sequence, frame) {
        if (sequence !== -1) {
            return this.stg[sequence].getValue(animRef, frame)
        } else {
            return animRef.initValue;
        }
    },

    bindShared(bucket) {
        let gl = this.gl,
            shader = this.shader,
            vertexSize = this.vertexSize,
            instancedArrays = gl.extensions.instancedArrays,
            attribs = shader.attribs,
            uniforms = shader.uniforms;

        // Team colors
        let teamColorAttrib = attribs.get("a_teamColor");
        gl.bindBuffer(gl.ARRAY_BUFFER, bucket.teamColorBuffer);
        gl.vertexAttribPointer(teamColorAttrib, 1, gl.UNSIGNED_BYTE, false, 1, 0);
        instancedArrays.vertexAttribDivisorANGLE(teamColorAttrib, 1);

        // Tint colors
        let tintColorAttrib = attribs.get("a_tintColor");
        gl.bindBuffer(gl.ARRAY_BUFFER, bucket.tintColorBuffer);
        gl.vertexAttribPointer(tintColorAttrib, 3, gl.UNSIGNED_BYTE, true, 3, 0); // normalize the colors from [0, 255] to [0, 1] here instead of in the pixel shader
        instancedArrays.vertexAttribDivisorANGLE(tintColorAttrib, 1);

        let instanceIdAttrib = attribs.get("a_InstanceID");
        gl.bindBuffer(gl.ARRAY_BUFFER, bucket.instanceIdBuffer);
        gl.vertexAttribPointer(instanceIdAttrib, 1, gl.UNSIGNED_SHORT, false, 2, 0);
        instancedArrays.vertexAttribDivisorANGLE(instanceIdAttrib, 1);

        gl.activeTexture(gl.TEXTURE15);
        gl.bindTexture(gl.TEXTURE_2D, bucket.boneTexture);
        gl.uniform1i(uniforms.get("u_boneMap"), 15);
        gl.uniform1f(uniforms.get("u_vector_size"), bucket.vectorSize);
        gl.uniform1f(uniforms.get("u_row_size"), bucket.rowSize);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.arrayBuffer);
        gl.vertexAttribPointer(attribs.get("a_position"), 3, gl.FLOAT, false, vertexSize, 0);
        gl.vertexAttribPointer(attribs.get("a_weights"), 4, gl.UNSIGNED_BYTE, false, vertexSize, 12);
        gl.vertexAttribPointer(attribs.get("a_bones"), 4, gl.UNSIGNED_BYTE, false, vertexSize, 16);
    },

    bind(bucket) {
        const gl = this.gl,
            webgl = this.env.webgl;

        var vertexSize = this.vertexSize;
        var uvSetCount = this.uvSetCount;

        // HACK UNTIL I IMPLEMENT MULTIPLE SHADERS AGAIN
        var shader = M3.standardShader;
        webgl.useShaderProgram(shader);
        this.shader = shader;

        this.bindShared(bucket);

        let instancedArrays = webgl.extensions.instancedArrays,
            attribs = shader.attribs,
            uniforms = shader.uniforms;

        gl.vertexAttribPointer(attribs.get("a_normal"), 4, gl.UNSIGNED_BYTE, false, vertexSize, 20);

        for (let i = 0; i < uvSetCount; i++) {
            gl.vertexAttribPointer(attribs.get("a_uv" + i), 2, gl.SHORT, false, vertexSize, 24 + i * 4);
        }

        gl.vertexAttribPointer(attribs.get("a_tangent"), 4, gl.UNSIGNED_BYTE, false, vertexSize, 24 + uvSetCount * 4);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementBuffer);

        let camera = bucket.modelView.scene.camera;

        gl.uniformMatrix4fv(uniforms.get("u_mvp"), false, camera.worldProjectionMatrix);
        gl.uniformMatrix4fv(uniforms.get("u_mv"), false, camera.worldMatrix);

        gl.uniform3fv(uniforms.get("u_eyePos"), camera.worldLocation);
        gl.uniform3fv(uniforms.get("u_lightPos"), M3.lightPosition);
    },
    
    unbind() {
        let instancedArrays = this.gl.extensions.instancedArrays,
            shader = this.shader,
            attribs = shader.attribs;

        instancedArrays.vertexAttribDivisorANGLE(attribs.get("a_teamColor"), 0);
        instancedArrays.vertexAttribDivisorANGLE(attribs.get("a_tintColor"), 0);
        instancedArrays.vertexAttribDivisorANGLE(attribs.get("a_InstanceID"), 0);
    },

    renderBatch(bucket, batch) {
        let shader = this.shader,
            region = batch.region,
            material = batch.material;

        material.bind(shader);

        region.render(shader, bucket.instances.length);

        material.unbind(shader); // This is required to not use by mistake layers from this material that were bound and are not overwritten by the next material
    },

    renderOpaque(bucket) {
        const batches = this.batches;

        if (batches.length) {
            //const updateBatches = bucket.updateBatches;

            this.bind(bucket);

            for (let i = 0, l = batches.length; i < l; i++) {
                const batch = batches[i];

                //if (updateBatches[batch.index]) {
                    this.renderBatch(bucket, batch);
                //}
            }

            this.unbind();
        }
    },

    renderTranslucent(bucket) {

    },

    renderEmitters(bucket) {
    /*
    if (this.particleEmitters) {
    ctx.disable(ctx.CULL_FACE);

    for (i = 0, l = this.particleEmitters.length; i < l; i++) {
    gl.bindShader("particles");

    gl.bindMVP("u_mvp");

    this.particleEmitters[i].render();
    }

    ctx.enable(ctx.CULL_FACE);
    }
    */
    },

    bindTexture(texture, unit) {
        this.env.webgl.bindTexture(texture, unit);
    }
};

mix(M3Model.prototype, Model.prototype);
/**
 * @class
 * @classdesc An M3 model instance.
 * @extends ModelInstance
 * @memberOf M3
 * @param {ModelViewer} env The model viewer object that this texture belongs to.
 */
function M3ModelInstance(env) {
    ModelInstance.call(this, env);
}

M3ModelInstance.prototype = {
    initialize() {
        this.skeleton = new M3Skeleton(this);

        this.sequence = -1;
        this.frame = 0;
        this.sequenceLoopMode = 0;
    },

    setSharedData(sharedData) {
        this.bucket = sharedData.bucket;

        this.skeleton.boneArray = sharedData.boneArray;

        // Update once at setup, since it might not be updated later, depending on sequence variancy
        this.skeleton.update();

        this.teamColorArray = sharedData.teamColorArray;
        this.tintColorArray = sharedData.tintColorArray;
    },

    update() {
        const env = this.env;

        var i, l;
        var sequenceId = this.sequence;
        var allowCreate = false;

        if (sequenceId !== -1) {
            var sequence = this.model.sequences[sequenceId];

            var interval = sequence.interval;

            this.frame += env.frameTime;

            if (this.frame > interval[1]) {
                if ((this.sequenceLoopMode === 0 && !(sequence.flags & 0x1)) || this.sequenceLoopMode === 2) {
                    this.frame = 0;
                } else {
                    this.frame = interval[1];
                }

                this.dispatchEvent({ type: "seqend" });
            }

            allowCreate = true;

            this.skeleton.update();
        }
        //this.bucket.updateBoneTexture[0] = 1;

        /*
        if (this.particleEmitters) {
        for (i = 0, l = this.particleEmitters.length; i < l; i++) {
        this.particleEmitters[i].update(allowCreate, sequenceId, this.frame);
        }
        }
        */
    },

    // This is overriden in order to update the skeleton when the parent node changes
    recalculateTransformation() {
        Node.prototype.recalculateTransformation.call(this);

        if (this.rendered) {
            this.skeleton.update();
            this.bucket.updateBoneTexture[0] = 1;
        } else {
            this.addAction(() => this.skeleton.update(), []);
        }
    },

    setTeamColor(id) {
        if (this.rendered) {
            this.teamColorArray[0] = id;
            this.bucket.updateTeamColors[0] = 1;
        } else {
            this.addAction((id) => this.setTeamColor(id), [id]);
        }

        return this;
    },

    setTintColor(color) {
        if (this.rendered) {
            this.tintColorArray.set(color);
            this.bucket.updateTintColors[0] = 1;
        } else {
            this.addAction((id) => this.setTintColor(color), [color]);
        }

        return this;
    },

    setSequence(id) {
        if (this.rendered) {
            this.sequence = id;
            this.frame = 0;

            // Update the skeleton in case this sequence isn't variant, and thus it won't get updated in the update function
            this.skeleton.update();
        } else {
            this.addAction((id) => this.setSequence(id), [id]);
        }

        return this;
    },

    setSequenceLoopMode(mode) {
        if (this.rendered) {
            this.sequenceLoopMode = mode;
        } else {
            this.addAction((mode) => this.setSequenceLoopMode(mode), [mode]);
        }

        return this;

    },

    getAttachment(id) {
        var attachment = this.model.getAttachment(id);

        if (attachment) {
            return this.skeleton.nodes[attachment.bone];
        } else {
            return this.skeleton.root;
        }
    }
};

mix(M3ModelInstance.prototype, ModelInstance.prototype);
const M3 = {
    initialize(env) {
        env.addHandler(Dds);
        env.addHandler(Tga);

        this.standardShader = env.webgl.createShaderProgram(env.sharedShaders.instanceId + env.sharedShaders.boneTexture + M3Shaders.vs_common + M3Shaders.vs_main, "#define STANDARD_PASS\n" + M3Shaders.ps_common + M3Shaders.ps_main);

        // If a shader failed to compile, don't allow the handler to be registered, and send an error instead.
        if (!this.standardShader.loaded) {
            return false;
        }

        const teamColors = [[255, 3, 3], [0, 66, 255], [28, 230, 185], [84, 0, 129], [255, 252, 1], [254, 138, 14], [32, 192, 0], [229, 91, 176], [149, 150, 151], [126, 191, 241], [16, 98, 70], [78, 42, 4], [40, 40, 40], [0, 0, 0]];

        this.lightPosition = [0, 0, 10000];

        this.teamColors = 14;

        const webgl = env.webgl,
            gl = env.gl;

        webgl.useShaderProgram(this.standardShader);

        for (let i = 0; i < 14; i++) {
            const color = teamColors[i];

            gl.uniform3fv(this.standardShader.uniforms.get("u_teamColors[" + i + "]"), [color[0] / 255, color[1] / 255, color[2] / 255]);
        }

        return true;
    },

    get extension() {
        return ".m3";
    },

    get Constructor() {
        return M3Model;
    },

    get ModelView() {
        return M3ModelView;
    },

    get Instance() {
        return M3ModelInstance;
    },

    get Bucket() {
        return M3Bucket;
    },

    get binaryFormat() {
        return true;
    }
};

mix(M3, ModelHandler);
